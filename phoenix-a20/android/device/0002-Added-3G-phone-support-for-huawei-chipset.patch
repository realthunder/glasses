From 7cbe2c3faa6339e68ded5efc40bc4ac29100cbca Mon Sep 17 00:00:00 2001
From: "Zheng,Lei" <realthunder.dev@gmail.com>
Date: Thu, 4 Dec 2014 19:21:55 -0800
Subject: [PATCH 2/2] Added 3G phone support for huawei chipset

---
 softwinner/common/hardware/audio/Android.mk        |   18 +-
 softwinner/common/hardware/audio/audio_hw.c        | 1821 ++++++--------------
 softwinner/common/hardware/audio/audio_iface.c     |  238 +++
 softwinner/common/hardware/audio/audio_iface.h     |  113 ++
 softwinner/common/hardware/audio/audio_policy.conf |   24 +-
 softwinner/common/hardware/audio/audio_ril.h       |   40 -
 softwinner/common/hardware/audio/audio_ril_stub.c  |   39 -
 .../hardware/audio/libcodec_audio/Android.mk       |   50 +
 .../hardware/audio/libcodec_audio/asoundlib.h      |  242 +++
 .../common/hardware/audio/libcodec_audio/codec.c   |  131 ++
 .../hardware/audio/libcodec_audio/codec_devices.c  |   57 +
 .../hardware/audio/libcodec_audio/codec_devices.h  |   63 +
 .../libcodec_audio/codec_devices/pad/manage.c      |  445 +++++
 .../audio/libcodec_audio/codec_devices/pad/pad.c   |  224 +++
 .../audio/libcodec_audio/codec_devices/pad/pad.h   |   11 +
 .../libcodec_audio/codec_devices/planOne/manage.c  |  493 ++++++
 .../codec_devices/planOne/plan_one.c               |  540 ++++++
 .../codec_devices/planOne/plan_one.h               |   18 +
 .../codec_devices/planThree/manage.c               |  649 +++++++
 .../libcodec_audio/codec_devices/planThree/plan.c  |  479 +++++
 .../libcodec_audio/codec_devices/planThree/plan.h  |   20 +
 .../libcodec_audio/codec_devices/planTwo/manage.c  |  649 +++++++
 .../codec_devices/planTwo/plan_two.c               |  464 +++++
 .../codec_devices/planTwo/plan_two.h               |   20 +
 .../hardware/audio/libcodec_audio/codec_utils.c    |  402 +++++
 .../hardware/audio/libcodec_audio/codec_utils.h    |  148 ++
 .../hardware/audio/libcodec_audio/hal_codec.h      |   87 +
 .../common/hardware/audio/libcodec_audio/mixer.c   |  416 +++++
 .../common/hardware/audio/libcodec_audio/pcm.c     |  791 +++++++++
 .../common/hardware/audio/libcodec_audio/record.c  |  300 ++++
 .../common/hardware/audio/libcodec_audio/record.h  |   17 +
 .../hardware/audio/libcodec_audio/volume_conf.c    |  277 +++
 .../hardware/audio/libcodec_audio/wakelock.cpp     |   90 +
 .../common/hardware/audio/libcodec_audio/wav.c     |  129 ++
 .../common/hardware/audio/libcodec_audio/wav.h     |    9 +
 .../common/hardware/audio/libril_audio/Android.mk  |   51 +
 softwinner/common/hardware/audio/libril_audio/bp.c |   71 +
 .../hardware/audio/libril_audio/bp_devices.c       |   42 +
 .../hardware/audio/libril_audio/bp_devices.h       |   34 +
 .../audio/libril_audio/bp_devices/demo/demo.c      |  173 ++
 .../audio/libril_audio/bp_devices/demo/demo.h      |   12 +
 .../audio/libril_audio/bp_devices/mu509/mu509.c    |  160 ++
 .../audio/libril_audio/bp_devices/mu509/mu509.h    |   12 +
 .../audio/libril_audio/bp_devices/mu709/mu709.c    |  133 ++
 .../libril_audio/bp_devices/oviphone_em55/em55.c   |  107 ++
 .../libril_audio/bp_devices/oviphone_em55/em55.h   |   12 +
 .../libril_audio/bp_devices/usi6276/usi6276.c      |  173 ++
 .../libril_audio/bp_devices/usi6276/usi6276.h      |   12 +
 .../common/hardware/audio/libril_audio/bp_utils.c  |   13 +
 .../common/hardware/audio/libril_audio/bp_utils.h  |   26 +
 .../common/hardware/audio/libril_audio/hal_bp.h    |   25 +
 softwinner/common/hardware/audio/phone_volume.conf |   60 +
 softwinner/common/rild/ip-down                     |    1 +
 softwinner/common/rild/ip-up                       |    1 +
 softwinner/common/rild/libhuawei-ril.so            |  Bin 0 -> 120556 bytes
 softwinner/common/sw-common.mk                     |    4 +-
 .../frameworks/base/core/res/res/values/config.xml |    2 +-
 .../SettingsProvider/res/values/defaults.xml       |    2 +
 softwinner/sugar-standard/sugar_standard.mk        |   29 +-
 softwinner/wing-common/ProductCommon.mk            |   18 +-
 60 files changed, 9311 insertions(+), 1376 deletions(-)
 mode change 100755 => 100644 softwinner/common/hardware/audio/Android.mk
 mode change 100755 => 100644 softwinner/common/hardware/audio/audio_hw.c
 create mode 100644 softwinner/common/hardware/audio/audio_iface.c
 create mode 100644 softwinner/common/hardware/audio/audio_iface.h
 mode change 100755 => 100644 softwinner/common/hardware/audio/audio_policy.conf
 delete mode 100755 softwinner/common/hardware/audio/audio_ril.h
 delete mode 100755 softwinner/common/hardware/audio/audio_ril_stub.c
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/Android.mk
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/asoundlib.h
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/codec.c
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/codec_devices.c
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/codec_devices.h
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/codec_devices/pad/manage.c
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/codec_devices/pad/pad.c
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/codec_devices/pad/pad.h
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/codec_devices/planOne/manage.c
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/codec_devices/planOne/plan_one.c
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/codec_devices/planOne/plan_one.h
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/codec_devices/planThree/manage.c
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/codec_devices/planThree/plan.c
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/codec_devices/planThree/plan.h
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/codec_devices/planTwo/manage.c
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/codec_devices/planTwo/plan_two.c
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/codec_devices/planTwo/plan_two.h
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/codec_utils.c
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/codec_utils.h
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/hal_codec.h
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/mixer.c
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/pcm.c
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/record.c
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/record.h
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/volume_conf.c
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/wakelock.cpp
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/wav.c
 create mode 100644 softwinner/common/hardware/audio/libcodec_audio/wav.h
 create mode 100644 softwinner/common/hardware/audio/libril_audio/Android.mk
 create mode 100644 softwinner/common/hardware/audio/libril_audio/bp.c
 create mode 100644 softwinner/common/hardware/audio/libril_audio/bp_devices.c
 create mode 100644 softwinner/common/hardware/audio/libril_audio/bp_devices.h
 create mode 100644 softwinner/common/hardware/audio/libril_audio/bp_devices/demo/demo.c
 create mode 100644 softwinner/common/hardware/audio/libril_audio/bp_devices/demo/demo.h
 create mode 100644 softwinner/common/hardware/audio/libril_audio/bp_devices/mu509/mu509.c
 create mode 100644 softwinner/common/hardware/audio/libril_audio/bp_devices/mu509/mu509.h
 create mode 100644 softwinner/common/hardware/audio/libril_audio/bp_devices/mu709/mu709.c
 create mode 100644 softwinner/common/hardware/audio/libril_audio/bp_devices/oviphone_em55/em55.c
 create mode 100644 softwinner/common/hardware/audio/libril_audio/bp_devices/oviphone_em55/em55.h
 create mode 100644 softwinner/common/hardware/audio/libril_audio/bp_devices/usi6276/usi6276.c
 create mode 100644 softwinner/common/hardware/audio/libril_audio/bp_devices/usi6276/usi6276.h
 create mode 100644 softwinner/common/hardware/audio/libril_audio/bp_utils.c
 create mode 100644 softwinner/common/hardware/audio/libril_audio/bp_utils.h
 create mode 100644 softwinner/common/hardware/audio/libril_audio/hal_bp.h
 create mode 100644 softwinner/common/hardware/audio/phone_volume.conf
 create mode 100644 softwinner/common/rild/libhuawei-ril.so

diff --git a/softwinner/common/hardware/audio/Android.mk b/softwinner/common/hardware/audio/Android.mk
old mode 100755
new mode 100644
index ac1016c..250c6fc
--- a/softwinner/common/hardware/audio/Android.mk
+++ b/softwinner/common/hardware/audio/Android.mk
@@ -20,21 +20,25 @@ LOCAL_MODULE := audio.primary.$(TARGET_BOARD_PLATFORM)
 
 LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
 
-LOCAL_SRC_FILES := audio_hw.c
+LOCAL_SRC_FILES := audio_hw.c audio_iface.c
 
-ifneq ($(SW_BOARD_HAVE_3G), true)
-LOCAL_SRC_FILES += audio_ril_stub.c
-else
-LOCAL_SHARED_LIBRARIES := libaudio_ril
-endif
+#ifneq ($(SW_BOARD_HAVE_3G), true)
+#LOCAL_SRC_FILES += audio_ril_stub.c
+#else
+#LOCAL_SHARED_LIBRARIES := libaudio_ril
+#endif
 
 LOCAL_C_INCLUDES += \
 	external/tinyalsa/include \
 	system/media/audio_utils/include \
 	system/media/audio_effects/include
 	
-LOCAL_SHARED_LIBRARIES += liblog libcutils libtinyalsa libaudioutils libdl
+LOCAL_SHARED_LIBRARIES += liblog libcutils libtinyalsa libaudioutils libdl libcodec_audio libril_audio
 LOCAL_MODULE_TAGS := optional
 
 include $(BUILD_SHARED_LIBRARY)
 
+include $(call all-makefiles-under, $(LOCAL_PATH))
+
+
+
diff --git a/softwinner/common/hardware/audio/audio_hw.c b/softwinner/common/hardware/audio/audio_hw.c
old mode 100755
new mode 100644
index 3c81849..2363ee2
--- a/softwinner/common/hardware/audio/audio_hw.c
+++ b/softwinner/common/hardware/audio/audio_hw.c
@@ -15,7 +15,7 @@
  */
 
 #define LOG_TAG "audio_hw_primary"
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 
 #include <errno.h>
 #include <pthread.h>
@@ -38,32 +38,19 @@
 #include <audio_effects/effect_aec.h>
 #include <fcntl.h>
 
-#include "audio_ril.h"
+#include "audio_iface.h"
 
 #include <cutils/properties.h> // for property_get
 
 #define F_LOG ALOGV("%s, line: %d", __FUNCTION__, __LINE__);
 
-#define  CALL_VOLUME_MAX    59
-#define  CALL_VOLUME_MIN    0
-static int call_volume = CALL_VOLUME_MAX;
-
-
-#define PRO_AUDIO_MULTI_OUTPUT		"ro.audio.multi.output"
-#define PRO_AUDIO_OUTPUT_ACTIVE		"audio.output.active"
-#define PRO_AUDIO_INPUT_ACTIVE		"audio.input.active"
-
-/* Mixer control names */
-#define MIXER_MASTER_PLAYBACK_VOLUME   		"Master Playback Volume"
-#define MIXER_AUDIO_SPEAKER_OUT             "Audio speaker out"
-
 /* ALSA cards for A1X */
 #define CARD_A1X_CODEC		0
 #define CARD_A1X_HDMI		1
 #define CARD_A1X_SPDIF		2
 #define CARD_A1X_DEFAULT	CARD_A1X_CODEC
 
-/* ALSA ports for A10 */
+/* ALSA ports for A1X */
 #define PORT_CODEC			0
 #define PORT_HDMI			0
 #define PORT_SPDIF			0
@@ -77,10 +64,11 @@ static int call_volume = CALL_VOLUME_MAX;
 /* constraint imposed by ABE: all period sizes must be multiples of 24 */
 #define ABE_BASE_FRAME_COUNT 24
 /* number of base blocks in a short period (low latency) */
-//#define SHORT_PERIOD_MULTIPLIER 44  /* 22 ms */
-#define SHORT_PERIOD_MULTIPLIER 44  /* 40 ms */
+#define SHORT_PERIOD_MULTIPLIER 44  /* 22 ms */
+//#define SHORT_PERIOD_MULTIPLIER 55 /* 40 ms */
 /* number of frames per short period (low latency) */
 #define SHORT_PERIOD_SIZE (ABE_BASE_FRAME_COUNT * SHORT_PERIOD_MULTIPLIER)
+// #define SHORT_PERIOD_SIZE 1360
 /* number of short periods in a long period (low power) */
 //#define LONG_PERIOD_MULTIPLIER 14  /* 308 ms */
 #define LONG_PERIOD_MULTIPLIER 6  /* 240 ms */
@@ -100,6 +88,7 @@ static int call_volume = CALL_VOLUME_MAX;
 #define DEFAULT_OUT_SAMPLING_RATE SAMPLING_RATE_44K
 
 /* audio codec default sampling rate*/
+// #define MM_SAMPLING_RATE SAMPLING_RATE_44K
 #define MM_SAMPLING_RATE SAMPLING_RATE_44K
 
 /*wifi display buffer size*/
@@ -137,42 +126,25 @@ struct route_setting
 
 struct mixer_ctls
 {
-	struct mixer_ctl *master_playback_volume;
-    struct mixer_ctl *audio_speaker_out;
-};
+    struct mixer_ctl *master_playback_volume;		//
+    struct mixer_ctl *audio_spk_headset_switch;
+};  
 
 struct pcm_buf_manager
 {
 	pthread_mutex_t lock;       		/* see note below on mutex acquisition order */
 	bool 		    BufExist;
-    unsigned char   *BufStart;        
-    int             BufTotalLen;      
-    unsigned char   *BufReadPtr;      
-    int             DataLen;          
-    unsigned char   *BufWritPtr;      
-    int            	BufValideLen;       
+    unsigned char   *BufStart;
+    int             BufTotalLen;
+    unsigned char   *BufReadPtr;
+    int             DataLen;
+    unsigned char   *BufWritPtr;
+    int            	BufValideLen;
     int				SampleRate;
     int				Channel;
-};
-
-#define MAX_AUDIO_DEVICES	16
 
-typedef enum e_AUDIO_DEVICE_MANAGEMENT
-{
-	AUDIO_IN		= 0x01,
-	AUDIO_OUT		= 0x02,
-}e_AUDIO_DEVICE_MANAGEMENT;
-
-typedef struct sunxi_audio_device_manager {
-	char		name[32];
-	int			card;
-	int			device;
-	int			flag_in;			//
-	int			flag_in_active;		// 0: do not use, 1: used to caputre or playback
-	int			flag_out;
-	int			flag_out_active;	// 0: do not use, 1: used to caputre or playback
-	bool		flag_exist;			// for hot-plugging
-}sunxi_audio_device_manager;
+	struct sunxi_audio_device *dev;
+};
 
 struct sunxi_audio_device {
     struct audio_hw_device hw_device;
@@ -181,7 +153,8 @@ struct sunxi_audio_device {
     struct mixer *mixer;
     struct mixer_ctls mixer_ctls;
     int mode;
-    int devices;
+	int out_device;
+    int in_device;
     struct pcm *pcm_modem_dl;
     struct pcm *pcm_modem_ul;
     int in_call;
@@ -194,14 +167,9 @@ struct sunxi_audio_device {
     bool bluetooth_nrec;
     int wb_amr;
 	bool raw_flag;		// flag for raw data
-
-	// add for audio device management
-	struct sunxi_audio_device_manager dev_manager[MAX_AUDIO_DEVICES];
-	int usb_audio_cnt;
-	char in_devices[128], out_devices[128];
-	char out_device_active_req[128];
-	bool support_multi_ouput;
-	bool first_set_audio_routing;
+    int fm_mode;
+    bool in_record;
+    bool bluetooth_voice;
 	bool af_capture_flag;
 	struct pcm_buf_manager PcmManager;
 };
@@ -210,13 +178,10 @@ struct sunxi_stream_out {
     struct audio_stream_out stream;
 
     pthread_mutex_t lock;       /* see note below on mutex acquisition order */
-	struct pcm_config config;
-	struct pcm_config multi_config[16];
-	struct pcm *pcm;
-	struct pcm *multi_pcm[16];
-	struct resampler_itfe *resampler;
-	struct resampler_itfe *multi_resampler[16];
-	char *buffer;
+    struct pcm_config config;
+    struct pcm *pcm;
+    struct resampler_itfe *resampler;
+    char *buffer;
     int standby;
     struct echo_reference_itfe *echo_reference;
     struct sunxi_audio_device *dev;
@@ -399,26 +364,43 @@ static int ReadPcmData(void *pBuf, int uGetLen, struct pcm_buf_manager *PcmManag
 	int size_read = uGetLen;
 	int timeout = 0, max_wait_count;
 
+	struct sunxi_audio_device *adev = PcmManager->dev;
+
 	max_wait_count = uGetLen * 100 / (PcmManager->SampleRate*PcmManager->Channel * 2) + 1; //normal
 	max_wait_count *= 2;//twice
 
 	ALOGV("ReadPcmDataForEnc ++, getLen: %d max_wait_count=%d", uGetLen,max_wait_count);
-    while(PcmManager->DataLen < uGetLen)
-    {
+	if (adev->active_output != NULL)
+	{
+	    while(PcmManager->DataLen < uGetLen)
+	    {
+	        ALOGV("pcm is not enough for audio encoder! uGetLen: %d, uDataLen: %d\n",
+				uGetLen, PcmManager->DataLen);
+	        usleep(10 * 1000);
+	        timeout++;
+			if(timeout > max_wait_count) {
+				if (PcmManager->DataLen < uGetLen) {
+					underflow = 1;
+					size_read = PcmManager->DataLen;
+					fill_dc_size = uGetLen - PcmManager->DataLen;
+					ALOGV("fill with dc size:%d",uGetLen - PcmManager->DataLen);
+				}
+			break;
+	        }
+	    }
+	}
+	else
+	{
         ALOGV("pcm is not enough for audio encoder! uGetLen: %d, uDataLen: %d\n",
 			uGetLen, PcmManager->DataLen);
-        usleep(10*1000);
-        timeout++;
-        if(timeout > max_wait_count) {
-        	if (PcmManager->DataLen < uGetLen) {
-        		underflow = 1;
-        		size_read = PcmManager->DataLen;
-        		fill_dc_size = uGetLen - PcmManager->DataLen;
-        		ALOGV("fill with dc size:%d",uGetLen - PcmManager->DataLen);
-        	}
-        	break;
-        }
-    }
+		if (PcmManager->DataLen < uGetLen) {
+			underflow = 1;
+			size_read = PcmManager->DataLen;
+			fill_dc_size = uGetLen - PcmManager->DataLen;
+			usleep(fill_dc_size * 1000000 / 4 / PcmManager->SampleRate);
+			ALOGV("fill with dc size:%d",uGetLen - PcmManager->DataLen);
+		}
+	}
 
     if((PcmManager->BufReadPtr + size_read)
 		> (PcmManager->BufStart + PcmManager->BufTotalLen))
@@ -448,7 +430,7 @@ static int ReadPcmData(void *pBuf, int uGetLen, struct pcm_buf_manager *PcmManag
 	ALOGV("after rd: BufTotalLen: %d, DataLen: %d, BufValideLen: %d, pBufReadPtr: %p, pBufWritPtr: %p",
 		PcmManager->BufTotalLen, PcmManager->DataLen, PcmManager->BufValideLen,
 		PcmManager->BufReadPtr, PcmManager->BufWritPtr);
-	
+
 	pthread_mutex_unlock(&PcmManager->lock);
 	ALOGV("ReadPcmDataForEnc --");
 
@@ -471,617 +453,6 @@ static int adev_set_voice_volume(struct audio_hw_device *dev, float volume);
 static int do_input_standby(struct sunxi_stream_in *in);
 static int do_output_standby(struct sunxi_stream_out *out);
 
-typedef struct name_map_t
-{
-	char name_linux[32];
-	char name_android[32];
-}name_map;
-
-#define AUDIO_MAP_CNT	8
-#define AUDIO_NAME_CODEC	"AUDIO_CODEC"
-#define AUDIO_NAME_HDMI		"AUDIO_HDMI"
-#define AUDIO_NAME_SPDIF	"AUDIO_SPDIF"
-#define AUDIO_NAME_I2S		"AUDIO_I2S"
-
-static name_map audio_name_map[AUDIO_MAP_CNT] =
-{
-	{"audiocodec",		AUDIO_NAME_CODEC},
-	{"sndhdmi",			AUDIO_NAME_HDMI},
-	{"sndspdif",		AUDIO_NAME_SPDIF},
-};
-
-static int set_audio_devices_active(struct sunxi_audio_device *adev, int in_out, char * devices);
-
-static int find_name_map(struct sunxi_audio_device *adev, char * in, char * out)
-{
-	int index = 0;
-
-	if (in == 0 || out == 0)
-	{
-		ALOGE("error params");
-		return -1;
-	}
-
-	for (; index < AUDIO_MAP_CNT; index++)
-	{
-		if (strlen(audio_name_map[index].name_linux) == 0)
-		{
-
-			sprintf(out, "AUDIO_USB%d", adev->usb_audio_cnt++);
-			strcpy(audio_name_map[index].name_linux, in);
-			strcpy(audio_name_map[index].name_android, out);
-			ALOGD("linux name = %s, android name = %s",
-				audio_name_map[index].name_linux,
-				audio_name_map[index].name_android);
-			return 0;
-		}
-
-		if (!strcmp(in, audio_name_map[index].name_linux))
-		{
-			strcpy(out, audio_name_map[index].name_android);
-			ALOGD("linux name = %s, android name = %s",
-				audio_name_map[index].name_linux,
-				audio_name_map[index].name_android);
-			return 0;
-		}
-	}
-
-	return 0;
-}
-
-static int do_init_audio_card(struct sunxi_audio_device *adev, int card)
-{
-	int ret = -1;
-	int fd = 0;
-	char * snd_path = "/sys/class/sound";
-	char snd_card[128], snd_node[128];
-	char snd_id[32], snd_name[32];
-
-	memset(snd_card, 0, sizeof(snd_card));
-	memset(snd_node, 0, sizeof(snd_node));
-	memset(snd_id, 0, sizeof(snd_id));
-	memset(snd_name, 0, sizeof(snd_name));
-
-	sprintf(snd_card, "%s/card%d", snd_path, card);
-	ret = access(snd_card, F_OK);
-	if(ret == 0)
-	{
-		// id / name
-		sprintf(snd_node, "%s/card%d/id", snd_path, card);
-		ALOGD("read card %s/card%d/id",snd_path, card);
-		fd = open(snd_node, O_RDONLY);
-		if (fd > 0)
-		{
-			ret = read(fd, snd_id, sizeof(snd_id));
-			if (ret > 0)
-			{
-				snd_id[ret - 1] = 0;
-				ALOGD("%s, %s, len: %d", snd_node, snd_id, ret);
-			}
-			close(fd);
-		}
-		else
-		{
-			return -1;
-		}
-		ALOGD("find name map");
-		find_name_map(adev, snd_id, snd_name);
-		strcpy(adev->dev_manager[card].name, snd_name);
-
-		adev->dev_manager[card].card = card;
-		adev->dev_manager[card].device = 0;
-		adev->dev_manager[card].flag_exist = true;
-
-		// playback device
-		sprintf(snd_node, "%s/card%d/pcmC%dD0p", snd_path, card, card);
-		ret = access(snd_node, F_OK);
-		if(ret == 0)
-		{
-			// there is a playback device
-			adev->dev_manager[card].flag_out = AUDIO_OUT;
-			adev->dev_manager[card].flag_out_active = 0;
-		}
-
-		// capture device
-		sprintf(snd_node, "%s/card%d/pcmC%dD0c", snd_path, card, card);
-		ret = access(snd_node, F_OK);
-		if(ret == 0)
-		{
-			// there is a capture device
-			adev->dev_manager[card].flag_in = AUDIO_IN;
-			adev->dev_manager[card].flag_in_active = 0;
-		}
-	}
-	else
-	{
-		return -1;
-	}
-
-	return 0;
-}
-
-static void init_audio_devices(struct sunxi_audio_device *adev)
-{
-	int card = 0;
-
-	F_LOG;
-
-	memset(adev->dev_manager, 0, sizeof(adev->dev_manager));
-
-	for (card = 0; card < MAX_AUDIO_DEVICES; card++)
-	{
-		if (do_init_audio_card(adev, card) == 0)
-		{
-			// break;
-			ALOGV("card: %d, name: %s, capture: %d, playback: %d",
-				card, adev->dev_manager[card].name,
-				adev->dev_manager[card].flag_in == AUDIO_IN,
-				adev->dev_manager[card].flag_out == AUDIO_OUT);
-		}
-	}
-}
-
-static void init_audio_devices_active(struct sunxi_audio_device *adev)
-{
-	int card = 0;
-	int flag_active = 0;
-	char * active_name_in;
-	char * active_name_out;
-
-	F_LOG;
-
-	// high priority, due to the proprety
-	char prop_value_in[128];
-	int ret = property_get(PRO_AUDIO_INPUT_ACTIVE, prop_value_in, "");
-	if (ret > 0)
-	{
-		ALOGV("init_audio_devices_active: get property %s: %s", PRO_AUDIO_INPUT_ACTIVE, prop_value_in);
-		if (set_audio_devices_active(adev, AUDIO_IN, prop_value_in) == 0)
-		{
-			active_name_in = prop_value_in;
-			flag_active |= AUDIO_IN;
-		}
-	}
-	else
-	{
-		ALOGV("init_audio_devices_active: get property %s failed, %s", PRO_AUDIO_INPUT_ACTIVE, strerror(errno));
-	}
-
-	char prop_value_out[128];
-	ret = property_get(PRO_AUDIO_OUTPUT_ACTIVE, prop_value_out, "");
-	if (ret > 0)
-	{
-		ALOGV("init_audio_devices_active: get property %s: %s", PRO_AUDIO_OUTPUT_ACTIVE, prop_value_out);
-		if (set_audio_devices_active(adev, AUDIO_OUT, prop_value_out) == 0)
-		{
-			active_name_out = prop_value_out;
-			flag_active |= AUDIO_OUT;
-		}
-	}
-	else
-	{
-		ALOGV("init_audio_devices_active: get property %s failed, %s", PRO_AUDIO_OUTPUT_ACTIVE, strerror(errno));
-	}
-
-	if ((flag_active & AUDIO_IN)
-		&& (flag_active & AUDIO_OUT))
-	{
-		goto INIT_END;
-	}
-
-	// midle priority, use codec
-	for (card = 0; card < MAX_AUDIO_DEVICES; card++)
-	{
-		// default use auido codec in/out
-		if (adev->dev_manager[card].flag_exist
-			&& (!strcmp(adev->dev_manager[card].name, AUDIO_NAME_CODEC)))
-		{
-			if (!(flag_active & AUDIO_IN)
-				&& (adev->dev_manager[card].flag_in == AUDIO_IN))
-			{
-				ALOGV("OK, default use %s capture", adev->dev_manager[card].name);
-				active_name_in = adev->dev_manager[card].name;
-				adev->dev_manager[card].flag_in_active = 1;
-				flag_active |= AUDIO_IN;
-			}
-			if (!(flag_active & AUDIO_OUT)
-				&& (adev->dev_manager[card].flag_out == AUDIO_OUT))
-			{
-				ALOGV("OK, default use %s playback", adev->dev_manager[card].name);
-				active_name_out = adev->dev_manager[card].name;
-				adev->dev_manager[card].flag_out_active = 1;
-				flag_active |= AUDIO_OUT;
-			}
-
-			break;
-		}
-	}
-
-	if ((flag_active & AUDIO_IN)
-		&& (flag_active & AUDIO_OUT))
-	{
-		goto INIT_END;
-	}
-
-	// low priority, chose any device
-	for (card = 0; card < MAX_AUDIO_DEVICES; card++)
-	{
-		if (!adev->dev_manager[card].flag_exist)
-		{
-			break;
-		}
-
-		// there is no auido codec in
-		if (!(flag_active & AUDIO_IN))
-		{
-			if (adev->dev_manager[card].flag_in == AUDIO_IN)
-			{
-				ALOGV("OK, default use %s capture", adev->dev_manager[card].name);
-				active_name_in = adev->dev_manager[card].name;
-				adev->dev_manager[card].flag_in_active = 1;
-				flag_active |= AUDIO_IN;
-			}
-		}
-
-		// there is no auido codec out
-		if (!(flag_active & AUDIO_OUT))
-		{
-			if (adev->dev_manager[card].flag_out == AUDIO_OUT)
-			{
-				ALOGV("OK, default use %s playback", adev->dev_manager[card].name);
-				active_name_out = adev->dev_manager[card].name;
-				adev->dev_manager[card].flag_out_active = 1;
-				flag_active |= AUDIO_OUT;
-			}
-		}
-	}
-
-INIT_END:
-
-	if (flag_active & AUDIO_IN)
-	{
-		if (active_name_in)
-		{
-			adev->devices |= AUDIO_DEVICE_IN_BUILTIN_MIC;
-		}
-	}
-	else
-	{
-		ALOGW("there is not a audio capture devices");
-	}
-
-	if (flag_active & AUDIO_OUT)
-	{
-		if (active_name_out)
-		{
-			if (strstr(active_name_out, AUDIO_NAME_CODEC))
-			{
-				adev->devices |= AUDIO_DEVICE_OUT_SPEAKER;
-			}
-			if (strstr(active_name_out, AUDIO_NAME_SPDIF))
-			{
-				adev->devices |= AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET;
-			}
-			if (strstr(active_name_out, AUDIO_NAME_HDMI))
-			{
-				adev->devices |= AUDIO_DEVICE_OUT_AUX_DIGITAL;
-			}
-		}
-	}
-	else
-	{
-		ALOGW("there is not a audio playback devices");
-	}
-
-	ALOGV("OK, default adev->devices: %08x", adev->devices);
-}
-
-static int updata_audio_devices(struct sunxi_audio_device *adev)
-{
-	int card = 0;
-	int ret = -1;
-	int fd = 0;
-	char * snd_path = "/sys/class/sound";
-	char snd_card[128];
-
-	memset(snd_card, 0, sizeof(snd_card));
-
-	for (card = 0; card < MAX_AUDIO_DEVICES; card++)
-	{
-		sprintf(snd_card, "%s/card%d", snd_path, card);
-		ret = access(snd_card, F_OK);
-		if(ret == 0)
-		{
-			if (adev->dev_manager[card].flag_exist == true)
-			{
-				continue;		// no changes
-			}
-			else				// plug-in
-			{
-				ALOGD("do init audio card");
-				do_init_audio_card(adev, card);
-			}
-		}
-		else
-		{
-			if (adev->dev_manager[card].flag_exist == false)
-			{
-				continue;		// no changes
-			}
-			else				// plug-out
-			{
-				adev->dev_manager[card].flag_exist = false;
-				adev->dev_manager[card].flag_in = 0;
-				adev->dev_manager[card].flag_out = 0;
-			}
-		}
-	}
-
-	return 0;
-}
-
-static char * get_audio_devices(struct sunxi_audio_device *adev, int in_out)
-{
-	char * in_devices = adev->in_devices;
-	char * out_devices = adev->out_devices;
-
-	updata_audio_devices(adev);
-
-	memset(in_devices, 0, sizeof(adev->in_devices));
-	memset(out_devices, 0, sizeof(adev->out_devices));
-
-	ALOGD("getAudioDevices()");
-	int card = 0;
-	for(card = 0; card < MAX_AUDIO_DEVICES; card++)
-	{
-		if (adev->dev_manager[card].flag_exist == true)
-		{
-			if (adev->dev_manager[card].flag_in == AUDIO_IN)
-			{
-				strcat(in_devices, adev->dev_manager[card].name);
-				strcat(in_devices, ",");
-				ALOGD("in dev:%s",adev->dev_manager[card].name);
-			}
-
-			if (adev->dev_manager[card].flag_out == AUDIO_OUT)
-			{
-				strcat(out_devices, adev->dev_manager[card].name);
-				strcat(out_devices, ",");
-				ALOGD("out dev:%s",adev->dev_manager[card].name);
-			}
-		}
-	}
-
-	in_devices[strlen(in_devices) - 1] = 0;
-	out_devices[strlen(out_devices) - 1] = 0;
-
-	//
-	if (in_out & AUDIO_IN)
-	{
-		ALOGD("in capture: %s",in_devices);
-		return in_devices;
-	}
-	else if(in_out & AUDIO_OUT)
-	{
-		ALOGD("out playback: %s",out_devices);
-		return out_devices;
-	}
-	else
-	{
-		ALOGE("unknown in/out flag");
-		return 0;
-	}
-}
-
-static int set_audio_devices_active_internal(struct sunxi_stream_out *stream, int in_out, int value)
-{
-    struct sunxi_stream_out *out = (struct sunxi_stream_out *)stream;
-    struct sunxi_audio_device *adev = out->dev;
-	int card = 0;
-	char devices[128];
-	int ret = -1;
-
-	F_LOG;
-
-	switch(value & AUDIO_DEVICE_OUT_ALL) {
-        case AUDIO_DEVICE_OUT_EARPIECE:
-        case AUDIO_DEVICE_OUT_SPEAKER:
-		case AUDIO_DEVICE_OUT_WIRED_HEADSET:
-        case AUDIO_DEVICE_OUT_WIRED_HEADPHONE:
-			// codec
-			strcpy(devices, AUDIO_NAME_CODEC);
-            break;
-        case AUDIO_DEVICE_OUT_AUX_DIGITAL:
-			// hdmi
-			strcpy(devices, AUDIO_NAME_HDMI);
-            break;
-        case AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET:
-			// spdif
-			strcpy(devices, AUDIO_NAME_SPDIF);
-            break;
-        default:
-			//do nothing
-            // codec
-			//strcpy(devices, AUDIO_NAME_CODEC);
-			return 0;
-	}
-
-	if (in_out & AUDIO_OUT)
-	{
-		char prop_value_out[128];
-		ret = property_get(PRO_AUDIO_OUTPUT_ACTIVE, prop_value_out, "");
-		int odev = value & AUDIO_DEVICE_OUT_ALL;
-		if ((ret > 0)
-			&& adev->support_multi_ouput
-			/*&& (strlen(adev->out_device_active_req) > 0)*/)
-		{
-			// support multi-audio devices output at the same time
-			ALOGV("get property %s: %s", PRO_AUDIO_OUTPUT_ACTIVE, prop_value_out);
-			if(odev == AUDIO_DEVICE_OUT_WIRED_HEADPHONE
-				|| odev == AUDIO_DEVICE_OUT_AUX_DIGITAL)
-			{
-				//deal with:headphone plugin or HDMI plugin
-				ALOGV("just change to this audio device:%d", odev);
-			}
-			else if (!strstr(prop_value_out, devices))
-			{
-
-				strcat(devices, ",");
-				strcat(devices, prop_value_out);
-
-			}
-			else
-			{
-				strcpy(devices, prop_value_out);
-			}
-		}
-		if (strstr(prop_value_out, AUDIO_NAME_HDMI))
-		{
-			do_output_standby(out);
-		}
-	}
-	set_audio_devices_active(adev, in_out, devices);
-
-	return 0;
-}
-
-static int set_audio_devices_active(struct sunxi_audio_device *adev, int in_out, char * devices)
-{
-	int card = 0, i = 0;
-	char name[8][32];
-	int cnt = 0;
-	char str[128];
-	int ret = -1;
-
-	strcpy(str, devices);
-	char *pval = str;
-
-	if (pval == NULL)
-	{
-		return -1;
-	}
-
-	if (in_out & AUDIO_IN)
-	{
-		ret = property_set(PRO_AUDIO_INPUT_ACTIVE, devices);
-		if (ret < 0)
-		{
-			ALOGE("set property %s: %s failed", PRO_AUDIO_INPUT_ACTIVE, devices);
-		}
-		else
-		{
-			ALOGV("set property %s: %s ok", PRO_AUDIO_INPUT_ACTIVE, devices);
-		}
-	}
-
-	if (in_out & AUDIO_OUT)
-	{
-		ret = property_set(PRO_AUDIO_OUTPUT_ACTIVE, devices);
-		if (ret < 0)
-		{
-			ALOGE("set property %s: %s failed", PRO_AUDIO_OUTPUT_ACTIVE, devices);
-		}
-		else
-		{
-			ALOGV("set property %s: %s ok", PRO_AUDIO_OUTPUT_ACTIVE, devices);
-		}
-	}
-
-	char *seps = " ,";
-	pval = strtok(pval, seps);
-	while (pval != NULL)
-	{
-		strcpy(name[cnt++], pval);
-		pval = strtok(NULL, seps);
-	}
-
-	for (card = 0; card < MAX_AUDIO_DEVICES; card++)
-	{
-		if (in_out & AUDIO_IN)
-		{
-			adev->dev_manager[card].flag_in_active = 0;
-		}
-		else
-		{
-			adev->dev_manager[card].flag_out_active = 0;
-		}
-	}
-
-	for (i = 0; i < cnt; i++)
-	{
-		for (card = 0; card < MAX_AUDIO_DEVICES; card++)
-		{
-			if (in_out & AUDIO_IN)
-			{
-				if ((adev->dev_manager[card].flag_in == in_out)
-					&& (strcmp(adev->dev_manager[card].name, name[i]) == 0))
-				{
-					ALOGV("%s %s device will be active", name[i], "input");
-					adev->dev_manager[card].flag_in_active = 1;
-					// only one capture device can be active
-					return 0;
-				}
-			}
-			else
-			{
-				if ((adev->dev_manager[card].flag_out == in_out)
-					&& (strcmp(adev->dev_manager[card].name, name[i]) == 0))
-				{
-					ALOGV("%s %s device will be active", name[i], "output");
-					adev->dev_manager[card].flag_out_active = 1;
-					break;
-				}
-			}
-		}
-
-		if (card == MAX_AUDIO_DEVICES)
-		{
-			ALOGE("can not set %s %s active", name[i], (in_out & AUDIO_IN) ? "input" : "ouput");
-			return -1;
-		}
-	}
-
-	return 0;
-}
-
-static int get_audio_devices_active(struct sunxi_audio_device *adev, int in_out, char * devices)
-{
-	int card = 0, i = 0;
-	int flag_in_out = -1;
-
-	if (devices == 0)
-	{
-		return -1;
-	}
-
-	for (card = 0; card < MAX_AUDIO_DEVICES; card++)
-	{
-		if (in_out & AUDIO_IN)
-		{
-			if ((adev->dev_manager[card].flag_in == in_out)
-				&& (adev->dev_manager[card].flag_in_active == 1))
-			{
-				strcat(devices, adev->dev_manager[card].name);
-				strcat(devices, ",");
-			}
-		}
-		else
-		{
-			if ((adev->dev_manager[card].flag_out == in_out)
-				&& (adev->dev_manager[card].flag_out_active == 1))
-			{
-				strcat(devices, adev->dev_manager[card].name);
-				strcat(devices, ",");
-			}
-		}
-	}
-
-	devices[strlen(devices) - 1] = 0;
-
-	ALOGD("get_audio_devices_active: %s", devices);
-
-	return 0;
-}
 /* The enable flag when 0 makes the assumption that enums are disabled by
  * "Off" and integers/booleans by 0 */
 static int set_route_by_array(struct mixer *mixer, struct route_setting *route,
@@ -1120,31 +491,13 @@ static int set_route_by_array(struct mixer *mixer, struct route_setting *route,
 static int start_call(struct sunxi_audio_device *adev)
 {
     F_LOG;
-
-//	set_route_by_array(adev->mixer, mic1_up_routing, 1);
-//	set_route_by_array(adev->mixer, line_in_routing, 1);
-//	mixer_ctl_set_value(adev->mixer_ctls.playback_pamute_switch, 0, 1);		// in call mode must switch pa unmute
-
-	ril_set_call_volume(0, 1);
-
-//	mixer_ctl_set_value(adev->mixer_ctls.master_playback_volume, 0, (call_volume ? call_volume : CALL_VOLUME_MIN));
-
 	return 0;
 }
 
 static void end_call(struct sunxi_audio_device *adev)
 {
     F_LOG;
-	
-//	mixer_ctl_set_value(adev->mixer_ctls.playback_pamute_switch, 0, 0);
-    mixer_ctl_set_value(adev->mixer_ctls.audio_speaker_out, 0, 0);
-	usleep(5000);
-//	set_route_by_array(adev->mixer, mic1_up_routing, 0);
-//	set_route_by_array(adev->mixer, line_in_routing, 0);
-	
-	ril_set_call_audio_path(SOUND_AUDIO_PATH_SPEAKER);
-
-	mixer_ctl_set_value(adev->mixer_ctls.master_playback_volume, 0, CALL_VOLUME_MAX);
+    ALOGD("end_call, bluetooth_nrec=%d", adev->bluetooth_nrec);
 }
 
 static void set_incall_device(struct sunxi_audio_device *adev)
@@ -1153,36 +506,66 @@ static void set_incall_device(struct sunxi_audio_device *adev)
 
 	F_LOG;
 
-    switch(adev->devices & AUDIO_DEVICE_OUT_ALL) {
+    switch(adev->out_device) {
         case AUDIO_DEVICE_OUT_EARPIECE:
-            device_type = SOUND_AUDIO_PATH_HANDSET;
+            device_type = RIL_AUDIO_PATH_EARPIECE;
             break;
         case AUDIO_DEVICE_OUT_SPEAKER:
         case AUDIO_DEVICE_OUT_AUX_DIGITAL:
-            device_type = SOUND_AUDIO_PATH_SPEAKER;
+            device_type = RIL_AUDIO_PATH_SPK;
             break;
         case AUDIO_DEVICE_OUT_WIRED_HEADSET:
-            device_type = SOUND_AUDIO_PATH_HEADSET;
+            device_type = RIL_AUDIO_PATH_HEADSET;
             break;
         case AUDIO_DEVICE_OUT_WIRED_HEADPHONE:
-            device_type = SOUND_AUDIO_PATH_HEADPHONE;
+            device_type = RIL_AUDIO_PATH_HEADSET;
             break;
         case AUDIO_DEVICE_OUT_BLUETOOTH_SCO:
         case AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET:
         case AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT:
-            if (adev->bluetooth_nrec)
-                device_type = SOUND_AUDIO_PATH_BLUETOOTH;
-            else
-                device_type = SOUND_AUDIO_PATH_BLUETOOTH_NO_NR;
+            device_type = RIL_AUDIO_PATH_BT;
             break;
         default:
-            device_type = SOUND_AUDIO_PATH_HANDSET;
+            device_type = RIL_AUDIO_PATH_EARPIECE;
             break;
     }
 
 	ril_set_call_audio_path(device_type);
 }
 
+static void set_bp_volume(struct sunxi_audio_device *adev, int volume)
+{
+    int device_type;
+
+	F_LOG;
+
+    switch(adev->out_device) {
+        case AUDIO_DEVICE_OUT_EARPIECE:
+            device_type = RIL_AUDIO_PATH_EARPIECE;
+            break;
+        case AUDIO_DEVICE_OUT_SPEAKER:
+        case AUDIO_DEVICE_OUT_AUX_DIGITAL:
+            device_type = RIL_AUDIO_PATH_SPK;
+            break;
+        case AUDIO_DEVICE_OUT_WIRED_HEADSET:
+            device_type = RIL_AUDIO_PATH_HEADSET;
+            break;
+        case AUDIO_DEVICE_OUT_WIRED_HEADPHONE:
+            device_type = RIL_AUDIO_PATH_HEADSET;
+            break;
+        case AUDIO_DEVICE_OUT_BLUETOOTH_SCO:
+        case AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET:
+        case AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT:
+                device_type = RIL_AUDIO_PATH_BT;
+            break;
+        default:
+            device_type = RIL_AUDIO_PATH_EARPIECE;
+            break;
+    }
+
+    ril_set_call_volume(device_type, volume);
+}
+
 static void force_all_standby(struct sunxi_audio_device *adev)
 {
     struct sunxi_stream_in *in;
@@ -1205,7 +588,7 @@ static void force_all_standby(struct sunxi_audio_device *adev)
 
 static void select_mode(struct sunxi_audio_device *adev)
 {
-    if (adev->mode == AUDIO_MODE_IN_CALL) {
+    if (adev->mode == AUDIO_MODE_IN_CALL || adev->mode == AUDIO_MODE_MODE_FACTORY_TEST) {
         ALOGV("Entering IN_CALL state, in_call=%d", adev->in_call);
         if (!adev->in_call) {
             force_all_standby(adev);
@@ -1215,17 +598,19 @@ static void select_mode(struct sunxi_audio_device *adev)
             after the ringtone is played, but doesn't cause a route
             change if a headset or bt device is already connected. If
             speaker is not the only thing active, just remove it from
-            the route. We'll assume it'll never be used initally during
+            the route. We'll assume it'll never be used initially during
             a call. This works because we're sure that the audio policy
             manager will update the output device after the audio mode
             change, even if the device selection did not change. */
-            if ((adev->devices & AUDIO_DEVICE_OUT_ALL) == AUDIO_DEVICE_OUT_SPEAKER)
-                adev->devices = AUDIO_DEVICE_OUT_EARPIECE |
-                                AUDIO_DEVICE_IN_BUILTIN_MIC;
-            else
-                adev->devices &= ~AUDIO_DEVICE_OUT_SPEAKER;
-            select_output_device(adev);
+            if (adev->out_device == AUDIO_DEVICE_OUT_SPEAKER) {
+                adev->out_device = AUDIO_DEVICE_OUT_EARPIECE;
+                adev->in_device = AUDIO_DEVICE_IN_BUILTIN_MIC & ~AUDIO_DEVICE_BIT_IN;
+            } else
+                adev->out_device &= ~AUDIO_DEVICE_OUT_SPEAKER;
+
             start_call(adev);
+            select_output_device(adev);
+
 
             adev_set_voice_volume(&adev->hw_device, adev->voice_volume);
             adev->in_call = 1;
@@ -1241,80 +626,62 @@ static void select_mode(struct sunxi_audio_device *adev)
             select_input_device(adev);
         }
     }
-}
-
-static void select_output_device(struct sunxi_audio_device *adev)
-{
-	int ret = -1;
-    int headset_on;
-    int headphone_on;
-    int speaker_on;
-    int earpiece_on;
-    int bt_on;
+	
 
-    headset_on = adev->devices & AUDIO_DEVICE_OUT_WIRED_HEADSET;
-    headphone_on = adev->devices & AUDIO_DEVICE_OUT_WIRED_HEADPHONE;
-    speaker_on = adev->devices & AUDIO_DEVICE_OUT_SPEAKER;
-    earpiece_on = adev->devices & AUDIO_DEVICE_OUT_EARPIECE;
-    bt_on = adev->devices & AUDIO_DEVICE_OUT_ALL_SCO;
+    if (adev->mode == AUDIO_MODE_IN_COMMUNICATION) {
+        ALOGV("AUDIO_MODE_IN_COMMUNICATION");
+        select_output_device(adev);
+    }
 
-	ALOGV("select_output_device, devices: %x, mode: %x", adev->devices, adev->mode);
+    if (adev->mode == AUDIO_MODE_FM) {
+            force_all_standby(adev);
+            select_output_device(adev);
+            adev_set_voice_volume(&adev->hw_device, adev->voice_volume);
+    }
 
-	int pa_should_on = speaker_on;
+}
 
-	char prop_value[16];
-	ret = property_get("audio.without.earpiece", prop_value, "");
-	if (ret > 0)
-	{
-		ALOGD("get property audio.without.earpiece: %s", prop_value);
-		if (strcmp(prop_value, "true") == 0)
-		{
-			pa_should_on |= earpiece_on;
+static void select_output_device(struct sunxi_audio_device *adev)
+{
+    int ret = -1;
+
+	//ALOGV("select_output_device, devices: %x, mode: %x", adev->devices, adev->mode);
+	//ALOGV("select_output_device, headset_on=%x,headphone_on=%x,speaker_on=%x,earpiece_on=%x,bt_on=%x",headset_on,headphone_on,speaker_on,earpiece_on,bt_on);
+
+	//lkj
+	if (adev->mode == AUDIO_MODE_NORMAL){
+		normal_play_route(adev->out_device);
+		ALOGV("normal mode , speaker,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	} else if (adev->mode == AUDIO_MODE_RINGTONE){
+		normal_play_route(adev->out_device);
+		normal_play_volume(AUDIO_DEVICE_OUT_WIRED_HEADSET, 60);
+		normal_play_volume(AUDIO_DEVICE_OUT_SPEAKER, 60);
+		ALOGV("RINGTONE mode, ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	} else if (adev->mode == AUDIO_MODE_FM){
+		fm_play_route(adev->out_device);
+		ALOGV("FM mode, headset or speaker on,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	} else 	if (adev->mode == AUDIO_MODE_MODE_FACTORY_TEST) {
+		ril_set_call_at("AT^ECHO1ON");// bp to loop mode
+		//set_incall_device(adev);
+		factory_route(adev->out_device);
+		ALOGV("FACTORY mode, ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	} else 	if (adev->mode == AUDIO_MODE_IN_CALL) {
+		if (adev->out_device & AUDIO_DEVICE_OUT_ALL_SCO){
+			adev->bluetooth_voice = true;
+		} else {
+			adev->bluetooth_voice = false;
 		}
-	}
 
-    // mute/unmute speaker
-	if (adev->mode == AUDIO_MODE_IN_CALL) 
-	{		
-		if(pa_should_on)
-		{
-			//mixer_ctl_set_value(adev->mixer_ctls.audio_earpiece_out, 0, 0);
-			//mixer_ctl_set_value(adev->mixer_ctls.audio_headphone_out, 0, 0);
-			mixer_ctl_set_value(adev->mixer_ctls.audio_speaker_out, 0, 1);
-            ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
-		}
-		else
-		{
-			if(earpiece_on)
-			{
-                //mixer_ctl_set_value(adev->mixer_ctls.audio_earpiece_out, 0, 1);
-                //mixer_ctl_set_value(adev->mixer_ctls.audio_headphone_out, 0, 0);
-				mixer_ctl_set_value(adev->mixer_ctls.audio_speaker_out, 0, 0);
-                ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
-			}
-			else
-			{
-				//mixer_ctl_set_value(adev->mixer_ctls.audio_earpiece_out, 0, 0);
-				//mixer_ctl_set_value(adev->mixer_ctls.audio_headphone_out, 0, 1)
-				mixer_ctl_set_value(adev->mixer_ctls.audio_speaker_out, 0, 0);
-				ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
-			}
-		}
+		phone_play_route(adev->out_device);
 		set_incall_device(adev);
-	}
-	else
-	{
-		//mixer_ctl_set_value(adev->mixer_ctls.audio_spk_switch, 0, (pa_should_on ? 1 : 0));
-		if (pa_should_on)
-		{
-            mixer_ctl_set_value(adev->mixer_ctls.audio_speaker_out, 0, 1);
-            ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
-        }
-        else
-        {
-            mixer_ctl_set_value(adev->mixer_ctls.audio_speaker_out, 0, 0);
-            ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
-        }
+
+		ALOGV("phone mode, ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	} else if (adev->mode == AUDIO_MODE_IN_COMMUNICATION) {
+		normal_play_route(adev->out_device);
+		ALOGV("IN COMMUNICATION mode , ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+    	} else {
+		normal_play_route(adev->out_device);
+		ALOGV("other mode , ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
 	}
 }
 
@@ -1323,20 +690,37 @@ static void select_input_device(struct sunxi_audio_device *adev)
     int headset_on = 0;
     int main_mic_on = 0;
     int sub_mic_on = 0;
-    int bt_on = adev->devices & AUDIO_DEVICE_IN_ALL_SCO;
+    int bt_on = adev->in_device & AUDIO_DEVICE_IN_ALL_SCO;
 
     if (!bt_on) {
         if ((adev->mode != AUDIO_MODE_IN_CALL) && (adev->active_input != 0)) {
             /* sub mic is used for camcorder or VoIP on speaker phone */
             sub_mic_on = (adev->active_input->source == AUDIO_SOURCE_CAMCORDER) ||
-                         ((adev->devices & AUDIO_DEVICE_OUT_SPEAKER) &&
+                         ((adev->out_device & AUDIO_DEVICE_OUT_SPEAKER) &&
                           (adev->active_input->source == AUDIO_SOURCE_VOICE_COMMUNICATION));
         }
         if (!sub_mic_on) {
-            headset_on = adev->devices & AUDIO_DEVICE_IN_WIRED_HEADSET;
-            main_mic_on = adev->devices & AUDIO_DEVICE_IN_BUILTIN_MIC;
+            headset_on = adev->in_device & AUDIO_DEVICE_IN_WIRED_HEADSET;
+            main_mic_on = adev->in_device & AUDIO_DEVICE_IN_BUILTIN_MIC;
         }
     }
+
+    //ALOGV("select_input_device, devices: %x, mode: %x", adev->devices, adev->mode);
+    //ALOGV("select_input_device, headset_on=%x,headphone_on=%x,speaker_on=%x,earpiece_on=%x,bt_on=%x",headset_on,headphone_on,speaker_on,earpiece_on,bt_on);
+
+    if (adev->mode == AUDIO_MODE_IN_CALL) {
+	phone_record_enable(true);
+	phone_record_route(adev->in_device);
+	ALOGV("phone record,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+    } else if (adev->mode == AUDIO_MODE_FM) {
+	fm_record_enable(true);
+	fm_record_route(adev->in_device);
+	ALOGV("fm record,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+    } else if (adev->mode == AUDIO_MODE_NORMAL)  {
+	normal_record_enable(true);
+	normal_record_route(adev->in_device);
+	ALOGV("normal record,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+    }
 }
 
 /* must be called with hw device and output stream mutexes locked */
@@ -1346,9 +730,8 @@ static int start_output_stream(struct sunxi_stream_out *out)
     struct sunxi_audio_device *adev = out->dev;
     unsigned int card = CARD_A1X_DEFAULT;
     unsigned int port = PORT_CODEC;
-	unsigned int index;
 
-	if (adev->mode == AUDIO_MODE_IN_CALL)
+	if (adev->mode == AUDIO_MODE_IN_CALL || adev->mode == AUDIO_MODE_MODE_FACTORY_TEST || adev->mode == AUDIO_MODE_FM)
 	{
 		ALOGW("mode in call, do not start stream");
 		return 0;
@@ -1359,7 +742,7 @@ static int start_output_stream(struct sunxi_stream_out *out)
 		return 0;
 	}
 
-	int device = adev->devices;
+	int device = adev->out_device;
 	char prop_value[512];
     int ret = property_get("audio.routing", prop_value, "");
 	if (ret > 0)
@@ -1389,7 +772,7 @@ static int start_output_stream(struct sunxi_stream_out *out)
 		// ALOGW("get audio.routing failed");
 	}
 
-	adev->devices = device;
+	adev->out_device = device;
 
     adev->active_output = out;
 
@@ -1400,11 +783,11 @@ static int start_output_stream(struct sunxi_stream_out *out)
     /* S/PDIF takes priority over HDMI audio. In the case of multiple
      * devices, this will cause use of S/PDIF or HDMI only */
     out->config.rate = MM_SAMPLING_RATE;
-    if (adev->devices & AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET) {
+    if (adev->out_device & AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET) {
 		card = CARD_A1X_SPDIF;
         port = PORT_SPDIF;
     }
-    else if(adev->devices & AUDIO_DEVICE_OUT_AUX_DIGITAL) {
+    else if(adev->out_device & AUDIO_DEVICE_OUT_AUX_DIGITAL) {
         card = CARD_A1X_HDMI;
         port = PORT_HDMI;
         out->config.rate = MM_SAMPLING_RATE;
@@ -1412,64 +795,53 @@ static int start_output_stream(struct sunxi_stream_out *out)
     /* default to low power: will be corrected in out_write if necessary before first write to
      * tinyalsa.
      */
-    out->write_threshold = PLAYBACK_PERIOD_COUNT * LONG_PERIOD_SIZE;
+    out->write_threshold = PLAYBACK_PERIOD_COUNT * SHORT_PERIOD_SIZE;
     out->config.start_threshold = SHORT_PERIOD_SIZE * 2;
-    out->config.avail_min = LONG_PERIOD_SIZE;
-			
-	for (index = 0; index < MAX_AUDIO_DEVICES; index++)
-	{
-		if (adev->dev_manager[index].flag_exist
-			&& (adev->dev_manager[index].flag_out == AUDIO_OUT)
-			&& adev->dev_manager[index].flag_out_active)
-		{
-			card = index;
-			ALOGV("use %s to playback audio", adev->dev_manager[index].name);
-
-			out->multi_config[card] = pcm_config_mm_out;
-			out->multi_config[card].rate = MM_SAMPLING_RATE;
-	    	out->multi_config[card].start_threshold = SHORT_PERIOD_SIZE * 2;
-    		out->multi_config[card].avail_min = LONG_PERIOD_SIZE;
-
-			out->multi_pcm[card] = pcm_open_req(card, port, PCM_OUT | PCM_MMAP | PCM_NOIRQ, &out->multi_config[card], DEFAULT_OUT_SAMPLING_RATE);
-
-			if (!pcm_is_ready(out->multi_pcm[card])) {
-        		ALOGE("cannot open pcm driver: %s", pcm_get_error(out->multi_pcm[card]));
-        		pcm_close(out->multi_pcm[card]);
-				out->multi_pcm[card] = NULL;
-        		adev->active_output = NULL;
-        		return -ENOMEM;
-    		}
-
-		    if (adev->echo_reference != NULL)
-		        out->echo_reference = adev->echo_reference;
-
-			if (DEFAULT_OUT_SAMPLING_RATE != out->multi_config[card].rate)
-			{
-				int ret = create_resampler(DEFAULT_OUT_SAMPLING_RATE,
-						   					out->multi_config[card].rate,
-						   					2,
-						   					RESAMPLER_QUALITY_DEFAULT,
-						   					NULL,
-						   					&out->multi_resampler[card]);
-				if (ret != 0)
-				{
-					ALOGE("create out resampler failed, %d -> %d", DEFAULT_OUT_SAMPLING_RATE, out->multi_config[card].rate);
-					return ret;
-				}
+    out->config.avail_min = SHORT_PERIOD_SIZE;
 
-				ALOGV("create out resampler OK, %d -> %d", DEFAULT_OUT_SAMPLING_RATE, out->multi_config[card].rate);
-			}
-			else
-			{
-				ALOGV("do not use out resampler");
-			}
+    out->write_threshold = 0;// SHORT_PERIOD_SIZE * PLAYBACK_PERIOD_COUNT;
+    out->config.start_threshold = 0;//SHORT_PERIOD_SIZE * 2;
+    out->config.avail_min = 0; //SHORT_PERIOD_SIZE;
+    out->config.stop_threshold = 0;
+    ALOGV("start_output_stream: card:%d, port:%d, rate:%d", card, port, out->config.rate);
+//		out->config.period_size = 256;
+//		out->config.period_count = 8;
+    out->pcm = pcm_open(card, port, PCM_OUT, &out->config);
+	//out->pcm = pcm_open_req(card, port, PCM_OUT | PCM_MMAP | PCM_NOIRQ, &out->config, DEFAULT_OUT_SAMPLING_RATE);
+    if (!pcm_is_ready(out->pcm)) {
+        ALOGE("cannot open pcm_out driver: %s", pcm_get_error(out->pcm));
+        pcm_close(out->pcm);
+        adev->active_output = NULL;
+        return -ENOMEM;
+    }
 
-			if (out->multi_resampler[card])
-			{
-	    		out->multi_resampler[card]->reset(out->multi_resampler[card]);
-			}
+    if (adev->echo_reference != NULL)
+        out->echo_reference = adev->echo_reference;
 
+	if (DEFAULT_OUT_SAMPLING_RATE != out->config.rate)
+	{
+		ret = create_resampler(DEFAULT_OUT_SAMPLING_RATE,
+							   out->config.rate,
+							   2,
+							   RESAMPLER_QUALITY_DEFAULT,
+							   NULL,
+							   &out->resampler);
+		if (ret != 0)
+		{
+			ALOGE("create out resampler failed, %d -> %d", DEFAULT_OUT_SAMPLING_RATE, out->config.rate);
+			return ret;
 		}
+
+		ALOGV("create out resampler OK, %d -> %d", DEFAULT_OUT_SAMPLING_RATE, out->config.rate);
+	}
+	else
+	{
+		ALOGV("do not use out resampler");
+	}
+
+	if (out->resampler)
+	{
+	    out->resampler->reset(out->resampler);
 	}
 
     return 0;
@@ -1577,35 +949,20 @@ static int get_playback_delay(struct sunxi_stream_out *out,
                        size_t frames,
                        struct echo_reference_buffer *buffer)
 {
-	struct sunxi_audio_device *adev = out->dev;
     size_t kernel_frames;
     int status;
-	int index;
-	int card;
 
-	for (index = 0; index < MAX_AUDIO_DEVICES; index++)
-	{
-		if (adev->dev_manager[index].flag_exist
-			&& (adev->dev_manager[index].flag_out == AUDIO_OUT)
-			&& adev->dev_manager[index].flag_out_active)
-		{
-			card = index;
-
-			status = pcm_get_htimestamp(out->multi_pcm[card], &kernel_frames, &buffer->time_stamp);
-    		if (status < 0) {
-        		buffer->time_stamp.tv_sec  = 0;
-        		buffer->time_stamp.tv_nsec = 0;
-        		buffer->delay_ns           = 0;
-        		ALOGV("get_playback_delay(): pcm_get_htimestamp error,"
-               			"setting playbackTimestamp to 0");
-        		return status;
-    		}
-
-	   		kernel_frames = pcm_get_buffer_size(out->multi_pcm[card]) - kernel_frames;
-			break;
-		}
+    status = pcm_get_htimestamp(out->pcm, &kernel_frames, &buffer->time_stamp);
+    if (status < 0) {
+        buffer->time_stamp.tv_sec  = 0;
+        buffer->time_stamp.tv_nsec = 0;
+        buffer->delay_ns           = 0;
+        ALOGV("get_playback_delay(): pcm_get_htimestamp error,"
+                "setting playbackTimestamp to 0");
+        return status;
+    }
 
-	}
+    kernel_frames = pcm_get_buffer_size(out->pcm) - kernel_frames;
 
     /* adjust render time stamp with delay added by current driver buffer.
      * Add the duration of current frame as we want the render time of the last
@@ -1638,7 +995,7 @@ static size_t out_get_buffer_size(const struct audio_stream *stream)
     return size * audio_stream_frame_size((struct audio_stream *)stream);
 }
 
-static uint32_t out_get_channels(const struct audio_stream *stream)
+static audio_channel_mask_t out_get_channels(const struct audio_stream *stream)
 {
     return AUDIO_CHANNEL_OUT_STEREO;
 }
@@ -1657,35 +1014,10 @@ static int out_set_format(struct audio_stream *stream, audio_format_t format)
 static int do_output_standby(struct sunxi_stream_out *out)
 {
     struct sunxi_audio_device *adev = out->dev;
-	int index = 0;
 
     if (!out->standby) {
-		if (out->pcm)
-		{
-			pcm_close(out->pcm);
-        	out->pcm = NULL;
-		}
-
-		if (out->resampler)
-		{
-			release_resampler(out->resampler);
-			out->resampler = NULL;
-		}
-
-        for (index = 0; index < MAX_AUDIO_DEVICES; index++)
-        {
-        	if (out->multi_pcm[index])
-        	{
-				pcm_close(out->multi_pcm[index]);
-        		out->multi_pcm[index] = NULL;
-			}
-
-			if (out->multi_resampler[index])
-			{
-				release_resampler(out->multi_resampler[index]);
-				out->multi_resampler[index] = NULL;
-			}
-        }
+        pcm_close(out->pcm);
+        out->pcm = NULL;
 
         adev->active_output = 0;
 
@@ -1704,12 +1036,12 @@ static int out_standby(struct audio_stream *stream)
 {
     struct sunxi_stream_out *out = (struct sunxi_stream_out *)stream;
     int status;
-
-    pthread_mutex_lock(&out->dev->lock);
+ALOGD("out_standby");
+    //pthread_mutex_lock(&out->dev->lock);
     pthread_mutex_lock(&out->lock);
     status = do_output_standby(out);
     pthread_mutex_unlock(&out->lock);
-    pthread_mutex_unlock(&out->dev->lock);
+    //pthread_mutex_unlock(&out->dev->lock);
     return status;
 }
 
@@ -1725,28 +1057,20 @@ static int out_set_parameters(struct audio_stream *stream, const char *kvpairs)
     struct sunxi_stream_in *in;
     struct str_parms *parms;
     char *str;
-    char value[128];
+    char value[32];
     int ret, val = 0;
     bool force_input_standby = false;
 
     parms = str_parms_create_str(kvpairs);
 
 	ALOGV("out_set_parameters: %s", kvpairs);
- 
+
     ret = str_parms_get_str(parms, AUDIO_PARAMETER_STREAM_ROUTING, value, sizeof(value));
     if (ret >= 0) {
         val = atoi(value);
-		if (adev->first_set_audio_routing)
-		{
-			// we do not use the android default routing
-			// init audio routing by fuction init_audio_devices_active()
-			adev->first_set_audio_routing= false;
-			return ret;
-		}
         pthread_mutex_lock(&adev->lock);
         pthread_mutex_lock(&out->lock);
-        //if (((adev->devices & AUDIO_DEVICE_OUT_ALL) != val) && (val != 0)) {
-        if(val != 0){
+        if ((adev->out_device  != val) && (val != 0)) {
             if (out == adev->active_output) {
                 /* a change in output device may change the microphone selection */
                 if (adev->active_input &&
@@ -1755,18 +1079,16 @@ static int out_set_parameters(struct audio_stream *stream, const char *kvpairs)
                 }
                 /* force standby if moving to/from HDMI */
                 if (((val & AUDIO_DEVICE_OUT_AUX_DIGITAL) ^
-                        (adev->devices & AUDIO_DEVICE_OUT_AUX_DIGITAL)) ||
+                        (adev->out_device & AUDIO_DEVICE_OUT_AUX_DIGITAL)) ||
                         ((val & AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET) ^
-                        (adev->devices & AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET)))
+                        (adev->out_device & AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET)))
                     do_output_standby(out);
             }
-			ALOGD("val: %x, adev->devices: %x", val, adev->devices);
-            adev->devices &= ~AUDIO_DEVICE_OUT_ALL;
-            adev->devices |= val;
-
-			//set_audio_devices_active_internal(out, AUDIO_OUT, val);
-
+            adev->out_device = val;
             select_output_device(adev);
+            if (adev->mode == AUDIO_MODE_IN_CALL || adev->mode == AUDIO_MODE_MODE_FACTORY_TEST || adev->mode == AUDIO_MODE_FM){
+            	adev_set_voice_volume(&adev->hw_device, adev->voice_volume);
+	    }
         }
         pthread_mutex_unlock(&out->lock);
         if (force_input_standby) {
@@ -1778,36 +1100,11 @@ static int out_set_parameters(struct audio_stream *stream, const char *kvpairs)
         pthread_mutex_unlock(&adev->lock);
     }
 
-	// set audio out device
-	ret = str_parms_get_str(parms, AUDIO_PARAMETER_DEVICES_OUT_ACTIVE, value, sizeof(value));
-	if (ret >= 0)
-	{
-		ALOGV("out AUDIO_PARAMETER_DEVICES_OUT_ACTIVE: %s", value);
-
-		pthread_mutex_lock(&adev->lock);
-		pthread_mutex_lock(&out->lock);
-
-		if (adev->raw_flag == true)
-		{
-			ALOGW("in raw mode, should not set other audio out devices");
-			return -1;
-		}
-
-		set_audio_devices_active(adev, AUDIO_OUT, value);
-		//strcpy(adev->out_device_active_req, value);
-
-		do_output_standby(out);
-		select_output_device(adev);
-		pthread_mutex_unlock(&out->lock);
-		pthread_mutex_unlock(&adev->lock);
-	}
-
-	// for raw data output
 	ret = str_parms_get_str(parms, AUDIO_PARAMETER_RAW_DATA_OUT, value, sizeof(value));
 	if (ret >= 0)
 	{
 		bool bval = (atoi(value) == 1) ? true : false;
-		ALOGD("AUDIO_PARAMETER_RAW_DATA_OUT: %d", bval);
+		ALOGV("AUDIO_PARAMETER_RAW_DATA_OUT: %d", bval);
 		pthread_mutex_lock(&adev->lock);
 		pthread_mutex_lock(&out->lock);
 
@@ -1843,6 +1140,170 @@ static int out_set_volume(struct audio_stream_out *stream, float left,
     return -ENOSYS;
 }
 
+#if 0
+static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
+                          size_t bytes)
+ {
+	struct sunxi_stream_out *out = (struct sunxi_stream_out *)stream;
+	struct sunxi_audio_device *adev = out->dev;
+	bool force_input_standby = false;
+	size_t frame_size = audio_stream_frame_size(&out->stream.common);
+	size_t in_frames = bytes / frame_size;
+	size_t out_frames = RESAMPLER_BUFFER_SIZE / frame_size;
+	struct sunxi_stream_in *in;
+	unsigned int card = CARD_A1X_DEFAULT;
+	unsigned int port = PORT_CODEC;
+	void *buf;
+	int ret;
+	int kernel_frames;
+	int device = adev->out_device;
+	char prop_value[512];
+	
+	if (adev->mode == AUDIO_MODE_IN_CALL || adev->mode == AUDIO_MODE_MODE_FACTORY_TEST || adev->mode == AUDIO_MODE_FM)
+	{
+		//ALOGW("mode in call, do not out_write");
+		return bytes;
+	}
+
+	if (adev->raw_flag)
+	{
+		return 0;
+	}
+
+	pthread_mutex_lock(&out->lock);
+	pthread_mutex_lock(&adev->lock);
+	if (out->standby)
+	{
+		ret = property_get("audio.routing", prop_value, "");
+		if (ret > 0)
+		{
+			if(atoi(prop_value) == AUDIO_DEVICE_OUT_SPEAKER)
+			{
+				ALOGD("start_output_stream, AUDIO_DEVICE_OUT_SPEAKER");
+				device = AUDIO_DEVICE_OUT_SPEAKER;
+			}
+			else if(atoi(prop_value) == AUDIO_DEVICE_OUT_AUX_DIGITAL)
+			{
+				ALOGD("start_output_stream AUDIO_DEVICE_OUT_AUX_DIGITAL");
+				device = AUDIO_DEVICE_OUT_AUX_DIGITAL;
+			}
+			else if(atoi(prop_value) == AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET)
+			{
+				ALOGD("start_output_stream AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET");
+				device = AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET;
+			}
+			else
+			{
+				ALOGW("unknown audio.routing : %s", prop_value);
+			}
+		}
+		else
+		{
+			// ALOGW("get audio.routing failed");
+		}
+	
+		adev->out_device = device;
+		adev->active_output = out;
+
+	    if (adev->mode != AUDIO_MODE_IN_CALL) {
+	        /* FIXME: only works if only one output can be active at a time */
+	        select_output_device(adev);
+	    }
+	    /* S/PDIF takes priority over HDMI audio. In the case of multiple
+	     * devices, this will cause use of S/PDIF or HDMI only */
+	    out->config.rate = MM_SAMPLING_RATE;
+	    if (adev->out_device & AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET) {
+			card = CARD_A1X_SPDIF;
+	        port = PORT_SPDIF;
+	    }
+	    else if(adev->out_device & AUDIO_DEVICE_OUT_AUX_DIGITAL) {
+	        card = CARD_A1X_HDMI;
+	        port = PORT_HDMI;
+	        out->config.rate = MM_SAMPLING_RATE;
+	    }
+
+		/* a change in output device may change the microphone selection */
+		if (adev->active_input &&
+		adev->active_input->source == AUDIO_SOURCE_VOICE_COMMUNICATION)
+			force_input_standby = true;
+
+		out->config.channels = 2;//cda_dec->pDev.AudioBsInfo.chan;
+		out->config.rate = 44100;//cda_dec->pDev.AudioBsInfo.Samplerate;
+		out->config.period_size = 256;//256;//512;//256;
+		out->config.period_count = 8;//8;//4;//8;
+		out->config.format = PCM_FORMAT_S16_LE;
+		out->config.start_threshold = 0;
+		out->config.stop_threshold = 0;
+		out->config.silence_threshold = 0;
+		out->write_threshold = out->config.period_size*out->config.period_count;//SHORT_PERIOD_SIZE * PLAYBACK_PERIOD_COUNT;
+//   	out->config.avail_min = out->config.period_size;//SHORT_PERIOD_SIZE;
+//		pcm_set_avail_min(out->pcm, out->config.avail_min);
+
+		//ALOGV("huangxin*60**out->config.period_size:%d, out->config.period_count:%d, fs:%d,ch:%d", out->config.period_size, out->config.period_count, out->config.rate,out->config.channels);
+		out->pcm = pcm_open(card, port, PCM_OUT, &(out->config));
+		if (!out->pcm || !pcm_is_ready(out->pcm)) {
+			ALOGW("Unable to open PCM device %u (%s)\n",
+			port, pcm_get_error(out->pcm));
+			pthread_mutex_unlock(&adev->lock);
+			goto exit;
+		}
+		out->standby = 0;
+	}
+	pthread_mutex_unlock(&adev->lock);
+	out_frames = in_frames;
+	buf = (void *)buffer;
+
+#if 0
+    /* do not allow more than out->write_threshold frames in kernel pcm driver buffer */
+    do {
+        struct timespec time_stamp;
+
+        if (pcm_get_htimestamp(out->pcm, (unsigned int *)&kernel_frames, &time_stamp) < 0)
+            break;
+        kernel_frames = pcm_get_buffer_size(out->pcm) - kernel_frames;
+
+        if (kernel_frames > out->write_threshold) {
+            unsigned long time = (unsigned long)
+                    (((int64_t)(kernel_frames - out->write_threshold) * 1000000) /
+                            MM_SAMPLING_RATE);
+            if (time < MIN_WRITE_SLEEP_US)
+                time = MIN_WRITE_SLEEP_US;
+            usleep(time);
+        }
+    } while (kernel_frames > out->write_threshold);
+#endif
+
+	if (adev->af_capture_flag && adev->PcmManager.BufExist) {
+		WritePcmData((void *)buf, out_frames * frame_size, &adev->PcmManager);
+		memset(buf, 0, out_frames * frame_size); //mute
+	}
+
+	ret = pcm_write(out->pcm, (void *)buf, out_frames * frame_size);
+	if (ret != 0)
+	{
+		do_output_standby(out);
+	}
+	exit:
+	if (ret != 0) {
+		usleep(bytes * 1000000 / audio_stream_frame_size(&stream->common) /
+		out_get_sample_rate(&stream->common));
+	}
+	pthread_mutex_unlock(&out->lock);
+	if (force_input_standby) {
+		pthread_mutex_lock(&adev->lock);
+		if (adev->active_input) {
+			in = adev->active_input;
+			pthread_mutex_lock(&in->lock);
+			do_input_standby(in);
+			pthread_mutex_unlock(&in->lock);
+		}
+		pthread_mutex_unlock(&adev->lock);
+	}
+	return bytes;
+}
+
+#else
+
 static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
                          size_t bytes)
 {
@@ -1855,14 +1316,12 @@ static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
     bool force_input_standby = false;
     struct sunxi_stream_in *in;
     int kernel_frames;
-	void *buf;
-	int index;
-	int card;
+    void *buf;
 
-	if (adev->mode == AUDIO_MODE_IN_CALL)
+	if (adev->mode == AUDIO_MODE_IN_CALL || adev->mode == AUDIO_MODE_MODE_FACTORY_TEST || adev->mode == AUDIO_MODE_FM)
 	{
-		// ALOGW("mode in call, do not out_write");
-		return 0;
+		//ALOGW("mode in call, do not out_write");
+		return bytes;
 	}
 
 	if (adev->raw_flag)
@@ -1874,8 +1333,8 @@ static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
      * on the output stream mutex - e.g. executing select_mode() while holding the hw device
      * mutex
      */
-    pthread_mutex_lock(&adev->lock);
     pthread_mutex_lock(&out->lock);
+    pthread_mutex_lock(&adev->lock);
     if (out->standby) {
         ret = start_output_stream(out);
         if (ret != 0) {
@@ -1889,100 +1348,63 @@ static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
             force_input_standby = true;
     }
     pthread_mutex_unlock(&adev->lock);
-
+#if 0
     out->write_threshold = SHORT_PERIOD_SIZE * PLAYBACK_PERIOD_COUNT;
     out->config.avail_min = SHORT_PERIOD_SIZE;
+	pcm_set_avail_min(out->pcm, out->config.avail_min);
+#endif
+    /* only use resampler if required */
+    if (out->resampler) {
+        out->resampler->resample_from_input(out->resampler,
+                                            (int16_t *)buffer,
+                                            &in_frames,
+                                            (int16_t *)out->buffer,
+                                            &out_frames);
+        buf = out->buffer;
+    } else {
+        out_frames = in_frames;
+        buf = (void *)buffer;
+    }
+    if (out->echo_reference != NULL) {
+        struct echo_reference_buffer b;
+        b.raw = (void *)buffer;
+        b.frame_count = in_frames;
 
-	if (adev->af_capture_flag && adev->PcmManager.BufExist) {
-		WritePcmData((void *)buffer, out_frames * frame_size, &adev->PcmManager);
-		memset((void *)buffer, 0, out_frames * frame_size); //mute
-	}
+        get_playback_delay(out, out_frames, &b);
+        out->echo_reference->write(out->echo_reference, &b);
+    }
 
-	for (index = MAX_AUDIO_DEVICES; index >= 0; index--)
-	{
-		if (adev->dev_manager[index].flag_exist
-			&& (adev->dev_manager[index].flag_out == AUDIO_OUT)
-			&& adev->dev_manager[index].flag_out_active)
-		{
-			card = index;
-			out->multi_config[card].avail_min = SHORT_PERIOD_SIZE;
-
-			pcm_set_avail_min(out->multi_pcm[card], out->multi_config[card].avail_min);
-
-			if (out->multi_resampler[card]) {
-				out->multi_resampler[card]->resample_from_input(out->multi_resampler[card],
-                                            					(int16_t *)buffer,
-                                            					&in_frames,
-                                            					(int16_t *)out->buffer,
-                                            					&out_frames);
-        		buf = out->buffer;
-    		} else {
-        		out_frames = in_frames;
-        		buf = (void *)buffer;
-    		}
-			
-    		if (out->echo_reference != NULL) {
-        		struct echo_reference_buffer b;
-        		b.raw = (void *)buffer;
-       			b.frame_count = in_frames;
-
-        		get_playback_delay(out, out_frames, &b);
-        		out->echo_reference->write(out->echo_reference, &b);
-    		}
-
-		    /* do not allow more than out->write_threshold frames in kernel pcm driver buffer */
-		    do {
-		        struct timespec time_stamp;
-
-		       			if (pcm_get_htimestamp(out->multi_pcm[card], (unsigned int *)&kernel_frames, &time_stamp) < 0)
-		           			break;
-		       			kernel_frames = pcm_get_buffer_size(out->multi_pcm[card]) - kernel_frames;
-
-		        if (kernel_frames > out->write_threshold) {
-		            unsigned long time = (unsigned long)
-		                    (((int64_t)(kernel_frames - out->write_threshold) * 1000000) /
-		                            MM_SAMPLING_RATE);
-		            if (time < MIN_WRITE_SLEEP_US)
-		                time = MIN_WRITE_SLEEP_US;
-		            usleep(time);
-		        }
-		    } while (kernel_frames > out->write_threshold);
-		
-			if (strncmp(adev->dev_manager[index].name, "AUDIO_USB", 9))
-			{
-				ret = pcm_mmap_write(out->multi_pcm[card], (void *)buf, out_frames * frame_size);
-			}
-			else
-			{
-				if (out->multi_config[index].channels == 2)
-				{
-					ret = pcm_mmap_write(out->multi_pcm[card], (void *)buf, out_frames * frame_size);
-				}
-				else
-				{
-					size_t i;
-					char *pcm_buf = (char *)buf;
-					for (i = 0; i < out_frames; i++)
-					{
-						pcm_buf[2 * i + 2] = pcm_buf[4 * i + 4];
-						pcm_buf[2 * i + 3] = pcm_buf[4 * i + 5];
-					}
-					ret = pcm_mmap_write(out->multi_pcm[card], (void *)buf, out_frames * frame_size / 2);
-				}
-			}
-		}
-        if(ret!=0)
-        {
-            ALOGE("##############out_write()  Warning:write fail#################  card=%d", card);
-            do_output_standby(out);
+#if 0
+    /* do not allow more than out->write_threshold frames in kernel pcm driver buffer */
+    do {
+        struct timespec time_stamp;
+
+        if (pcm_get_htimestamp(out->pcm, (unsigned int *)&kernel_frames, &time_stamp) < 0)
             break;
+        kernel_frames = pcm_get_buffer_size(out->pcm) - kernel_frames;
+
+        if (kernel_frames > out->write_threshold) {
+            unsigned long time = (unsigned long)
+                    (((int64_t)(kernel_frames - out->write_threshold) * 1000000) /
+                            MM_SAMPLING_RATE);
+            if (time < MIN_WRITE_SLEEP_US)
+                time = MIN_WRITE_SLEEP_US;
+            usleep(time);
         }
+    } while (kernel_frames > out->write_threshold);
+#endif
+
+	if (adev->af_capture_flag && adev->PcmManager.BufExist) {
+		WritePcmData((void *)buf, out_frames * frame_size, &adev->PcmManager);
+		memset(buf, 0, out_frames * frame_size); //mute
 	}
 
-	if (ret != 0) {
+    ret = pcm_write(out->pcm, (void *)buf, out_frames * frame_size);
+	if(ret!=0)
+	{
 		do_output_standby(out);
-		ALOGW("##############out_write()  Warning:write fail#######################");
 	}
+
 exit:
     pthread_mutex_unlock(&out->lock);
 
@@ -2004,6 +1426,7 @@ exit:
 
     return bytes;
 }
+#endif
 
 static int out_get_render_position(const struct audio_stream_out *stream,
                                    uint32_t *dsp_frames)
@@ -2043,9 +1466,13 @@ static int start_input_stream(struct sunxi_stream_in *in)
 
     adev->active_input = in;
 
+    if (adev->mode == AUDIO_MODE_IN_CALL) { // && adev->bluetooth_voice
+	ALOGD("in call mode , start_input_stream, return");
+	return 0;
+    }	
+
     if (adev->mode != AUDIO_MODE_IN_CALL) {
-        adev->devices &= ~AUDIO_DEVICE_IN_ALL;
-        adev->devices |= in->device;
+        adev->in_device = in->device;
         select_input_device(adev);
     }
 
@@ -2072,19 +1499,7 @@ static int start_input_stream(struct sunxi_stream_in *in)
 		ALOGV("out/in stream should be both 44.1K serial, force capture rate: %d", in_ajust_rate);
 	}
 
-	int card = 0;
-	for (card = 0; card < MAX_AUDIO_DEVICES; card++)
-	{
-		if (adev->dev_manager[card].flag_exist
-			&& (adev->dev_manager[card].flag_in == AUDIO_IN)
-			&& adev->dev_manager[card].flag_in_active)
-		{
-			ALOGV("use %s to capture audio", adev->dev_manager[card].name);
-			break;
-		}
-	}
-
-	in->pcm = pcm_open_req(card, PORT_CODEC, PCM_IN, &in->config, in_ajust_rate);
+	in->pcm = pcm_open_req(0, PORT_CODEC, PCM_IN, &in->config, in_ajust_rate);
 
     if (!pcm_is_ready(in->pcm)) {
         ALOGE("cannot open pcm_in driver: %s", pcm_get_error(in->pcm));
@@ -2093,13 +1508,6 @@ static int start_input_stream(struct sunxi_stream_in *in)
         return -ENOMEM;
     }
 
-	// 
-	//set_route_by_array(adev->mixer, mic1_rec_routing, 1);
-
-	if (adev->mode == AUDIO_MODE_IN_CALL)
-	{
-		//set_route_by_array(adev->mixer, line_in_rec_routing, 1);	// must after mic1_rec_routing
-	}
 
 	if (in->requested_rate != in->config.rate) {
 		in->buf_provider.get_next_buffer = get_next_buffer;
@@ -2160,7 +1568,7 @@ static size_t in_get_buffer_size(const struct audio_stream *stream)
                                  in->config.channels);
 }
 
-static uint32_t in_get_channels(const struct audio_stream *stream)
+static audio_channel_mask_t in_get_channels(const struct audio_stream *stream)
 {
     struct sunxi_stream_in *in = (struct sunxi_stream_in *)stream;
 
@@ -2192,7 +1600,7 @@ static int do_input_standby(struct sunxi_stream_in *in)
 
         adev->active_input = 0;
         if (adev->mode != AUDIO_MODE_IN_CALL) {
-            adev->devices &= ~AUDIO_DEVICE_IN_ALL;
+            adev->in_device = AUDIO_DEVICE_NONE;
             select_input_device(adev);
         }
 
@@ -2203,16 +1611,7 @@ static int do_input_standby(struct sunxi_stream_in *in)
             in->echo_reference = NULL;
         }
 
-	    if (in->resampler) {
-        	release_resampler(in->resampler);
-			in->resampler = NULL;
-    	}
-
         in->standby = 1;
-
-		//
-		// set_route_by_array(adev->mixer, line_in_rec_routing, 0);
-//		set_route_by_array(adev->mixer, mic1_rec_routing, 0);
     }
     return 0;
 }
@@ -2264,22 +1663,16 @@ static int in_set_parameters(struct audio_stream *stream, const char *kvpairs)
 
     ret = str_parms_get_str(parms, AUDIO_PARAMETER_STREAM_ROUTING, value, sizeof(value));
     if (ret >= 0) {
-        val = atoi(value);
-        if ((in->device != val) && (val != 0)) {
+        val = atoi(value) & ~AUDIO_DEVICE_BIT_IN;
+        if ((adev->mode != AUDIO_MODE_IN_CALL) && (in->device != val) && (val != 0)) {
             in->device = val;
             do_standby = true;
-        }
-    }
+        } else if((adev->mode == AUDIO_MODE_IN_CALL) && (in->source != val) && (val != 0)) {
+            in->device = val;
 
-	// set audio in device
-	ret = str_parms_get_str(parms, AUDIO_PARAMETER_DEVICES_IN_ACTIVE, value, sizeof(value));
-	if (ret >= 0)
-	{
-		ALOGV("in_set_parament AUDIO_PARAMETER_DEVICES_IN_ACTIVE: %s", value);
-		//set_audio_devices_active(adev, AUDIO_IN, value);
-		do_standby = true;
+            select_input_device(adev);
 	}
-
+    }
 
     if (do_standby)
         do_input_standby(in);
@@ -2613,12 +2006,18 @@ static ssize_t process_frames(struct sunxi_stream_in *in, void* buffer, ssize_t
 static ssize_t in_read(struct audio_stream_in *stream, void* buffer,
                        size_t bytes)
 {
-	 F_LOG;
+	// F_LOG;
     int ret = 0;
     struct sunxi_stream_in *in 		= (struct sunxi_stream_in *)stream;
     struct sunxi_audio_device *adev = in->dev;
     size_t frames_rq 				= bytes / audio_stream_frame_size(&stream->common);
 
+    if (adev->mode == AUDIO_MODE_IN_CALL) {
+	//ALOGD("in call mode, in_read, return ;");
+	usleep(10000);
+	return 1;
+    }	
+
     /* acquiring hw device mutex systematically is useful if a low priority thread is waiting
      * on the input stream mutex - e.g. executing select_mode() while holding the hw device
      * mutex
@@ -2627,9 +2026,7 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer,
 	    pthread_mutex_lock(&adev->lock);
     	pthread_mutex_lock(&in->lock);
 	    if (in->standby) {
-	        ret = start_input_stream(in);
-	        if (ret == 0)
-	            in->standby = 0;
+	    	in->standby = 0;
 	    }
 	    pthread_mutex_unlock(&adev->lock);
 
@@ -2664,7 +2061,7 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer,
         goto exit;
 
     if (in->num_preprocessors != 0) {
-        ret = process_frames(in, buffer, frames_rq);
+        ret = read_frames(in, buffer, frames_rq);//ret = process_frames(in, buffer, frames_rq);
     } else if (in->resampler != NULL) {
         ret = read_frames(in, buffer, frames_rq);
 	} else {
@@ -2815,8 +2212,7 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
 
     /* FIXME: when we support multiple output devices, we will want to
      * do the following:
-     * adev->devices &= ~AUDIO_DEVICE_OUT_ALL;
-     * adev->devices |= out->device;
+	 * adev->out_device = out->device;
      * select_output_device(adev);
      * This is because out_set_parameters() with a route is not
      * guaranteed to be called after an output stream is opened. */
@@ -2840,19 +2236,19 @@ static void adev_close_output_stream(struct audio_hw_device *dev,
                                      struct audio_stream_out *stream)
 {
     struct sunxi_stream_out *out = (struct sunxi_stream_out *)stream;
-	unsigned int index;
+    struct sunxi_audio_device *adev = out->dev;
+
+	if (adev->mode == AUDIO_MODE_IN_CALL || adev->mode == AUDIO_MODE_MODE_FACTORY_TEST  || adev->mode == AUDIO_MODE_FM)
+	{
+		ALOGW("mode in call, do not adev_close_output_stream");
+		return ;
+	}
 
     out_standby(&stream->common);
     if (out->buffer)
         free(out->buffer);
     if (out->resampler)
         release_resampler(out->resampler);
-	for (index = 0; index < MAX_AUDIO_DEVICES; index++)
-	{
-		if (out->multi_resampler[index])
-			release_resampler(out->multi_resampler[index]);
-	}
-
     free(stream);
 }
 
@@ -2885,8 +2281,10 @@ static int adev_set_parameters(struct audio_hw_device *dev, const char *kvpairs)
         pthread_mutex_lock(&adev->lock);
         if (tty_mode != adev->tty_mode) {
             adev->tty_mode = tty_mode;
-            if (adev->mode == AUDIO_MODE_IN_CALL)
+            if (adev->mode == AUDIO_MODE_IN_CALL || adev->mode == AUDIO_MODE_MODE_FACTORY_TEST || adev->mode == AUDIO_MODE_FM){
                 select_output_device(adev);
+            	adev_set_voice_volume(&adev->hw_device, adev->voice_volume);
+	     }
         }
         pthread_mutex_unlock(&adev->lock);
     }
@@ -2899,14 +2297,6 @@ static int adev_set_parameters(struct audio_hw_device *dev, const char *kvpairs)
             adev->bluetooth_nrec = false;
     }
 
-	// set audio in device
-	ret = str_parms_get_str(parms, AUDIO_PARAMETER_DEVICES_IN_ACTIVE, value, sizeof(value));
-	if (ret >= 0)
-	{
-		ALOGV("in AUDIO_PARAMETER_DEVICES_IN_ACTIVE: %s", value);
-		set_audio_devices_active(adev, AUDIO_IN, value);
-	}
-
     str_parms_destroy(parms);
     return ret;
 }
@@ -2914,48 +2304,15 @@ static int adev_set_parameters(struct audio_hw_device *dev, const char *kvpairs)
 static char * adev_get_parameters(const struct audio_hw_device *dev,
                                   const char *keys)
 {
-	struct sunxi_audio_device *adev = (struct sunxi_audio_device *)dev;
-
-	int ret = -1;
-	char devices[128];
-	memset(devices, 0, sizeof(devices));
-
-	if (!strcmp(keys, AUDIO_PARAMETER_STREAM_ROUTING))
+	if (!strcmp(keys, "routing"))
 	{
 		char prop_value[512];
-		property_get("audio.routing", prop_value, "");
+		int ret = property_get("audio.routing", prop_value, "");
 		if (ret > 0)
 		{
 		    return strdup(prop_value);
 		}
 	}
-
-	if (!strcmp(keys, AUDIO_PARAMETER_DEVICES_IN))
-	{
-		return strdup(get_audio_devices(adev, AUDIO_IN));
-	}
-
-	if (!strcmp(keys, AUDIO_PARAMETER_DEVICES_OUT))
-	{
-		return strdup(get_audio_devices(adev, AUDIO_OUT));
-	}
-
-	if (!strcmp(keys, AUDIO_PARAMETER_DEVICES_IN_ACTIVE))
-	{
-		if (!get_audio_devices_active(adev, AUDIO_IN, devices))
-		{
-			return strdup(devices);
-		}
-	}
-
-	if (!strcmp(keys, AUDIO_PARAMETER_DEVICES_OUT_ACTIVE))
-	{
-		if (!get_audio_devices_active(adev, AUDIO_OUT, devices))
-		{
-			return strdup(devices);
-		}
-	}
-
     return strdup("");
 }
 
@@ -2968,43 +2325,16 @@ static int adev_set_voice_volume(struct audio_hw_device *dev, float volume)
 {
     struct sunxi_audio_device *adev = (struct sunxi_audio_device *)dev;
 
-	if (adev->mode == AUDIO_MODE_IN_CALL)
-	{
-	    adev->voice_volume = volume;
-
-		// 59, 47, 35, 23, 11, 0
-		int vol = 59;
-		if (volume >= 1.0f)
-		{
-			vol = 59;
-		}
-		else if (volume >= 0.8f)
-		{
-			vol = 55;
-		}
-		else if (volume >= 0.6f)
-		{
-			vol = 50;
-		}
-		else if (volume >= 0.4f)
-		{
-			vol = 43;
-		}
-		else if (volume >= 0.2f)
-		{
-			vol = 30;
-		}
-		else
-		{
-			vol = 0;
-		}
-
-		ALOGV("adev_set_voice_volume, volume: %f, vol: %d", volume, vol);
+	ALOGV("adev_set_voice_volume, volume: %f", volume);
 
-        call_volume = vol;
-		mixer_ctl_set_value(adev->mixer_ctls.master_playback_volume, 0, vol);
+	if (adev->mode == AUDIO_MODE_FM) {
+		fm_volume(adev->out_device,(int)(volume*100/10));
+		ALOGV("set fm debug,adev_set_voice_volume, volume: %f, intege of volume: %d", volume, (int)(volume*100/10));
+	} else if (adev->mode == AUDIO_MODE_IN_CALL) {
+		phone_volume(adev->out_device,(int)(volume*100/10));
+		set_bp_volume(adev,(int)(volume*100/10));
+		ALOGV("set phone debug,adev_set_voice_volume, volume: %f, intege of volume: %d", volume, (int)(volume*100/10));
 	}
-
     return 0;
 }
 
@@ -3095,9 +2425,9 @@ static int adev_open_input_stream(struct audio_hw_device *dev,
     in->stream.common.get_parameters 	= in_get_parameters;
     in->stream.common.add_audio_effect 	= in_add_audio_effect;
     in->stream.common.remove_audio_effect = in_remove_audio_effect;
-    in->stream.set_gain 				= in_set_gain;
-    in->stream.read 					= in_read;
-    in->stream.get_input_frames_lost 	= in_get_input_frames_lost;
+    in->stream.set_gain = in_set_gain;
+    in->stream.read 	= in_read;
+    in->stream.get_input_frames_lost = in_get_input_frames_lost;
 
     in->requested_rate 	= config->sample_rate;
 
@@ -3137,11 +2467,13 @@ static int adev_open_input_stream(struct audio_hw_device *dev,
 		ladev->PcmManager.SampleRate 	= config->sample_rate;
 		ladev->PcmManager.Channel 		= 2;
 		ladev->af_capture_flag 			= true;
+
+		ladev->PcmManager.dev 			= (struct sunxi_audio_device *)ladev;
 	}
 
     in->dev 	= ladev;
     in->standby = 1;
-    in->device 	= devices;
+    in->device 	= devices & ~AUDIO_DEVICE_BIT_IN;
 
     *stream_in 	= &in->stream;
     return 0;
@@ -3178,7 +2510,12 @@ static void adev_close_input_stream(struct audio_hw_device *dev,
 		ladev->PcmManager.BufStart = 0;
 	}
     free(stream);
-    return;
+
+	normal_record_enable(false);
+	fm_record_enable(false);
+	phone_record_enable(false);
+	ALOGD("adev_close_input_stream set voice record status");
+	return;
 }
 
 static int adev_dump(const audio_hw_device_t *device, int fd)
@@ -3192,32 +2529,11 @@ static int adev_close(hw_device_t *device)
 
 	mixer_close(adev->mixer);
     free(device);
+
     return 0;
 }
 
-static uint32_t adev_get_supported_devices(const struct audio_hw_device *dev)
-{
-    return (/* OUT */
-            AUDIO_DEVICE_OUT_EARPIECE |
-            AUDIO_DEVICE_OUT_SPEAKER |
-            AUDIO_DEVICE_OUT_WIRED_HEADSET |
-            AUDIO_DEVICE_OUT_WIRED_HEADPHONE |
-            AUDIO_DEVICE_OUT_AUX_DIGITAL |
-            AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET |
-            AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET |
-            AUDIO_DEVICE_OUT_ALL_SCO |
-            AUDIO_DEVICE_OUT_DEFAULT |
-            /* IN */
-            AUDIO_DEVICE_IN_COMMUNICATION |
-            AUDIO_DEVICE_IN_AMBIENT |
-            AUDIO_DEVICE_IN_BUILTIN_MIC |
-            AUDIO_DEVICE_IN_WIRED_HEADSET |
-            AUDIO_DEVICE_IN_AUX_DIGITAL |
-            AUDIO_DEVICE_IN_BACK_MIC |
-			AUDIO_DEVICE_IN_AF |
-            AUDIO_DEVICE_IN_ALL_SCO |
-            AUDIO_DEVICE_IN_DEFAULT);
-}
+
 
 static int adev_open(const hw_module_t* module, const char* name,
                      hw_device_t** device)
@@ -3233,11 +2549,10 @@ static int adev_open(const hw_module_t* module, const char* name,
         return -ENOMEM;
 
     adev->hw_device.common.tag 		= HARDWARE_DEVICE_TAG;
-    adev->hw_device.common.version = AUDIO_DEVICE_API_VERSION_2_0;
+    adev->hw_device.common.version 	= AUDIO_DEVICE_API_VERSION_2_0;
     adev->hw_device.common.module 	= (struct hw_module_t *) module;
     adev->hw_device.common.close 	= adev_close;
 
-    adev->hw_device.get_supported_devices 	= adev_get_supported_devices;
     adev->hw_device.init_check 				= adev_init_check;
     adev->hw_device.set_voice_volume 		= adev_set_voice_volume;
     adev->hw_device.set_master_volume 		= adev_set_master_volume;
@@ -3253,33 +2568,9 @@ static int adev_open(const hw_module_t* module, const char* name,
     adev->hw_device.open_input_stream 		= adev_open_input_stream;
     adev->hw_device.close_input_stream 		= adev_close_input_stream;
     adev->hw_device.dump 					= adev_dump;
+	adev->raw_flag 							= false;
+    adev->mixer 							= mixer_open(0);
 
-
-	adev->raw_flag = false;
-	adev->af_capture_flag = false;
-	adev->first_set_audio_routing = true;
-
-	init_audio_devices(adev);
-	init_audio_devices_active(adev);
-
-	int card = 0;
-	for (card = 0; card < MAX_AUDIO_DEVICES; card++)
-	{
-		if (adev->dev_manager[card].flag_exist
-			&& (adev->dev_manager[card].flag_in == AUDIO_IN)
-			&& !strcmp(adev->dev_manager[card].name, AUDIO_NAME_CODEC))
-		{
-			ALOGV("use %s mixer control", adev->dev_manager[card].name);
-			break;
-		}
-	}
-
-	if (card == MAX_AUDIO_DEVICES)
-	{
-		ALOGE("can not find audio codec mixer control");
-	}
-
-    adev->mixer = mixer_open(card);
     if (!adev->mixer) {
 		free(adev);
 		ALOGE("Unable to open the mixer, aborting.");
@@ -3291,49 +2582,39 @@ static int adev_open(const hw_module_t* module, const char* name,
 	tinymix_list_controls(adev->mixer);
 #endif
 
-    adev->mixer_ctls.audio_speaker_out = mixer_get_ctl_by_name(adev->mixer,
-									   MIXER_AUDIO_SPEAKER_OUT);
-	if (!adev->mixer_ctls.audio_speaker_out) {
-		ALOGE("Unable to find '%s' mixer control",MIXER_AUDIO_SPEAKER_OUT);
-		goto error_out;
-	}
-
-
     /* Set the default route before the PCM stream is opened */
     pthread_mutex_lock(&adev->lock);
 
-	char prop_value[16];
-	adev->support_multi_ouput = false;
-	ret = property_get(PRO_AUDIO_MULTI_OUTPUT, prop_value, "");
-	if (ret > 0)
-	{
-		ALOGV("get property %s: %s", PRO_AUDIO_MULTI_OUTPUT, prop_value);
-		if (strcmp(prop_value, "true") == 0)
-		{
-			adev->support_multi_ouput = true;
-		}
-	}
-
-//    set_route_by_array(adev->mixer, defaults, 1);
-    adev->mode 				= AUDIO_MODE_NORMAL;
-    adev->devices 			= AUDIO_DEVICE_OUT_SPEAKER | AUDIO_DEVICE_IN_BUILTIN_MIC;
+    adev->mode 		= AUDIO_MODE_NORMAL;
+	adev->out_device = AUDIO_DEVICE_OUT_SPEAKER;
+    adev->in_device = AUDIO_DEVICE_IN_BUILTIN_MIC & ~AUDIO_DEVICE_BIT_IN;
     select_output_device(adev);
 
     adev->pcm_modem_dl 		= NULL;
     adev->pcm_modem_ul 		= NULL;
     adev->voice_volume 		= 1.0f;
     adev->tty_mode 			= TTY_MODE_OFF;
-    adev->bluetooth_nrec 	= true;
-    adev->wb_amr = 0;
-	
+    adev->bluetooth_nrec 	= false;
+    adev->wb_amr 			= 0;
+    adev->fm_mode = 2;
+
     pthread_mutex_unlock(&adev->lock);
 
     *device = &adev->hw_device.common;
 
+   if (codec_dev_init() < 0 ){
+	ALOGE("err: codec_dev_init ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	//return -1;
+   }
+
+   if (ril_dev_init() < 0 ){
+	ALOGE("err: ril_dev_init ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	//return -1;
+   }
     return 0;
 
-error_out:     
- 
+error_out:
+
 #if !LOG_NDEBUG
     /* To aid debugging, dump all mixer controls */
     {
@@ -3343,7 +2624,7 @@ error_out:
             for (i = 0; i < cnt; i++) {
                     struct mixer_ctl* x = mixer_get_ctl(adev->mixer,i);
                     if (x != NULL) {
-                            char * name;
+                            const char * name;
                             const char* type;
                             name = mixer_ctl_get_name(x);
                             type = mixer_ctl_get_type_string(x);
diff --git a/softwinner/common/hardware/audio/audio_iface.c b/softwinner/common/hardware/audio/audio_iface.c
new file mode 100644
index 0000000..64c4d18
--- /dev/null
+++ b/softwinner/common/hardware/audio/audio_iface.c
@@ -0,0 +1,238 @@
+
+#define LOG_TAG "audio_iface"
+#define LOG_NDEBUG 0
+
+#include <errno.h>
+#include <pthread.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <sys/time.h>
+#include <stdlib.h>
+
+#include <cutils/log.h>
+#include <fcntl.h>
+
+#include "audio_iface.h"
+
+
+static struct codec_client* codec_client;
+
+int codec_dev_init()
+{
+   codec_client= codec_client_new();
+
+   if (codec_client == NULL){
+	ALOGE("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return -1;
+   }
+
+  return 0;
+}
+
+void codec_dev_exit()
+{
+   if (codec_client != NULL)
+	codec_client_free(codec_client);
+}
+
+//normal play and record 
+void normal_play_enable(bool enable)
+{
+  // init volume
+  //disable other mode
+}
+
+void normal_play_route(int path)
+{
+   int ret = 0; 
+   if ((codec_client != NULL) && (codec_client->normal_ops != NULL)){
+	ret = codec_client->normal_ops->set_normal_path(codec_client,path);
+   }
+}
+
+/*
+hp3p,hp34p max 31
+spk max 60
+*/
+void normal_play_volume(int path, int vol) 
+{
+   int ret = 0; 
+   if ((codec_client != NULL) && (codec_client->normal_ops != NULL)){
+	ret = codec_client->normal_ops->set_normal_volume(codec_client,path,vol);
+   }
+}
+
+void normal_record_enable(bool enable)
+{
+   int ret = 0; 
+   if ((codec_client != NULL) && (codec_client->normal_ops != NULL)){
+	ret = codec_client->normal_ops->set_normal_record_enable(codec_client,enable);
+   }
+}
+
+void normal_record_route(int path)
+{
+   int ret = 0; 
+   if ((codec_client != NULL) && (codec_client->normal_ops != NULL)){
+	ret = codec_client->normal_ops->set_normal_record(codec_client,path);
+   }
+}
+
+//FM play and record
+void fm_play_enable(bool enable){
+
+
+}
+
+void fm_play_route(int path)
+{
+   int ret = 0; 
+   if ((codec_client != NULL) && (codec_client->fm_ops != NULL)){
+	ret = codec_client->fm_ops->set_fm_path(codec_client,path);
+   }
+}
+
+
+void fm_record_enable(bool enable)
+{
+   int ret = 0; 
+   if ((codec_client != NULL) && (codec_client->fm_ops != NULL)){
+	ret = codec_client->fm_ops->set_fm_record_enable(codec_client,enable);
+   }
+}
+
+void fm_record_route(int path)
+{
+   int ret = 0; 
+   if ((codec_client != NULL) && (codec_client->fm_ops != NULL)){
+	ret = codec_client->fm_ops->set_fm_record(codec_client,path);
+   }
+}
+
+
+void fm_volume(int path,int volume)
+{
+   if ((codec_client != NULL) && (codec_client->fm_ops != NULL)){
+	codec_client->fm_ops->set_fm_volume(codec_client,path,volume);
+   }
+}
+
+//Factory test
+void factory_enable(bool enable){
+
+}
+
+void factory_route(int path){
+   int ret = 0; 
+   if ((codec_client != NULL) && (codec_client->factory_ops != NULL)){
+	ret = codec_client->factory_ops->set_factory_path(codec_client,path);
+   }
+}
+
+
+//Ringtone 
+void ringtone_enable(bool enable){
+
+}
+
+void ringtone_path(int path){
+
+}
+
+void ringtone_volume(float volume){
+
+}
+
+//phone play and record
+void phone_play_enable(bool enable){
+
+}
+
+void phone_play_route(int path)
+{
+   int ret = 0; 
+   ALOGE("****LINE:%d,FUNC:%s,%p,%p",__LINE__,__FUNCTION__,codec_client,codec_client?codec_client->phone_ops:0);
+   if ((codec_client != NULL) && (codec_client->phone_ops != NULL)){
+       ret = codec_client->phone_ops->set_phone_path(codec_client,path);
+   }
+}
+
+void phone_record_enable(bool enable)
+{
+   int ret = 0; 
+   if ((codec_client != NULL) && (codec_client->phone_ops != NULL)){
+	ret = codec_client->phone_ops->set_phone_record_enable(codec_client,enable);
+   }
+}
+
+void phone_record_route(int path)
+{
+   int ret = 0; 
+   if ((codec_client != NULL) && (codec_client->phone_ops != NULL)){
+	ret = codec_client->phone_ops->set_phone_record(codec_client,path);
+   }
+}
+
+int phone_record_read_pcm_buf(void* buffer, int bytes)
+{
+   int ret = 0; 
+   if ((codec_client != NULL) && (codec_client->phone_ops != NULL)){
+	ret = codec_client->phone_ops->record_read_pcm_buf(codec_client,buffer,bytes);
+   }
+   return ret;
+}
+
+
+void phone_volume(int path, int volume)
+{
+   int ret = 0; 
+   if ((codec_client != NULL) && (codec_client->phone_ops != NULL)){
+	ret = codec_client->phone_ops->set_phone_volume(codec_client,path,volume);
+   }
+}
+
+
+
+
+/****************************************/
+static struct bp_client* bp_client;
+
+void ril_set_call_volume(ril_audio_path_type_t path, int volume)
+{
+   if ((bp_client != NULL) && (bp_client->bp_ops != NULL)){
+	bp_client->bp_ops->set_call_volume(path,volume);
+   }
+}
+
+void ril_set_call_audio_path(ril_audio_path_type_t path)
+{
+   if ((bp_client != NULL) && (bp_client->bp_ops != NULL)){
+	bp_client->bp_ops->set_call_path(path);
+   }
+}
+
+void ril_set_call_at(char *at)
+{
+   if ((bp_client != NULL) && (bp_client->bp_ops != NULL)){
+	bp_client->bp_ops->set_call_at(at);
+   }
+}
+
+
+int ril_dev_init()
+{
+   bp_client= bp_client_new();
+
+   if (bp_client == NULL)
+	return -1;
+	
+  return 0;
+}
+
+void ril_dev_exit()
+{
+   if (bp_client != NULL)
+	bp_client_free(bp_client);
+}
+
+
diff --git a/softwinner/common/hardware/audio/audio_iface.h b/softwinner/common/hardware/audio/audio_iface.h
new file mode 100644
index 0000000..ac9758b
--- /dev/null
+++ b/softwinner/common/hardware/audio/audio_iface.h
@@ -0,0 +1,113 @@
+
+#ifndef __AUDIO_IFACE_H__
+#define __AUDIO_IFACE_H__
+
+//===================================codec===========
+
+struct codec_client {
+    struct mixer_ctls *mixer_ctls;
+    struct normal_ops *normal_ops;
+    struct fm_ops *fm_ops;
+    struct factory_ops *factory_ops;
+    struct phone_ops *phone_ops;
+};
+
+struct normal_ops {
+    int (*set_normal_volume)(struct codec_client *client, int path, int vol);
+    int (*set_normal_path)(struct codec_client *client, int path);
+    int (*set_normal_record_enable)(struct codec_client *client, bool enable);
+    int (*set_normal_record)(struct codec_client *client, int path);
+};
+
+struct fm_ops {
+    int (*set_fm_volume)(struct codec_client *client, int path, int vol);
+    int (*set_fm_path)(struct codec_client *client, int path);
+    int (*set_fm_record_enable)(struct codec_client *client, bool enable);
+    int (*set_fm_record)(struct codec_client *client, int path);
+    int (*record_read_pcm_buf)(struct codec_client *client, void* buffer, int bytes);
+};
+
+struct factory_ops {
+    int (*set_factory_volume)(struct codec_client *client, int path, int vol);
+    int (*set_factory_path)(struct codec_client *client, int path);
+};
+
+struct phone_ops {
+    int (*set_phone_volume)(struct codec_client *client, int path, int vol);
+    int (*set_phone_path)(struct codec_client *client, int path);
+    int (*set_phone_record_enable)(struct codec_client *client, bool enable);
+    int (*set_phone_record)(struct codec_client *client, int path);
+    int (*record_read_pcm_buf)(struct codec_client *client, void* buffer, int bytes);
+};
+
+struct other_ops {
+    int (*other_op)(char *name);
+};
+
+
+//===================================ril===========
+typedef enum {
+	RIL_AUDIO_PATH_EARPIECE = 0 ,
+	RIL_AUDIO_PATH_HEADSET ,
+	RIL_AUDIO_PATH_SPK,
+	RIL_AUDIO_PATH_BT,
+	RIL_AUDIO_PATH_MAIM_MIC,
+	RIL_AUDIO_PATH_HEADSET_MIC,
+	RIL_AUDIO_PATH_EARPIECE_LOOP,
+	RIL_AUDIO_PATH_HEADSET_LOOP,
+	RIL_AUDIO_PATH_SPK_LOOP,
+
+	RIL_AUDIO_PATH_CNT,
+	RIL_AUDIO_PATH_MAX =RIL_AUDIO_PATH_CNT-1,
+}ril_audio_path_type_t;
+
+
+struct bp_ops {
+    int (*get_tty_dev)(char *name);
+    int (*set_call_volume)(ril_audio_path_type_t path, int vol);
+    int (*set_call_path)(ril_audio_path_type_t path);
+    int (*set_call_at)(char *at);
+};
+
+struct bp_client {
+    struct bp_ops *bp_ops;
+};
+
+struct bp_client* bp_client_new();
+void bp_client_free(struct bp_client *client);
+int ril_dev_init();
+void ril_dev_exit();
+void ril_set_call_volume(ril_audio_path_type_t path, int volume);
+void ril_set_call_audio_path(ril_audio_path_type_t path);
+void ril_set_call_at(char *at);
+
+
+struct codec_client* codec_client_new();
+void codec_client_free(struct codec_client *client);
+int codec_dev_init();
+void codec_dev_exit();
+
+void normal_play_route(int path);
+void fm_play_route(int path);
+void phone_play_route(int path);
+
+void normal_play_volume(int path, int vol);
+void fm_volume(int path,int volume);
+void phone_volume(int path, int volume);
+
+void factory_route(int path);
+
+void normal_record_enable(bool enable);
+void normal_record_route(int path);
+void fm_record_enable(bool enable);
+void fm_record_route(int path);
+void phone_record_enable(bool enable);
+void phone_record_route(int path);
+
+int phone_record_read_pcm_buf(void* buffer, int bytes);
+
+
+#endif
+
+
+
diff --git a/softwinner/common/hardware/audio/audio_policy.conf b/softwinner/common/hardware/audio/audio_policy.conf
old mode 100755
new mode 100644
index 24a37e4..23c3c56
--- a/softwinner/common/hardware/audio/audio_policy.conf
+++ b/softwinner/common/hardware/audio/audio_policy.conf
@@ -5,7 +5,7 @@
 global_configuration {
   attached_output_devices AUDIO_DEVICE_OUT_EARPIECE|AUDIO_DEVICE_OUT_SPEAKER
   default_output_device AUDIO_DEVICE_OUT_SPEAKER
-  attached_input_devices AUDIO_DEVICE_IN_BUILTIN_MIC|AUDIO_DEVICE_IN_BACK_MIC
+  attached_input_devices AUDIO_DEVICE_IN_BUILTIN_MIC|AUDIO_DEVICE_IN_BACK_MIC|AUDIO_DEVICE_IN_VOICE_CALL
 }
 
 # audio hardware module section: contains descriptors for all audio hw modules present on the
@@ -40,9 +40,9 @@ audio_hw_modules {
     inputs {
       primary {
         sampling_rates 8000|11025|16000|22050|24000|32000|44100|48000
-        channel_masks AUDIO_CHANNEL_IN_MONO|AUDIO_CHANNEL_IN_STEREO
+        channel_masks AUDIO_CHANNEL_IN_MONO|AUDIO_CHANNEL_IN_STEREO|AUDIO_CHANNEL_IN_VOICE_UPLINK|AUDIO_CHANNEL_IN_VOICE_DNLINK|AUDIO_CHANNEL_IN_VOICE
         formats AUDIO_FORMAT_PCM_16_BIT
-        devices AUDIO_DEVICE_IN_BUILTIN_MIC|AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET|AUDIO_DEVICE_IN_WIRED_HEADSET|AUDIO_DEVICE_IN_BACK_MIC|AUDIO_DEVICE_IN_AF
+        devices AUDIO_DEVICE_IN_BUILTIN_MIC|AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET|AUDIO_DEVICE_IN_WIRED_HEADSET|AUDIO_DEVICE_IN_BACK_MIC|AUDIO_DEVICE_IN_AF|AUDIO_DEVICE_IN_VOICE_CALL|AUDIO_DEVICE_IN_FM
       }
     }
   }
@@ -72,4 +72,22 @@ audio_hw_modules {
       }
     }
   }
+  r_submix {
+    outputs {
+      submix {
+        sampling_rates 44100|48000
+        channel_masks AUDIO_CHANNEL_OUT_STEREO
+        formats AUDIO_FORMAT_PCM_16_BIT
+        devices AUDIO_DEVICE_OUT_REMOTE_SUBMIX
+      }
+    }
+    inputs {
+      submix {
+        sampling_rates 44100|48000
+        channel_masks AUDIO_CHANNEL_IN_STEREO
+        formats AUDIO_FORMAT_PCM_16_BIT
+        devices AUDIO_DEVICE_IN_REMOTE_SUBMIX
+      }
+    }
+  }
 }
diff --git a/softwinner/common/hardware/audio/audio_ril.h b/softwinner/common/hardware/audio/audio_ril.h
deleted file mode 100755
index f5644a1..0000000
--- a/softwinner/common/hardware/audio/audio_ril.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef RIL_INTERFACE_H
-#define RIL_INTERFACE_H
-
-enum ril_sound_type {
-    SOUND_TYPE_VOICE,
-    SOUND_TYPE_SPEAKER,
-    SOUND_TYPE_HEADSET,
-    SOUND_TYPE_BTVOICE
-};
-
-enum ril_audio_path {
-    SOUND_AUDIO_PATH_HANDSET,
-    SOUND_AUDIO_PATH_HEADSET,
-    SOUND_AUDIO_PATH_SPEAKER,
-    SOUND_AUDIO_PATH_BLUETOOTH,
-    SOUND_AUDIO_PATH_BLUETOOTH_NO_NR,
-    SOUND_AUDIO_PATH_HEADPHONE
-};
-
-/* Function prototypes */
-int ril_set_call_volume(enum ril_sound_type sound_type, int volume);
-int ril_set_call_audio_path(enum ril_audio_path path);
-#endif
-
diff --git a/softwinner/common/hardware/audio/audio_ril_stub.c b/softwinner/common/hardware/audio/audio_ril_stub.c
deleted file mode 100755
index 64be420..0000000
--- a/softwinner/common/hardware/audio/audio_ril_stub.c
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "audio_hw_primary"
-#define LOG_NDEBUG 0
-
-#include <stdlib.h>
-#include <string.h>
-#include <utils/Log.h>
-#include "audio_ril.h"
-
-int get_current_tty_dev(char * tty_dev)
-{
-	return 0;
-}
-
-int ril_set_call_volume(enum ril_sound_type sound_type, int volume)
-{
-    return 0;
-}
-
-int ril_set_call_audio_path(enum ril_audio_path path)
-{
-	return 0;
-}
-
diff --git a/softwinner/common/hardware/audio/libcodec_audio/Android.mk b/softwinner/common/hardware/audio/libcodec_audio/Android.mk
new file mode 100644
index 0000000..f098e00
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/Android.mk
@@ -0,0 +1,50 @@
+# Copyright (C) 2011 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := libcodec_audio
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/
+LOCAL_SRC_FILES := codec.c \
+			 pcm.c mixer.c \
+			codec_devices.c \
+			codec_utils.c volume_conf.c\
+			wakelock.cpp \
+			record.c wav.c \
+			codec_devices/pad/pad.c \
+			codec_devices/planOne/plan_one.c \
+			codec_devices/planOne/manage.c	\
+			codec_devices/planTwo/plan_two.c \
+			codec_devices/planTwo/manage.c \
+			codec_devices/planThree/plan.c \
+			codec_devices/planThree/manage.c	
+		
+		
+LOCAL_C_INCLUDES += \
+	system/media/audio_utils/include \
+	frameworks/native/include \
+	$(LOCAL_PATH)/
+	
+LOCAL_SHARED_LIBRARIES += liblog libcutils libutils libdl libaudioutils libbinder libpowermanager
+
+LOCAL_MODULE_TAGS := optional
+
+include $(BUILD_SHARED_LIBRARY)
+
+
+
+
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/asoundlib.h b/softwinner/common/hardware/audio/libcodec_audio/asoundlib.h
new file mode 100644
index 0000000..72fc97f
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/asoundlib.h
@@ -0,0 +1,242 @@
+/* asoundlib.h
+**
+** Copyright 2011, The Android Open Source Project
+**
+** Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are met:
+**     * Redistributions of source code must retain the above copyright
+**       notice, this list of conditions and the following disclaimer.
+**     * Redistributions in binary form must reproduce the above copyright
+**       notice, this list of conditions and the following disclaimer in the
+**       documentation and/or other materials provided with the distribution.
+**     * Neither the name of The Android Open Source Project nor the names of
+**       its contributors may be used to endorse or promote products derived
+**       from this software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY The Android Open Source Project ``AS IS'' AND
+** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+** ARE DISCLAIMED. IN NO EVENT SHALL The Android Open Source Project BE LIABLE
+** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+** SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+** CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+** DAMAGE.
+*/
+
+#ifndef ASOUNDLIB_H
+#define ASOUNDLIB_H
+
+#include <sys/time.h>
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/*
+ * PCM API
+ */
+
+
+#define PCM_OUT        0x00000000
+#define PCM_IN         0x10000000
+#define PCM_MMAP       0x00000001
+#define PCM_NOIRQ      0x00000002
+#define PCM_NORESTART  0x00000004 /* PCM_NORESTART - when set, calls to
+                                   * pcm_write for a playback stream will not
+                                   * attempt to restart the stream in the case
+                                   * of an underflow, but will return -EPIPE
+                                   * instead.  After the first -EPIPE error, the
+                                   * stream is considered to be stopped, and a
+                                   * second call to pcm_write will attempt to
+                                   * restart the stream.
+                                   */
+
+/* PCM runtime states */
+#define	PCM_STATE_OPEN		0
+#define	PCM_STATE_SETUP		1
+#define	PCM_STATE_PREPARED	2
+#define	PCM_STATE_RUNNING		3
+#define	PCM_STATE_XRUN		4
+#define	PCM_STATE_DRAINING	5
+#define	PCM_STATE_PAUSED		6
+#define	PCM_STATE_SUSPENDED	7
+#define	PCM_STATE_DISCONNECTED	8
+
+/* Bit formats */
+enum pcm_format {
+    PCM_FORMAT_S16_LE = 0,
+    PCM_FORMAT_S32_LE,
+
+    PCM_FORMAT_MAX,
+};
+
+/* Configuration for a stream */
+struct pcm_config {
+    unsigned int channels;
+    unsigned int rate;
+    unsigned int period_size;
+    unsigned int period_count;
+    enum pcm_format format;
+
+    /* Values to use for the ALSA start, stop and silence thresholds.  Setting
+     * any one of these values to 0 will cause the default tinyalsa values to be
+     * used instead.  Tinyalsa defaults are as follows.
+     *
+     * start_threshold   : period_count * period_size
+     * stop_threshold    : period_count * period_size
+     * silence_threshold : 0
+     */
+    unsigned int start_threshold;
+    unsigned int stop_threshold;
+    unsigned int silence_threshold;
+
+    /* Minimum number of frames available before pcm_mmap_write() will actually
+     * write into the kernel buffer. Only used if the stream is opened in mmap mode
+     * (pcm_open() called with PCM_MMAP flag set).   Use 0 for default.
+     */
+    int avail_min;
+	
+	unsigned int in_init_channels;//keep the record init channels
+};
+
+#define PCM_ERROR_MAX 128
+struct pcm {
+    int fd;
+    unsigned int flags;
+    int running:1;
+    int underruns;
+    unsigned int buffer_size;
+    unsigned int boundary;
+    char error[PCM_ERROR_MAX];
+    struct pcm_config config;
+    struct snd_pcm_mmap_status *mmap_status;
+    struct snd_pcm_mmap_control *mmap_control;
+    struct snd_pcm_sync_ptr *sync_ptr;
+    void *mmap_buffer;
+    unsigned int noirq_frames_per_msec;
+    int wait_for_avail_min;
+};
+
+
+
+/* Mixer control types */
+enum mixer_ctl_type {
+    MIXER_CTL_TYPE_BOOL,
+    MIXER_CTL_TYPE_INT,
+    MIXER_CTL_TYPE_ENUM,
+    MIXER_CTL_TYPE_BYTE,
+    MIXER_CTL_TYPE_IEC958,
+    MIXER_CTL_TYPE_INT64,
+    MIXER_CTL_TYPE_UNKNOWN,
+
+    MIXER_CTL_TYPE_MAX,
+};
+
+/* Open and close a stream */
+struct pcm *pcm_open_req(unsigned int card, unsigned int device,
+                     unsigned int flags, struct pcm_config *config, int requested_rate);
+
+/* Open and close a stream */
+struct pcm *pcm_open(unsigned int card, unsigned int device,
+                     unsigned int flags, struct pcm_config *config);
+int pcm_close(struct pcm *pcm);
+int pcm_is_ready(struct pcm *pcm);
+
+/* Set and get config */
+int pcm_get_config(struct pcm *pcm, struct pcm_config *config);
+int pcm_set_config(struct pcm *pcm, struct pcm_config *config);
+
+/* Returns a human readable reason for the last error */
+const char *pcm_get_error(struct pcm *pcm);
+
+/* Returns the buffer size (int frames) that should be used for pcm_write. */
+unsigned int pcm_get_buffer_size(struct pcm *pcm);
+unsigned int pcm_frames_to_bytes(struct pcm *pcm, unsigned int frames);
+unsigned int pcm_bytes_to_frames(struct pcm *pcm, unsigned int bytes);
+
+/* Returns the pcm latency in ms */
+unsigned int pcm_get_latency(struct pcm *pcm);
+
+/* Returns available frames in pcm buffer and corresponding time stamp.
+ * For an input stream, frames available are frames ready for the
+ * application to read.
+ * For an output stream, frames available are the number of empty frames available
+ * for the application to write.
+ */
+int pcm_get_htimestamp(struct pcm *pcm, unsigned int *avail,
+                       struct timespec *tstamp);
+
+/* Write data to the fifo.
+ * Will start playback on the first write or on a write that
+ * occurs after a fifo underrun.
+ */
+int pcm_write(struct pcm *pcm, void *data, unsigned int count);
+int pcm_read(struct pcm *pcm, void *data, unsigned int count);
+
+/*
+ * mmap() support.
+ */
+int pcm_mmap_write(struct pcm *pcm, const void *data, unsigned int count);
+int pcm_mmap_begin(struct pcm *pcm, void **areas, unsigned int *offset,
+                   unsigned int *frames);
+int pcm_mmap_commit(struct pcm *pcm, unsigned int offset, unsigned int frames);
+
+/* Start and stop a PCM channel that doesn't transfer data */
+int pcm_start(struct pcm *pcm);
+int pcm_stop(struct pcm *pcm);
+
+/* Change avail_min after the stream has been opened with no need to stop the stream.
+ * Only accepted if opened with PCM_MMAP and PCM_NOIRQ flags
+ */
+int pcm_set_avail_min(struct pcm *pcm, int avail_min);
+
+int pcm_get_node_number(char *name);
+
+int get_pcm_state(struct pcm *pcm);
+int pcm_wait(struct pcm *pcm, int timeout);
+
+/*
+ * MIXER API
+ */
+
+struct mixer;
+struct mixer_ctl;
+
+/* Open and close a mixer */
+struct mixer *mixer_open(unsigned int card);
+void mixer_close(struct mixer *mixer);
+
+/* Obtain mixer controls */
+unsigned int mixer_get_num_ctls(struct mixer *mixer);
+struct mixer_ctl *mixer_get_ctl(struct mixer *mixer, unsigned int id);
+struct mixer_ctl *mixer_get_ctl_by_name(struct mixer *mixer, const char *name);
+
+/* Get info about mixer controls */
+const char *mixer_ctl_get_name(struct mixer_ctl *ctl);
+enum mixer_ctl_type mixer_ctl_get_type(struct mixer_ctl *ctl);
+const char *mixer_ctl_get_type_string(struct mixer_ctl *ctl);
+unsigned int mixer_ctl_get_num_values(struct mixer_ctl *ctl);
+unsigned int mixer_ctl_get_num_enums(struct mixer_ctl *ctl);
+const char *mixer_ctl_get_enum_string(struct mixer_ctl *ctl,
+                                      unsigned int enum_id);
+
+/* Set and get mixer controls */
+int mixer_ctl_get_percent(struct mixer_ctl *ctl, unsigned int id);
+int mixer_ctl_set_percent(struct mixer_ctl *ctl, unsigned int id, int percent);
+
+int mixer_ctl_get_value(struct mixer_ctl *ctl, unsigned int id);
+int mixer_ctl_set_value(struct mixer_ctl *ctl, unsigned int id, int value);
+int mixer_ctl_set_enum_by_string(struct mixer_ctl *ctl, const char *string);
+
+/* Determe range of integer mixer controls */
+int mixer_ctl_get_range_min(struct mixer_ctl *ctl);
+int mixer_ctl_get_range_max(struct mixer_ctl *ctl);
+
+#if defined(__cplusplus)
+}  /* extern "C" */
+#endif
+
+#endif
diff --git a/softwinner/common/hardware/audio/libcodec_audio/codec.c b/softwinner/common/hardware/audio/libcodec_audio/codec.c
new file mode 100644
index 0000000..9c231af
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/codec.c
@@ -0,0 +1,131 @@
+
+
+#define LOG_TAG "codec_audio"
+#define LOG_NDEBUG 0
+
+#include <stdlib.h>
+#include <string.h>
+#include <utils/Log.h>
+#include <cutils/properties.h>
+
+#include "codec_devices.h"
+#include "hal_codec.h"
+#include "record.h"
+
+static struct mixer_ctls mixer_ctls;
+
+extern struct phone_common_record_ops phone_common_record_ops;
+
+static int codec_device_detect(void)
+{
+    int index = -1, i=-1, ret = 0;
+    char device[20]={0};
+
+    ret = property_get("ro.sw.audio.codec_plan_name", device, "0");
+    if(ret <= 0){
+        ALOGE("wrn: get ro.sw.audio.codec_plan_name failed");
+        return -1;
+    }
+
+    ALOGD("get ro.sw.audio.codec_plan_name =%s", device);
+
+    for (i=0 ; i < codec_devices_count ; i++)
+    {
+        if (strstr(device, codec_devices[i].plan_name) != NULL)
+        {
+            index = i;
+            break;
+        }
+    }
+
+    if (index == -1){
+	    index = 0 ; //default pad
+    }
+
+    ALOGD("get index =%d", index);
+
+    return index;
+}
+
+static struct volume_array vol_array;
+
+extern int get_volume_config(struct volume_array *vol_array);
+
+struct codec_client* codec_client_new()
+{
+    struct codec_client *client=NULL;
+    int device_index = -1;
+    int ret = -1; 
+
+    device_index = codec_device_detect();
+
+    if (device_index < 0 || device_index > codec_devices_count)
+        return NULL;
+
+    client = (struct codec_client*) malloc(sizeof(struct codec_client));
+    if (client == NULL){
+	return NULL;	
+    }
+    memset(client, 0, sizeof(struct codec_client));
+
+    if (codec_devices[device_index].device_init != NULL){
+	ret = codec_devices[device_index].device_init();	
+	if (ret != 0){
+		ALOGE("%s device_init failed\n", codec_devices[device_index].name);
+		return NULL;
+	}
+    }
+
+    if(codec_devices[device_index].normal_ops)
+	client->normal_ops = codec_devices[device_index].normal_ops;
+
+
+    if(codec_devices[device_index].fm_ops)
+       client->fm_ops = codec_devices[device_index].fm_ops;
+
+
+    if(codec_devices[device_index].factory_ops)
+	client->factory_ops = codec_devices[device_index].factory_ops;
+
+
+    if(codec_devices[device_index].phone_ops)
+      client->phone_ops = codec_devices[device_index].phone_ops;
+
+    client->record_ops = &phone_common_record_ops;
+
+
+    if(get_mixer(&mixer_ctls) < 0){
+	ALOGE("get_mixer failed");
+	return NULL;
+    }
+
+    client->mixer_ctls = &mixer_ctls;
+
+    if(client->record_ops->init_record(client) < 0){
+	ALOGE("phone_common_record_ops init_record failed");
+	return NULL;
+    }
+
+    if(get_volume_config(&vol_array)<0){
+	ALOGE("get_volume_config failed");
+	return NULL;
+    }
+
+    client->vol_array = &vol_array;
+
+	ALOGD("get_volume_config pcm_vol: %d", client->vol_array->up_pcm_gain);
+
+    return client;
+}
+
+void codec_client_free(struct codec_client *client)
+{
+    client->record_ops->exit_record();
+    free(client);
+    client = NULL;
+}
+
+
+
+
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/codec_devices.c b/softwinner/common/hardware/audio/libcodec_audio/codec_devices.c
new file mode 100644
index 0000000..c271a29
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/codec_devices.c
@@ -0,0 +1,57 @@
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include "codec_devices.h"
+
+struct codec_device_desc codec_devices[] = {
+    {
+        .name = "pad",
+        .plan_name = "PAD",
+        .normal_ops = &pad_normal_ops,
+        .fm_ops     = &pad_fm_ops,
+        .factory_ops= NULL,
+        .phone_ops  = NULL,
+        .other_ops  = NULL,
+        .device_init = pad_init,
+        .device_exit = pad_exit,
+    },
+    {
+        .name = "bp_fm_Analog_bt_Pcm",
+        .plan_name = "PLAN_ONE",
+        .normal_ops = &plan_one_normal_ops,
+        .fm_ops     = &plan_one_fm_ops,
+        .factory_ops= &plan_one_factory_ops,
+        .phone_ops  = &plan_one_phone_ops,
+        .other_ops  = NULL,
+        .device_init = plan_one_init,
+        .device_exit = plan_one_exit,
+    },
+    {
+        .name = "bp_pcm_fm_Analog_bt_Pcm",
+        .plan_name = "PLAN_TWO",
+        .normal_ops = &plan_two_normal_ops,
+        .fm_ops     = &plan_two_fm_ops,
+        .factory_ops= &plan_two_factory_ops,
+        .phone_ops  = &plan_two_phone_ops,
+        .other_ops  = NULL,
+        .device_init = plan_two_init,
+        .device_exit = plan_two_exit,
+    },
+    {
+        .name = "bp_pcm_fm_Analog_bt_bypass",
+        .plan_name = "PLAN_THREE",
+        .normal_ops = &plan_three_normal_ops,
+        .fm_ops     = &plan_three_fm_ops,
+        .factory_ops= &plan_three_factory_ops,
+        .phone_ops  = &plan_three_phone_ops,
+        .other_ops  = NULL,
+        .device_init = plan_three_init,
+        .device_exit = plan_three_exit,
+
+    },
+};
+
+int codec_devices_count = sizeof(codec_devices) / sizeof(struct codec_device_desc);
+
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/codec_devices.h b/softwinner/common/hardware/audio/libcodec_audio/codec_devices.h
new file mode 100644
index 0000000..db11176
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/codec_devices.h
@@ -0,0 +1,63 @@
+
+#ifndef __BP_DEVICES_H__
+#define __BP_DEVICES_H__
+
+#include "hal_codec.h"
+
+struct codec_device_desc {
+    char *name;
+    char *plan_name;
+
+    struct normal_ops *normal_ops;
+    struct fm_ops *fm_ops;
+    struct factory_ops *factory_ops;
+    struct phone_ops *phone_ops;
+    struct other_ops *other_ops;
+    int (*device_init)(void);
+    void (*device_exit)(void);
+};
+
+extern struct codec_device_desc codec_devices[];
+extern int codec_devices_count;
+
+
+/*pad as default*/
+extern struct normal_ops pad_normal_ops;
+extern struct fm_ops pad_fm_ops;
+extern int pad_init(void);
+extern void pad_exit(void);
+
+/*There're four layout for a31s pad phone*/
+/*hardware board,like em55, bp <--analog-->codec, FM<--analog-->codec,  BT<--pcm-->codec   PLAN_ONE*/  
+extern struct normal_ops plan_one_normal_ops;
+extern struct fm_ops plan_one_fm_ops;
+extern struct factory_ops plan_one_factory_ops;
+extern struct phone_ops plan_one_phone_ops;
+extern int plan_one_init(void);
+extern void plan_one_exit(void);
+
+/*hardware board, bp <--pcm-->codec, FM<--analog-->codec,  BT<--pcm-->codec  PLAN_TWO*/
+extern struct normal_ops plan_two_normal_ops;
+extern struct fm_ops plan_two_fm_ops;
+extern struct factory_ops plan_two_factory_ops;
+extern struct phone_ops plan_two_phone_ops;
+extern int plan_two_init(void);
+extern void plan_two_exit(void);
+
+/*hardware board, bp <--pcm-->codec, FM<--analog-->codec,  BT<--pcm-->codec  PLAN_THREE*/
+extern struct normal_ops plan_three_normal_ops;
+extern struct fm_ops plan_three_fm_ops;
+extern struct factory_ops plan_three_factory_ops;
+extern struct phone_ops plan_three_phone_ops;
+extern int plan_three_init(void);
+extern void plan_three_exit(void);
+
+/*hardware board, bp <--analog-->codec,  (BT,FM)<--pcm-->codec  PLAN_THREE*/
+extern struct codec_ops bp_Analog_bt_fm_Pcm_ops;
+
+
+/*hardware board, bp <--pcm-->codec, (BT,FM)<--pcm-->codec  PLAN_ALL_PCM*/
+extern struct codec_ops all_Pcm_ops;
+
+#endif
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/codec_devices/pad/manage.c b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/pad/manage.c
new file mode 100644
index 0000000..ab2ffa2
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/pad/manage.c
@@ -0,0 +1,445 @@
+
+#define LOG_TAG "codec_audio_plan_one"
+#define LOG_NDEBUG 0
+
+#include <stdlib.h>
+#include <string.h>
+#include <utils/Log.h>
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <alloca.h>
+//#include <tinyalsa/asoundlib.h>
+
+#include <semaphore.h>
+
+#include "codec_utils.h"
+
+struct record_data{
+	unsigned char* record_buf;      //record
+	int 		record_lenth;
+	volatile	int lenwrite;
+	volatile	int lenwritedown;
+	volatile	int lenwriteup;
+	volatile	int lenread;
+};
+static struct record_data record_data;
+
+static sem_t sem_record;
+
+static struct dev_stream g_bt_send_stream ;
+static struct dev_stream g_bt_receive_stream ;
+static struct dev_stream g_codec_send_stream ;
+static struct dev_stream g_codec_receive_stream ;
+
+static struct stream_transfer g_upload_voice ;
+static struct stream_transfer g_download_voice ;
+
+static void *manage_voice_thread(void *param);
+static int stream_transfer(struct stream_transfer *stream_transfer);
+
+extern struct pcm_config bt_pcm_out_config;
+extern struct pcm_config bt_pcm_in_config ;
+extern struct pcm_config codec_out_config ;
+extern struct pcm_config codec_in_config ;
+
+static int create_voice_manager(struct stream_transfer *transfer, voice_thread func, void *parg)
+{
+	int ret;
+	pthread_attr_t attr;
+
+
+	ret = sem_init(&transfer->sem, 0, 0);
+	if (ret) {
+		ALOGE("err: sem_init failed, ret=%d\n", ret);
+		goto sem_init_failed;
+	}
+
+	ret = pthread_attr_init (&attr);
+	if (ret != 0) {
+		ALOGE("err: pthread_attr_init failed err=%s", strerror(ret));
+		goto pthread_attr_init_failed;
+	}
+
+	ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+	if (ret != 0) {
+		ALOGE("err: pthread_attr_setdetachstate failed err=%s", strerror(ret));
+		goto pthread_attr_setdetachstate_failed;
+	}
+
+	transfer->manage_thread_run_flag = 1;
+	transfer->voice_thread_run_flag = 0;
+	transfer->voice_thread_exit_flag = 1;
+	transfer->record_flag = 0;
+	transfer->func = func;
+
+	ret = pthread_create(&transfer->pid, &attr, transfer->func, parg);
+	if (ret) {
+		ALOGE("err: pthread_create failed, ret=%d\n", ret);
+		goto pthread_create_failed;
+	}
+
+	return 0;
+
+pthread_create_failed:
+pthread_attr_setdetachstate_failed:
+pthread_attr_init_failed:
+	transfer->manage_thread_run_flag = 0;
+	transfer->voice_thread_run_flag = 0;
+	transfer->voice_thread_exit_flag = 1;
+	transfer->record_flag = 0;
+	transfer->func = func;
+	sem_destroy(&transfer->sem);
+
+sem_init_failed:
+	return -1;
+}
+
+int plan_one_start_bt_voice(void)
+{
+	g_upload_voice.voice_thread_run_flag = 1;
+	g_download_voice.voice_thread_run_flag = 1;
+
+	ALOGD("start_bt_voice g_upload_voice.voice_thread_run_flag = %d", g_upload_voice.voice_thread_run_flag);
+
+	while(!(g_download_voice.voice_thread_exit_flag && g_upload_voice.voice_thread_exit_flag) ){
+		ALOGD("plan_one_start_bt_voice: wait last voice ending");
+		usleep(100);
+	}
+
+	sem_post(&g_download_voice.sem);
+	sem_post(&g_upload_voice.sem);
+
+	return 0;
+}
+
+int plan_one_stop_bt_voice(void)
+{
+	g_upload_voice.record_flag = 0;
+	g_download_voice.record_flag = 0;
+
+	g_upload_voice.voice_thread_run_flag = 0;
+	g_download_voice.voice_thread_run_flag = 0;
+
+	while(!(g_download_voice.voice_thread_exit_flag && g_upload_voice.voice_thread_exit_flag) ){
+		ALOGD("plan_one_stop_bt_voice: wait voice ending");
+		usleep(100);
+	}
+
+	return 0;
+}
+
+int plan_one_mixer_buf(char *buf, int bytes)
+{
+
+    int     Retlen = bytes;
+    unsigned char* bufReadingPtr;
+
+
+    while(1)
+    {
+	if(record_data.lenwrite - record_data.lenread >= bytes)
+        {
+            bufReadingPtr = record_data.record_buf + (record_data.lenread%record_data.record_lenth);
+            if((bufReadingPtr+bytes) > (record_data.record_buf+record_data.record_lenth))
+            {
+            	ALOGD("1 bufReadingPtr:0x%p, Len:%d", bufReadingPtr,bytes);
+                int len1 = (record_data.record_buf + record_data.record_lenth - bufReadingPtr);
+                memcpy((void *)buf,(void *)bufReadingPtr,len1);
+                memcpy((void *)((char *)buf+len1),(void *)record_data.record_buf,bytes-len1);
+            }
+            else
+            {
+
+            	ALOGD("2 bufReadingPtr:0x%p, Len:%d",bufReadingPtr,bytes);
+                memcpy(buf,bufReadingPtr,bytes);
+            }
+            Retlen = bytes;
+            record_data.lenread += bytes;
+	    break;
+       } else {
+		if(g_upload_voice.record_flag == 0 || g_download_voice.record_flag == 0){
+			break;
+		}	
+		sem_wait(&sem_record);	
+		if(g_upload_voice.record_flag == 0 || g_download_voice.record_flag == 0){
+			break;
+		}	
+        }
+    }
+	ALOGD("mixer bytes = %d", Retlen);
+
+	return Retlen;;
+}
+
+int plan_one_start_bt_record(void)
+{
+	int record_size=0;
+	char *record_buf = NULL;
+	int i=0,ret;
+	struct list_buf *new;
+
+	memset(&(record_data), 0, sizeof(struct record_data));
+
+	record_data.record_buf = (unsigned char *)malloc(g_upload_voice.stream_sender->buf_size * 10);
+	if (record_data.record_buf == NULL ){
+		ALOGD(" fail to malloc record_data.record_buf");
+		return -1;
+	}
+	record_data.record_lenth = g_upload_voice.stream_sender->buf_size * 10 ; 
+	memset(record_data.record_buf, 0, sizeof(record_data.record_lenth));
+
+	ALOGD("record_data.record_lenth:%d, record_data.record_buf:%p", record_data.record_lenth, record_data.record_buf);
+
+	ret = sem_init(&sem_record, 0, 0);
+	if (ret) {
+		ALOGE("err: sem_record failed, ret=%d\n", ret);
+		return -1;
+	}
+
+	g_upload_voice.record_flag = 1;
+	g_download_voice.record_flag = 1;
+	return 0;
+}
+
+int plan_one_stop_bt_record(void)
+{
+	g_upload_voice.record_flag = 0;
+	g_download_voice.record_flag = 0;
+
+	memset(&(record_data), 0, sizeof(struct record_data));	
+	sem_post(&sem_record);
+	sem_destroy(&sem_record);
+	if (record_data.record_buf){
+		free(record_data.record_buf);
+	}
+
+	return 0;
+}
+
+
+
+int plan_one_init_voice(void)
+{
+	int ret=-1;
+
+	memset(&g_bt_send_stream, 0, sizeof(struct dev_stream));
+	memset(&g_bt_receive_stream, 0, sizeof(struct dev_stream));
+	memset(&g_codec_send_stream, 0, sizeof(struct dev_stream));
+	memset(&g_codec_receive_stream, 0, sizeof(struct dev_stream));
+
+	memset(&g_upload_voice, 0, sizeof(struct stream_transfer));
+	memset(&g_download_voice, 0, sizeof(struct stream_transfer));
+
+	//pcm
+	g_bt_send_stream.type = BT;
+	g_bt_send_stream.direction = SENDER; //RECEIVER;
+	g_bt_send_stream.config= bt_pcm_out_config; 
+
+	g_bt_receive_stream.type = BT;
+	g_bt_receive_stream.direction = RECEIVER;
+	g_bt_receive_stream.config= bt_pcm_in_config; 
+
+	//codec
+	g_codec_send_stream.type = CODEC;
+	g_codec_send_stream.direction = SENDER;
+	g_codec_send_stream.config= codec_out_config; 
+
+	g_codec_receive_stream.type = CODEC;
+	g_codec_receive_stream.direction = RECEIVER;
+	g_codec_receive_stream.config= codec_in_config; 
+
+
+	//upload voice, and download voice
+	g_upload_voice.stream_sender= &g_bt_send_stream ;
+	g_upload_voice.stream_receiver= &g_codec_receive_stream ;
+	g_upload_voice.voice_direction = UPSTREAM;
+                       
+	g_download_voice.stream_sender= &g_codec_send_stream;
+	g_download_voice.stream_receiver= &g_bt_receive_stream;
+	g_download_voice.voice_direction = DOWNSTREAM;
+
+	ret = create_voice_manager(&g_upload_voice, manage_voice_thread, &g_upload_voice);
+	if (ret <0 ){
+		ALOGE("err: create voice_manager uploading of voice failed, ret=%d\n", ret);
+		return -1;
+	}
+
+	ret = create_voice_manager(&g_download_voice, manage_voice_thread, &g_download_voice);
+	if (ret <0 ){
+		ALOGE("err: create voice_manager downloading of voice failed, ret=%d\n", ret);
+		return -1;
+	}
+
+	return 0;
+}
+
+void plan_one_exit_voice(void)
+{
+	g_upload_voice.manage_thread_run_flag= 0;
+	g_download_voice.manage_thread_run_flag= 0;
+
+	sem_post(&g_download_voice.sem);
+	sem_post(&g_upload_voice.sem);
+
+	close_stream(&g_bt_send_stream);
+	close_stream(&g_bt_receive_stream);
+	close_stream(&g_codec_send_stream);
+	close_stream(&g_codec_receive_stream); 
+
+	sem_destroy(&g_download_voice.sem);
+	sem_destroy(&g_upload_voice.sem);
+	
+	memset(&g_upload_voice, 0, sizeof(struct stream_transfer));
+	memset(&g_download_voice, 0, sizeof(struct stream_transfer));
+}
+
+
+static void *manage_voice_thread(void *param)
+{
+	int ret = 0;
+	struct stream_transfer *transfer_stream = (struct stream_transfer*)param;
+
+	while(transfer_stream->manage_thread_run_flag){
+
+		ALOGV("common manager thread sleep\n");
+		sem_wait(&(transfer_stream->sem));
+		ALOGV("common manager thread wakeup\n");
+
+		if(transfer_stream->voice_thread_run_flag){
+			ret = init_stream(transfer_stream->stream_receiver);
+			if (ret <0 ){
+				ALOGE("err: voice_thread init stream receive_stream failed, ret=%d, ****LINE:%d,FUNC:%s", ret, __LINE__, __FUNCTION__);
+				return NULL;
+			}
+
+			ret = init_stream(transfer_stream->stream_sender);
+			if (ret <0 ){
+				ALOGE("err: voice_thread init stream  send_stream failed, ret=%d, ****LINE:%d,FUNC:%s", ret, __LINE__, __FUNCTION__);
+				return NULL;
+			}
+
+			transfer_stream->voice_thread_exit_flag = 0;
+
+			ALOGD("voice_thread start\n");
+			stream_transfer(transfer_stream);
+			ALOGD("voice_thread end\n");
+
+
+			close_stream(transfer_stream->stream_receiver);
+			close_stream(transfer_stream->stream_sender);
+
+			transfer_stream->voice_thread_exit_flag = 1;
+		}
+	}
+
+	ALOGD("common manager thread exit\n");
+
+	return param;
+}
+
+static int stream_transfer(struct stream_transfer *stream_transfer)
+{
+
+	struct dev_stream *stream_sender;
+	struct dev_stream *stream_receiver;
+	int size_transfer = 0;
+	int ret   =0;
+	int exit_flag   =0;
+	int i   =0;
+	short* Srcptr;
+	short* Drcptr;
+
+	stream_sender = stream_transfer->stream_sender;
+	stream_receiver = stream_transfer->stream_receiver;
+	size_transfer = stream_sender->buf_size;
+
+
+#ifdef  START_ZERO_BUFFER
+	/*  */
+	memset(stream_sender->buf, 0, stream_sender->buf_size);
+	pcm_write(stream_receiver->dev, stream_sender->buf, stream_sender->buf_size);
+#endif
+
+	while( 1 ){
+		if ( (!stream_transfer->voice_thread_run_flag) || (exit_flag == 1)){
+			break;	
+		}
+
+		ret = pcm_read(stream_sender->dev, stream_sender->buf, size_transfer);
+		if (ret != 0) {
+			exit_flag = 1;
+			ALOGE("err: read codec err:%s, ret=%d", strerror(errno), ret);
+			break;
+		}
+
+		if ( (!stream_transfer->voice_thread_run_flag) || (exit_flag == 1)){
+			break;	
+		}
+
+		ret = pcm_write(stream_receiver->dev, stream_sender->buf, size_transfer);
+		if (ret != 0) {
+			exit_flag = 1;
+			ALOGE("err: write pcm err:%s, ret=%d", strerror(errno), ret);
+		}
+
+		if ( (!stream_transfer->voice_thread_run_flag) || (exit_flag == 1)){
+			break;	
+		}
+
+		if (stream_transfer->record_flag == 1){
+			//,.
+			if (stream_transfer->voice_direction == UPSTREAM){
+				Srcptr = (short*)(stream_sender->buf);
+				Drcptr = (short*)(record_data.record_buf + (record_data.lenwriteup%record_data.record_lenth));
+				if(record_data.lenwriteup >= record_data.lenwritedown)
+				{
+					memcpy(Drcptr,Srcptr,size_transfer);
+				}
+				else
+				{
+					int i;
+					for(i=0;i<size_transfer/2;i++,Drcptr++)
+					{
+						*Drcptr = (*Drcptr + *Srcptr++)/2;
+					}
+					record_data.lenwrite += size_transfer;
+//				        sem_post(&sem_record);
+				}
+				record_data.lenwriteup += size_transfer;
+				//ALOGD("stream is upload");
+			} else {
+				Srcptr = (short*)(stream_sender->buf);
+				Drcptr = (short*)(record_data.record_buf + (record_data.lenwritedown%record_data.record_lenth));
+				if(record_data.lenwritedown >= record_data.lenwriteup)
+				{
+					memcpy(Drcptr,Srcptr,size_transfer);
+				}
+				else
+				{
+
+					for(i=0;i<size_transfer/2;i++,Drcptr++)
+					{
+						*Drcptr = ((int)*Drcptr + (int)(*Srcptr++))/2;
+					}
+					record_data.lenwrite += size_transfer;
+//				        sem_post(&sem_record);
+				}
+				record_data.lenwritedown += size_transfer;
+				//ALOGD("stream is download");
+			}	
+		        sem_post(&sem_record);
+		}
+
+		//ALOGD("pcm running ... , type=%d ",stream_sender->type);
+		if ( (!stream_transfer->voice_thread_run_flag) || (exit_flag == 1)){
+			break;	
+		}
+	}
+	return 0;
+}
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/codec_devices/pad/pad.c b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/pad/pad.c
new file mode 100644
index 0000000..bd18010
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/pad/pad.c
@@ -0,0 +1,224 @@
+
+#define LOG_TAG "codec_audio_pad"
+#define LOG_NDEBUG 0
+
+#include <stdlib.h>
+#include <string.h>
+#include <utils/Log.h>
+
+#include <cutils/properties.h>
+
+#include <system/audio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include "hal_codec.h"
+#include "pad.h"
+
+
+static int set_normal_volume(struct codec_client *client, int path, int vol)
+{
+	int headset_on=0, headphone_on=0, speaker_on=0;
+
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+
+	if (speaker_on){
+		ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		mixer_ctl_set_value(client->mixer_ctls->lineout_volume_control, 0, vol);
+	} else if ((headset_on || headphone_on)){
+		ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		mixer_ctl_set_value(client->mixer_ctls->master_playback_volume, 0, vol);
+	}
+
+	return 0;
+}
+
+static int set_normal_path(struct codec_client *client, int path)
+{
+	int headset_on=0, headphone_on=0, speaker_on=0, earpiece_on=0;
+	int switch_to_headset  =0;
+	int ret = -1, fd=0;
+	char prop_value[20]={0};
+	char h2w_state[2]={0};
+
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+	earpiece_on = path & AUDIO_DEVICE_OUT_EARPIECE;
+
+        mixer_ctl_set_value(client->mixer_ctls->audio_linein_in, 0, 0);  //turn off fm
+
+	ret = property_get("dev.bootcomplete", prop_value, "0");
+	if (ret > 0)
+	{
+		if (atoi(prop_value) == 0){
+			fd = open("/sys/class/switch/h2w/state", O_RDONLY);
+			if(fd>0){
+				ret = read(fd, h2w_state, sizeof(h2w_state));
+				close(fd);
+
+				if ( (atoi(h2w_state) == 2 || atoi(h2w_state) == 1) )
+				{
+					switch_to_headset  =1;
+				}
+			}
+		}
+	}
+
+	if (((headset_on || headphone_on) && speaker_on)){
+		ALOGV("in normal mode, headset and speaker on,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "spk_headset");
+	} else if(earpiece_on) {
+		mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "spk");
+		ALOGV("in earpiece mode, pad no earpiece but spk,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__); //no earpiece
+	} else if(switch_to_headset) {
+		mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "headset");
+		ALOGV("in boot switch_to_headset mode, headset,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__); 
+		switch_to_headset = 0;
+	} else {
+		ALOGV("in normal mode, headset or speaker on,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, speaker_on ? "spk" : "headset");
+	}
+	return 0;
+}
+
+static int set_normal_record_enable(struct codec_client *client, bool enable)
+{
+	mixer_ctl_set_value(client->mixer_ctls->audio_fm_record, 0, 0);
+	mixer_ctl_set_value(client->mixer_ctls->audio_phone_voice_record, 0, 0);
+	ALOGV("normal record mode 4,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+static int set_normal_record(struct codec_client *client, int path)
+{
+	ALOGV("normal record mode 4,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+
+static int mixer_vol[]={0,1,2,3,4,5,6,7}; //0~15
+static int spk_vol[]={16,18,21,23,25,26,28,30}; //0~31
+static int hp_vol[]={40,44,48,50,52,56,58,61}; //0~62
+static int set_fm_volume(struct codec_client *client, int path, int volume)
+{
+		int speaker_on=0,headset_on=0 ,headphone_on=0;
+		int speaker_vol=0, headset_vol=0;
+
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+
+
+
+		int val = 0;
+		if (volume >= 10) {
+			val = 7 ;	
+			speaker_vol = 25;
+			headset_vol = 35;
+		} else if (volume >= 8){
+			val = 6 ;	
+			speaker_vol = 25;
+			headset_vol = 35;
+		} else if (volume >= 6){
+			val = 5 ;	
+			speaker_vol = 25;
+			headset_vol = 35;
+		} else if (volume >= 4){
+			val = 4 ;	
+			speaker_vol = 25;
+			headset_vol = 35;
+		} else if (volume >= 2){
+			val = 3 ;	
+			speaker_vol = 25;
+			headset_vol = 35;
+		} else {
+			val = 2 ;	
+			speaker_vol = 25;
+			headset_vol = 35;
+		}
+
+	mixer_ctl_set_value(client->mixer_ctls->linein_g_boost_stage_output_mixer_control, 0, mixer_vol[val]);
+
+	if (speaker_on){
+		mixer_ctl_set_value(client->mixer_ctls->lineout_volume_control, 0, spk_vol[val]);
+	} else {
+		mixer_ctl_set_value(client->mixer_ctls->master_playback_volume, 0, hp_vol[val]);
+	} 
+	ALOGV("4 set fm , adev_set_voice_volume, volume: %d, val=%d", volume, val);
+	return 0;
+}
+
+static int set_fm_path(struct codec_client *client, int path)
+{
+	int headset_on=0, headphone_on=0, speaker_on=0;
+
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+
+	mixer_ctl_set_value(client->mixer_ctls->audio_linein_in, 0, 1);  
+
+	if (speaker_on){
+		mixer_ctl_set_value(client->mixer_ctls->audio_headphone_out, 0, 0);
+		mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 1);
+	} else {
+		mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 0);
+		mixer_ctl_set_value(client->mixer_ctls->audio_headphone_out, 0, 1);
+	} 
+	ALOGV("FM mode 4, devices is %s, ****LINE:%d,FUNC:%s", speaker_on ? "spk" : "headset",__LINE__,__FUNCTION__);
+
+	return 0;
+}
+static int set_fm_record_enable(struct codec_client *client, bool enable)
+{
+	mixer_ctl_set_value(client->mixer_ctls->audio_phone_voice_record, 0, 0);
+
+	if (enable){
+		mixer_ctl_set_value(client->mixer_ctls->audio_fm_record, 0, 1);
+	} else {
+		mixer_ctl_set_value(client->mixer_ctls->audio_fm_record, 0, 0);
+	}
+	ALOGV("fm record mode 4,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+static int set_fm_record(struct codec_client *client, int path)
+{
+	ALOGV("FM record mode 4, ****LINE:%d,FUNC:%s", __LINE__,__FUNCTION__);
+	return 0;
+}
+
+
+
+int pad_init(void)
+{
+	ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+void pad_exit(void)
+{
+	ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+}
+
+
+
+
+struct normal_ops pad_normal_ops = {
+    .set_normal_volume=set_normal_volume,
+    .set_normal_path=set_normal_path,
+    .set_normal_record_enable =set_normal_record_enable, 
+    .set_normal_record=set_normal_record,
+};
+
+struct fm_ops pad_fm_ops = {
+    .set_fm_volume=set_fm_volume,
+    .set_fm_path=set_fm_path,
+    .set_fm_record_enable =set_fm_record_enable, 
+    .set_fm_record=set_fm_record,
+};
+
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/codec_devices/pad/pad.h b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/pad/pad.h
new file mode 100644
index 0000000..25dba56
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/pad/pad.h
@@ -0,0 +1,11 @@
+
+
+#ifndef __PAD_H__
+#define __PAD_H__
+
+extern int pad_init(void);
+extern void pad_exit(void);
+
+#endif
+
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planOne/manage.c b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planOne/manage.c
new file mode 100644
index 0000000..4daa5f3
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planOne/manage.c
@@ -0,0 +1,493 @@
+
+#define LOG_TAG "codec_audio_plan_one"
+#define LOG_NDEBUG 0
+
+#include <stdlib.h>
+#include <string.h>
+#include <utils/Log.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <alloca.h>
+
+
+#include <semaphore.h>
+
+#include "codec_utils.h"
+
+struct record_data{
+	unsigned char* record_buf;      //record
+	int 		record_lenth;
+	volatile	int lenwrite;
+	volatile	int lenwritedown;
+	volatile	int lenwriteup;
+	volatile	int lenread;
+};
+static struct record_data record_data;
+
+static sem_t g_sem_record;
+static bool g_enable_record;
+
+static int bluetooth_up_vol = 0;
+
+static struct dev_stream g_bt_send_stream ;
+static struct dev_stream g_bt_receive_stream ;
+static struct dev_stream g_codec_send_stream ;
+static struct dev_stream g_codec_receive_stream ;
+
+static struct stream_transfer g_upload_voice ;
+static struct stream_transfer g_download_voice ;
+
+static void *manage_voice_thread(void *param);
+static int stream_transfer(struct stream_transfer *stream_transfer);
+
+extern struct pcm_config bt_pcm_out_config;
+extern struct pcm_config bt_pcm_in_config ;
+extern struct pcm_config codec_out_config ;
+extern struct pcm_config codec_in_config ;
+
+
+
+static int create_voice_manager(struct stream_transfer *transfer, voice_thread func, void *parg)
+{
+	int ret;
+	pthread_attr_t attr;
+
+
+	ret = sem_init(&transfer->sem, 0, 0);
+	if (ret) {
+		ALOGE("err: sem_init failed, ret=%d\n", ret);
+		goto sem_init_failed;
+	}
+
+	ret = pthread_attr_init (&attr);
+	if (ret != 0) {
+		ALOGE("err: pthread_attr_init failed err=%s", strerror(ret));
+		goto pthread_attr_init_failed;
+	}
+
+	ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+	if (ret != 0) {
+		ALOGE("err: pthread_attr_setdetachstate failed err=%s", strerror(ret));
+		goto pthread_attr_setdetachstate_failed;
+	}
+
+	transfer->manage_thread_run_flag = 1;
+	transfer->voice_thread_run_flag = 0;
+	transfer->voice_thread_exit_flag = 1;
+	transfer->record_flag = 0;
+	transfer->func = func;
+
+	ret = pthread_create(&transfer->pid, &attr, transfer->func, parg);
+	if (ret) {
+		ALOGE("err: pthread_create failed, ret=%d\n", ret);
+		goto pthread_create_failed;
+	}
+
+	return 0;
+
+pthread_create_failed:
+pthread_attr_setdetachstate_failed:
+pthread_attr_init_failed:
+	transfer->manage_thread_run_flag = 0;
+	transfer->voice_thread_run_flag = 0;
+	transfer->voice_thread_exit_flag = 1;
+	transfer->record_flag = 0;
+	transfer->func = func;
+	sem_destroy(&transfer->sem);
+
+sem_init_failed:
+	return -1;
+}
+
+int plan_one_start_bt_voice(int up_vol)
+{
+	g_upload_voice.voice_thread_run_flag = 1;
+	g_download_voice.voice_thread_run_flag = 1;
+
+	ALOGD("start_bt_voice g_upload_voice.voice_thread_run_flag = %d", g_upload_voice.voice_thread_run_flag);
+
+	while(!(g_download_voice.voice_thread_exit_flag && g_upload_voice.voice_thread_exit_flag) ){
+		ALOGD("plan_one_start_bt_voice: wait last voice ending");
+		usleep(100);
+	}
+
+	bluetooth_up_vol = up_vol;
+	sem_post(&g_download_voice.sem);
+	sem_post(&g_upload_voice.sem);
+
+	return 0;
+}
+
+int plan_one_stop_bt_voice(void)
+{
+	g_upload_voice.record_flag = 0;
+	g_download_voice.record_flag = 0;
+
+	g_upload_voice.voice_thread_run_flag = 0;
+	g_download_voice.voice_thread_run_flag = 0;
+
+	pcm_stop(g_upload_voice.stream_sender->dev);
+	pcm_stop(g_upload_voice.stream_receiver->dev);
+	pcm_stop(g_download_voice.stream_sender->dev);
+	pcm_stop(g_download_voice.stream_receiver->dev);
+
+	while(!(g_download_voice.voice_thread_exit_flag && g_upload_voice.voice_thread_exit_flag) ){
+		ALOGD("plan_one_stop_bt_voice: wait voice ending");
+		usleep(100);
+	}
+
+	bluetooth_up_vol = 0;
+
+	return 0;
+}
+
+
+static int g_exit_mixer_buf = 0; // 0 start , 1 wait exit
+
+int plan_one_mixer_buf(char *buf, int bytes)
+{
+    int     Retlen = bytes;
+    unsigned char* bufReadingPtr;
+
+		if(g_enable_record == false){
+			return 0;
+		}	
+
+    while(1)
+    {
+	if(record_data.lenwrite - record_data.lenread >= bytes)
+        {
+            bufReadingPtr = record_data.record_buf + (record_data.lenread%record_data.record_lenth);
+            if((bufReadingPtr+bytes) > (record_data.record_buf+record_data.record_lenth))
+            {
+            	ALOGD("1 bufReadingPtr:0x%p, Len:%d", bufReadingPtr,bytes);
+                int len1 = (record_data.record_buf + record_data.record_lenth - bufReadingPtr);
+                memcpy((void *)buf,(void *)bufReadingPtr,len1);
+                memcpy((void *)((char *)buf+len1),(void *)record_data.record_buf,bytes-len1);
+            }
+            else
+            {
+
+            	ALOGD("2 bufReadingPtr:0x%p, Len:%d",bufReadingPtr,bytes);
+                memcpy(buf,bufReadingPtr,bytes);
+            }
+            Retlen = bytes;
+            record_data.lenread += bytes;
+	    break;
+       } else {
+		ALOGD("mixer wait2");	
+		g_exit_mixer_buf = 0;
+		sem_wait(&g_sem_record);	
+		if(g_enable_record == false){
+			break;
+		}
+        }
+    }
+	ALOGD("mixer bytes = %d", Retlen);
+	g_exit_mixer_buf = 1;
+
+	return Retlen;;
+}
+
+int plan_one_start_bt_record(void)
+{
+	int record_size=0;
+	char *record_buf = NULL;
+	int i=0,ret;
+	struct list_buf *new;
+
+	memset(&(record_data), 0, sizeof(struct record_data));
+
+	record_data.record_buf = (unsigned char *)malloc(g_upload_voice.stream_sender->buf_size * 10);
+	if (record_data.record_buf == NULL ){
+		ALOGD(" fail to malloc record_data.record_buf");
+		return -1;
+	}
+	record_data.record_lenth = g_upload_voice.stream_sender->buf_size * 10 ; 
+	memset(record_data.record_buf, 0, sizeof(record_data.record_lenth));
+
+	ALOGD("record_data.record_lenth:%d, record_data.record_buf:%p", record_data.record_lenth, record_data.record_buf);
+
+	ret = sem_init(&g_sem_record, 0, 0);
+	if (ret) {
+		ALOGE("err: g_sem_record failed, ret=%d\n", ret);
+		return -1;
+	}
+
+	g_upload_voice.record_flag = 1;
+	g_download_voice.record_flag = 1;
+
+	g_exit_mixer_buf = 0;
+
+	g_enable_record = true;
+	return 0;
+}
+
+int plan_one_stop_bt_record(void)
+{
+	g_upload_voice.record_flag = 0;
+	g_download_voice.record_flag = 0;
+	g_enable_record = false;
+
+	memset(&(record_data), 0, sizeof(struct record_data));	
+
+	while(g_exit_mixer_buf == 0){
+		sem_post(&g_sem_record);
+		usleep(1000);
+	}
+	sem_destroy(&g_sem_record);
+	if (record_data.record_buf){
+		free(record_data.record_buf);
+	}
+		ALOGD("plan_one_stop_bt_record ");
+	return 0;
+}
+
+
+
+int plan_one_init_voice(void)
+{
+	int ret=-1;
+
+	g_enable_record = false;
+
+	memset(&g_bt_send_stream, 0, sizeof(struct dev_stream));
+	memset(&g_bt_receive_stream, 0, sizeof(struct dev_stream));
+	memset(&g_codec_send_stream, 0, sizeof(struct dev_stream));
+	memset(&g_codec_receive_stream, 0, sizeof(struct dev_stream));
+
+	memset(&g_upload_voice, 0, sizeof(struct stream_transfer));
+	memset(&g_download_voice, 0, sizeof(struct stream_transfer));
+
+	//pcm
+	g_bt_send_stream.type = BT;
+	g_bt_send_stream.direction = SENDER; //RECEIVER;
+	g_bt_send_stream.config= bt_pcm_in_config; 
+
+	g_bt_receive_stream.type = BT;
+	g_bt_receive_stream.direction = RECEIVER;
+	g_bt_receive_stream.config= bt_pcm_out_config; 
+
+	//codec
+	g_codec_send_stream.type = CODEC;
+	g_codec_send_stream.direction = SENDER;
+	g_codec_send_stream.config= codec_in_config; 
+
+	g_codec_receive_stream.type = CODEC;
+	g_codec_receive_stream.direction = RECEIVER;
+	g_codec_receive_stream.config= codec_out_config; 
+
+
+	//upload voice, and download voice
+	g_upload_voice.stream_sender= &g_bt_send_stream ;
+	g_upload_voice.stream_receiver= &g_codec_receive_stream ;
+	g_upload_voice.voice_direction = UPSTREAM;
+                       
+	g_download_voice.stream_sender= &g_codec_send_stream;
+	g_download_voice.stream_receiver= &g_bt_receive_stream;
+	g_download_voice.voice_direction = DOWNSTREAM;
+
+	ret = create_voice_manager(&g_upload_voice, manage_voice_thread, &g_upload_voice);
+	if (ret <0 ){
+		ALOGE("err: create voice_manager uploading of voice failed, ret=%d\n", ret);
+		return -1;
+	}
+
+	ret = create_voice_manager(&g_download_voice, manage_voice_thread, &g_download_voice);
+	if (ret <0 ){
+		ALOGE("err: create voice_manager downloading of voice failed, ret=%d\n", ret);
+		return -1;
+	}
+
+	return 0;
+}
+
+void plan_one_exit_voice(void)
+{
+	g_enable_record = false;
+
+	g_upload_voice.manage_thread_run_flag= 0;
+	g_download_voice.manage_thread_run_flag= 0;
+
+	sem_post(&g_download_voice.sem);
+	sem_post(&g_upload_voice.sem);
+
+	close_stream(&g_bt_send_stream);
+	close_stream(&g_bt_receive_stream);
+	close_stream(&g_codec_send_stream);
+	close_stream(&g_codec_receive_stream); 
+
+	sem_destroy(&g_download_voice.sem);
+	sem_destroy(&g_upload_voice.sem);
+	
+	memset(&g_upload_voice, 0, sizeof(struct stream_transfer));
+	memset(&g_download_voice, 0, sizeof(struct stream_transfer));
+}
+
+
+static void *manage_voice_thread(void *param)
+{
+	int ret = 0;
+	struct stream_transfer *transfer_stream = (struct stream_transfer*)param;
+
+	while(transfer_stream->manage_thread_run_flag){
+
+		ALOGV("common manager thread sleep\n");
+		sem_wait(&(transfer_stream->sem));
+		ALOGV("common manager thread wakeup\n");
+
+		if(transfer_stream->voice_thread_run_flag){
+			ret = init_stream(transfer_stream->stream_receiver);
+			if (ret <0 ){
+				ALOGE("err: voice_thread init stream receive_stream failed, ret=%d, ****LINE:%d,FUNC:%s", ret, __LINE__, __FUNCTION__);
+				return NULL;
+			}
+
+			ret = init_stream(transfer_stream->stream_sender);
+			if (ret <0 ){
+				ALOGE("err: voice_thread init stream  send_stream failed, ret=%d, ****LINE:%d,FUNC:%s", ret, __LINE__, __FUNCTION__);
+				return NULL;
+			}
+
+			transfer_stream->voice_thread_exit_flag = 0;
+
+			ALOGD("voice_thread start\n");
+			stream_transfer(transfer_stream);
+			ALOGD("voice_thread end\n");
+
+
+			close_stream(transfer_stream->stream_receiver);
+			close_stream(transfer_stream->stream_sender);
+
+			transfer_stream->voice_thread_exit_flag = 1;
+		}
+	}
+
+	ALOGD("common manager thread exit\n");
+
+	return param;
+}
+
+static int stream_transfer(struct stream_transfer *stream_transfer)
+{
+
+	struct dev_stream *stream_sender;
+	struct dev_stream *stream_receiver;
+	int size_transfer = 0;
+	int ret   =0;
+	int exit_flag   =0;
+	int i   =0;
+	short* Srcptr;
+	short* Drcptr;
+
+	stream_sender = stream_transfer->stream_sender;
+	stream_receiver = stream_transfer->stream_receiver;
+	size_transfer = stream_sender->buf_size;
+
+
+#ifdef  START_ZERO_BUFFER
+	/*  */
+	memset(stream_sender->buf, 0, stream_sender->buf_size);
+	pcm_write(stream_receiver->dev, stream_sender->buf, stream_sender->buf_size);
+#endif
+
+	ret =pcm_wait(stream_sender->dev, 0);
+	ret =pcm_wait(stream_receiver->dev, 0);
+
+	pcm_stop(stream_receiver->dev);
+	pcm_start(stream_receiver->dev);
+
+
+	while( 1 ){
+		if ( (!stream_transfer->voice_thread_run_flag) ){
+		ALOGE(" exit bt , ****LINE:%d,FUNC:%s, voice_direction=%d",__LINE__,__FUNCTION__, stream_transfer->voice_direction);
+			break;	
+		}
+
+		ret = pcm_read(stream_sender->dev, stream_sender->buf, size_transfer);
+		if (ret != 0) {
+			//exit_flag = 1;
+			ALOGE("err: read codec err:%s, ret=%d", strerror(errno), ret);
+			//break;
+		}
+
+		if ( (!stream_transfer->voice_thread_run_flag) ){
+			ALOGE(" exit bt , ****LINE:%d,FUNC:%s,voice_direction=%d",__LINE__,__FUNCTION__, stream_transfer->voice_direction);
+			break;	
+		}
+
+		if (stream_transfer->voice_direction == UPSTREAM){
+			ReduceVolume(stream_sender->buf,size_transfer, bluetooth_up_vol);
+			//ALOGE("bluetooth_up_vol =%d", bluetooth_up_vol);
+		}/**/
+
+		ret = pcm_write(stream_receiver->dev, stream_sender->buf, size_transfer);
+		if (ret != 0) {
+			//exit_flag = 1;
+			ALOGE("err: write pcm err:%s, ret=%d", strerror(errno), ret);
+		}
+
+		if ( (!stream_transfer->voice_thread_run_flag) ){
+			ALOGE(" exit bt , ****LINE:%d,FUNC:%s,svoice_direction=%d",__LINE__,__FUNCTION__, stream_transfer->voice_direction);
+			break;	
+		}
+
+		if (stream_transfer->record_flag == 1){
+			//,.
+			if (stream_transfer->voice_direction == UPSTREAM){
+				Srcptr = (short*)(stream_sender->buf);
+				Drcptr = (short*)(record_data.record_buf + (record_data.lenwriteup%record_data.record_lenth));
+				if(record_data.lenwriteup >= record_data.lenwritedown)
+				{
+					memcpy(Drcptr,Srcptr,size_transfer);
+				}
+				else
+				{
+					int i;
+					for(i=0;i<size_transfer/2;i++,Drcptr++)
+					{
+						*Drcptr = (*Drcptr + *Srcptr++)/2;
+					}
+					record_data.lenwrite += size_transfer;
+				}
+				record_data.lenwriteup += size_transfer;
+				//ALOGD("stream is upload");
+			} else {
+				Srcptr = (short*)(stream_sender->buf);
+				Drcptr = (short*)(record_data.record_buf + (record_data.lenwritedown%record_data.record_lenth));
+				if(record_data.lenwritedown >= record_data.lenwriteup)
+				{
+					memcpy(Drcptr,Srcptr,size_transfer);
+				}
+				else
+				{
+
+					for(i=0;i<size_transfer/2;i++,Drcptr++)
+					{
+						*Drcptr = ((int)*Drcptr + (int)(*Srcptr++))/2;
+					}
+					record_data.lenwrite += size_transfer;
+				}
+				record_data.lenwritedown += size_transfer;
+				//ALOGD("stream is download");
+			}	
+		        sem_post(&g_sem_record);
+		}
+
+		
+
+		//ALOGD("pcm running ... , type=%d ",stream_sender->type);
+		if ( (!stream_transfer->voice_thread_run_flag) ){
+		ALOGE(" exit bt , ****LINE:%d,FUNC:%s,svoice_direction=%d",__LINE__,__FUNCTION__, stream_transfer->voice_direction);
+			break;	
+		}
+	}
+	return 0;
+}
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planOne/plan_one.c b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planOne/plan_one.c
new file mode 100644
index 0000000..419f135
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planOne/plan_one.c
@@ -0,0 +1,540 @@
+
+#define LOG_TAG "codec_audio_plan_one"
+#define LOG_NDEBUG 0
+
+#include <stdlib.h>
+#include <string.h>
+#include <utils/Log.h>
+
+#include <cutils/properties.h>
+
+#include <system/audio.h>
+
+
+#include "hal_codec.h"
+#include "plan_one.h"
+
+
+static int no_earpiece = 0;
+static bool last_path_is_bt = false ;
+static bool wake_lock = false;
+static bool in_call = false;
+
+static int set_normal_volume(struct codec_client *client, int path, int vol)
+{
+	int headset_on=0, headphone_on=0, speaker_on=0;
+
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+
+	if (speaker_on){
+		ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		mixer_ctl_set_value(client->mixer_ctls->lineout_volume_control, 0, vol);
+	} else if ((headset_on || headphone_on)){
+		ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		mixer_ctl_set_value(client->mixer_ctls->master_playback_volume, 0, vol);
+	}
+
+	return 0;
+}
+
+static int set_normal_path(struct codec_client *client, int path)
+{
+	int headset_on=0, headphone_on=0, speaker_on=0, earpiece_on=0;
+
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+	earpiece_on = path & AUDIO_DEVICE_OUT_EARPIECE;
+
+	if(last_path_is_bt){
+		plan_one_stop_bt_voice();
+		last_path_is_bt = false;
+	}
+
+	if(in_call){
+		in_call = false;
+		mixer_ctl_set_value(client->mixer_ctls->audio_phone_end_call, 0, 1);
+	}
+
+
+	if(wake_lock){
+		releaseWakeLock();
+		wake_lock=false;
+	}
+
+        mixer_ctl_set_value(client->mixer_ctls->audio_linein_in, 0, 0);  //turn off fm
+
+
+	if ((headset_on || headphone_on) && speaker_on){
+		ALOGV("in normal mode, headset and speaker on,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "spk_headset");
+	} else if(earpiece_on && (no_earpiece!=1)) {
+		mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "earpiece");
+		ALOGV("in normal mode, earpiece on,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	} else if(headset_on | headphone_on) {
+		mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "headset");
+		ALOGV("in normal mode, headset on,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	} else {
+		ALOGV("in normal mode, speaker on,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "spk");
+	} 
+
+	return 0;
+}
+
+static int set_normal_record_enable(struct codec_client *client, bool enable)
+{
+	mixer_ctl_set_value(client->mixer_ctls->audio_fm_record, 0, 0);
+	mixer_ctl_set_value(client->mixer_ctls->audio_phone_voice_record, 0, 0);
+	ALOGV("normal record mode 4,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+static int set_normal_record(struct codec_client *client, int path)
+{
+	ALOGV("normal record mode 4,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+
+static int set_fm_volume(struct codec_client *client, int path, int volume)
+{
+	int speaker_on=0,headset_on=0 ,headphone_on=0;
+	int level;
+
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+
+	if (volume >= 10) {
+		level = 5;
+	} else if (volume >= 8){
+		level = 4;
+	} else if (volume >= 6){
+		level = 3;
+	} else if (volume >= 4){
+		level = 2;
+	} else if (volume >= 2){
+		level = 1;
+	} else {
+		level = 0;
+	}
+
+	if (speaker_on){
+		mixer_ctl_set_value(client->mixer_ctls->linein_g_boost_stage_output_mixer_control, 0, client->vol_array->fm_speaker_line_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->lineout_volume_control, 0, client->vol_array->fm_speaker_spk_gain[level]);
+	} else {
+		mixer_ctl_set_value(client->mixer_ctls->linein_g_boost_stage_output_mixer_control, 0,  client->vol_array->fm_headset_line_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->master_playback_volume, 0, client->vol_array->fm_headset_hp_gain[level]);
+	}
+
+	ALOGV("4 set fm , adev_set_voice_volume, volume: %d, level=%d", volume, level);
+	return 0;
+}
+
+static int fm_last_dev=0; // 1 = speaker, 2= headset;
+static int set_fm_path(struct codec_client *client, int path)
+{
+	int headset_on=0, headphone_on=0, speaker_on=0;
+
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+
+
+	ALOGV("FM mode, devices is:%d, ****LINE:%d,FUNC:%s", path ,__LINE__,__FUNCTION__);
+
+	mixer_ctl_set_value(client->mixer_ctls->audio_phone_end_call, 0, 1);
+	mixer_ctl_set_value(client->mixer_ctls->audio_linein_in, 0, 1);  
+
+	//speaker and headset all turn on , direct return. Don't do with alarm and ringtone in fm mode;
+	if( speaker_on && (headphone_on || headset_on) ){ 
+		ALOGV("FM mode Don't do with alarm and ringtone in fm mode, ****LINE:%d,FUNC:%s", __LINE__,__FUNCTION__);
+		if (fm_last_dev!=0){
+			speaker_on = fm_last_dev == 1 ? 1 : 0;
+		} else {
+			return 0;
+		}
+	}
+
+	if (speaker_on){
+		mixer_ctl_set_value(client->mixer_ctls->audio_headphone_out, 0, 0);
+		mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 1);
+		fm_last_dev=1;
+	} else {
+		mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 0);
+		mixer_ctl_set_value(client->mixer_ctls->audio_headphone_out, 0, 1);
+		fm_last_dev=2;
+	} 
+	ALOGV("FM mode 4, devices is %s, ****LINE:%d,FUNC:%s", speaker_on ? "spk" : "headset",__LINE__,__FUNCTION__);
+
+	return 0;
+}
+static int set_fm_record_enable(struct codec_client *client, bool enable)
+{
+	mixer_ctl_set_value(client->mixer_ctls->audio_phone_voice_record, 0, 0);
+
+	if (enable){
+		mixer_ctl_set_value(client->mixer_ctls->audio_fm_record, 0, 1);
+	} else {
+		mixer_ctl_set_value(client->mixer_ctls->audio_fm_record, 0, 0);
+	}
+	ALOGV("fm record mode 4,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+static int set_fm_record(struct codec_client *client, int path)
+{
+#if 0
+	int headset_on=0, headphone_on=0, speaker_on=0;
+
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+
+	mixer_ctl_set_value(client->mixer_ctls->audio_linein_in, 0, 1);  
+	if (speaker_on){
+		mixer_ctl_set_value(client->mixer_ctls->audio_headphone_out, 0, 0);
+		mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 1);
+	} else {
+		mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 0);
+		mixer_ctl_set_value(client->mixer_ctls->audio_headphone_out, 0, 1);
+	} 
+#endif	
+	ALOGV("FM record mode 4, ****LINE:%d,FUNC:%s", __LINE__,__FUNCTION__);
+
+	return 0;
+}
+
+
+
+static int set_factory_volume(struct codec_client *client, int path, int vol)
+{
+	ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+static int set_factory_path(struct codec_client *client, int path)
+{
+	mixer_ctl_set_value(client->mixer_ctls->audio_phone_end_call, 0, 1);
+
+	mixer_ctl_set_value(client->mixer_ctls->audio_phone_out, 0,1);
+	mixer_ctl_set_value(client->mixer_ctls->audio_phone_in, 0,1);
+
+	if(no_earpiece == 0){
+			mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_headphone_out, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_earpiece_out, 0, 1);
+
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+
+			ALOGV("in factory earpiece ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	} else if(no_earpiece == 1) {
+			mixer_ctl_set_value(client->mixer_ctls->audio_earpiece_out, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_headphone_out, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 1);
+
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+
+			ALOGV("in factory speaker pa ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	}
+
+	mixer_ctl_set_value(client->mixer_ctls->phonep_phonen_pre_amp_gain_control, 0, 7);
+	mixer_ctl_set_value(client->mixer_ctls->phone_g_boost_stage_output_mixer_control, 0, 7);
+	mixer_ctl_set_value(client->mixer_ctls->master_playback_volume, 0, 60);
+	mixer_ctl_set_value(client->mixer_ctls->lineout_volume_control, 0, 30);
+	ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+
+
+static int set_phone_volume(struct codec_client *client, int path, int volume)
+{
+	int level;
+	int speaker_on=0,headset_on=0 ,headphone_on=0,earpiece_on=0;
+	int speaker_vol=0, headset_vol=0, earpiece_vol=0;
+
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // with mic
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // no mic 
+	earpiece_on = path & AUDIO_DEVICE_OUT_EARPIECE;
+
+	if (volume >= 10) {
+		level = 5;
+	} else if (volume >= 8){
+		level = 4;
+	} else if (volume >= 6){
+		level = 3;
+	} else if (volume >= 4){
+		level = 2;
+	} else if (volume >= 2){
+		level = 1;
+	} else {
+		level = 0;
+	}
+
+	ALOGD("adev_set_voice_volume, speaker_on: %d, earpiece_on: %d, headset_on: %d", speaker_on ,earpiece_on, headset_on);
+	ALOGD("adev_set_voice_volume, volume:%d, level: %d", volume, level);
+
+	if (speaker_on  || (earpiece_on  && (no_earpiece == 1))){
+		mixer_ctl_set_value(client->mixer_ctls->phonep_phonen_pre_amp_gain_control, 0, client->vol_array->speaker_phonepn_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->phone_g_boost_stage_output_mixer_control, 0, client->vol_array->speaker_mixer_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->lineout_volume_control, 0, client->vol_array->speaker_spk_gain[level]);
+	} else if (earpiece_on && (no_earpiece == 0)){
+		mixer_ctl_set_value(client->mixer_ctls->phonep_phonen_pre_amp_gain_control, 0, client->vol_array->earpiece_phonepn_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->phone_g_boost_stage_output_mixer_control, 0, client->vol_array->earpiece_mixer_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->master_playback_volume, 0, client->vol_array->earpiece_hp_gain[level]);
+	} else if (headset_on || headphone_on){
+		mixer_ctl_set_value(client->mixer_ctls->phonep_phonen_pre_amp_gain_control, 0, client->vol_array->headset_phonepn_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->phone_g_boost_stage_output_mixer_control, 0, client->vol_array->headset_mixer_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->master_playback_volume, 0, client->vol_array->headset_hp_gain[level]);
+	}
+
+	return 0;
+}
+
+
+static bool is_in_record = false;
+static bool bluetooth_in_record = false;
+
+static int set_phone_path(struct codec_client *client, int path)
+{
+    int ret = -1;
+    int earpiece_on=0, headset_on=0, headphone_on=0, bt_on=0, speaker_on=0;
+    int pa_should_on=0;
+
+    headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+    headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+    speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+    earpiece_on = path & AUDIO_DEVICE_OUT_EARPIECE;
+    bt_on = path & AUDIO_DEVICE_OUT_ALL_SCO;
+
+	ALOGV("mode= phone mode 4, devices is 0x%x, ****LINE:%d,FUNC:%s", path, __LINE__,__FUNCTION__);
+
+	in_call = true;
+
+	if(last_path_is_bt){
+		plan_one_stop_bt_voice();
+
+		if (bluetooth_in_record == true){
+			plan_one_stop_bt_record();
+			bluetooth_in_record = false;
+		}
+
+		last_path_is_bt = false;
+
+		if(mixer_ctl_get_value(client->mixer_ctls->audio_adc_phone_in, 0) == 1 ){
+			mixer_ctl_set_value(client->mixer_ctls->audio_adc_phone_in, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_dac_phone_out, 0, 0);
+		}
+	}
+
+	if (is_in_record){
+		client->record_ops->set_record_source(!bt_on);			
+	}
+
+
+	if(mixer_ctl_get_value(client->mixer_ctls->audio_linein_in,0)){
+		mixer_ctl_set_value(client->mixer_ctls->audio_linein_in, 0, 0); //turn off fm
+	}
+
+
+	if (bt_on){
+		mixer_ctl_set_value(client->mixer_ctls->audio_phone_in, 0,0);
+	} else {
+		mixer_ctl_set_value(client->mixer_ctls->audio_phone_in, 0,1);
+	}
+
+#if 1
+	mixer_ctl_set_value(client->mixer_ctls->audio_phone_out, 0,1);
+
+		if(earpiece_on && (no_earpiece == 0)){
+			mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_headphone_out, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_earpiece_out, 0, 1);
+
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+
+			ALOGV("in earpiece ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		} else if(speaker_on || (earpiece_on  && (no_earpiece == 1))) {
+
+			mixer_ctl_set_value(client->mixer_ctls->audio_earpiece_out, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_headphone_out, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 1);
+
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+
+			ALOGV("in speaker pa ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		} else if (headphone_on) { //no mic hp3p 
+
+			mixer_ctl_set_value(client->mixer_ctls->audio_earpiece_out, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_headphone_out, 0, 1);
+
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+
+			ALOGV("in wire head with no mic ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		} else if (headset_on) {  //mic // hp4p
+
+			mixer_ctl_set_value(client->mixer_ctls->audio_earpiece_out, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_headphone_out, 0, 1);
+
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 1);
+
+			ALOGV("in wire head with mic ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		} else if (bt_on) {
+			if(!wake_lock){
+				grabPartialWakeLock();
+				wake_lock=true;
+			}
+
+			mixer_ctl_set_value(client->mixer_ctls->audio_earpiece_out, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_headphone_out, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 0);
+
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+
+			ALOGV("in bluetooth ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+			mixer_ctl_set_value(client->mixer_ctls->audio_adc_phone_in, 0, 1);
+			mixer_ctl_set_value(client->mixer_ctls->audio_dac_phone_out, 0, 1);
+			plan_one_start_bt_voice(client->vol_array->up_pcm_gain);
+			last_path_is_bt = true;
+
+			if (is_in_record && (bluetooth_in_record == false)){
+				plan_one_start_bt_record();	
+				bluetooth_in_record = true;	
+			}
+
+		}
+#endif
+	return 0;
+}
+
+
+static int set_phone_record_enable(struct codec_client *client, bool enable)
+{
+	mixer_ctl_set_value(client->mixer_ctls->audio_fm_record, 0, 0);
+
+	if (enable){
+		mixer_ctl_set_value(client->mixer_ctls->audio_phone_voice_record, 0, 1);
+		is_in_record = true;
+	} else {
+		if (is_in_record == true){
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_voice_record, 0, 0);
+			if( bluetooth_in_record ){
+           	             bluetooth_in_record = false;
+				plan_one_stop_bt_record();
+			}
+			client->record_ops->stop_record();
+			is_in_record = false;
+             	   	bluetooth_in_record = false;
+		}
+	}
+	ALOGV("phone record mode 4,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+static int set_phone_record(struct codec_client *client, int path)
+{
+    int ret = -1;
+    int bt_on=0;
+
+    bt_on = path & AUDIO_DEVICE_OUT_ALL_SCO;
+
+	if(bt_on){
+		bluetooth_in_record = true;
+		plan_one_start_bt_record();
+	} else {
+		if( bluetooth_in_record ){
+                        bluetooth_in_record = false;
+			plan_one_stop_bt_record();	
+		}
+	}
+
+	client->record_ops->set_record_source(!bt_on);
+	if(client->record_ops->start_record(4096) < 0){ // update later !!!!
+		ALOGE("common start record failed, ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		return -1;
+	}
+
+	ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+static int record_read_pcm_buf(struct codec_client *client, void* buffer, int bytes)
+{
+	ALOGV("1****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	
+	return plan_one_mixer_buf(buffer, bytes);
+}
+
+int plan_one_init(void)
+{
+	int ret = -1;
+	char prop_value[20];
+
+	ret = property_get("audio.without.earpiece", prop_value, "0");
+	if (ret > 0)
+	{		
+		if (atoi(prop_value) == 1)
+		{
+			no_earpiece = 1;
+			ALOGD("get property audio.without.earpiece: %d", no_earpiece);
+		}
+	}
+
+	ret = plan_one_init_voice();
+
+	ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+
+	return ret;
+}
+
+void plan_one_exit(void)
+{
+	plan_one_exit_voice();
+	ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+}
+
+
+
+
+struct normal_ops plan_one_normal_ops = {
+    .set_normal_volume=set_normal_volume,
+    .set_normal_path=set_normal_path,
+    .set_normal_record_enable =set_normal_record_enable, 
+    .set_normal_record=set_normal_record,
+};
+
+struct fm_ops plan_one_fm_ops = {
+    .set_fm_volume=set_fm_volume,
+    .set_fm_path=set_fm_path,
+    .set_fm_record_enable =set_fm_record_enable, 
+    .set_fm_record=set_fm_record,
+};
+
+struct factory_ops plan_one_factory_ops= {
+    .set_factory_volume=set_factory_volume,
+    .set_factory_path=set_factory_path,
+};
+
+struct phone_ops plan_one_phone_ops= {
+    .set_phone_volume=set_phone_volume,
+    .set_phone_path=set_phone_path,
+    .set_phone_record_enable =set_phone_record_enable, 
+    .set_phone_record=set_phone_record,
+    .record_read_pcm_buf=record_read_pcm_buf,
+};
+
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planOne/plan_one.h b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planOne/plan_one.h
new file mode 100644
index 0000000..07e7dba
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planOne/plan_one.h
@@ -0,0 +1,18 @@
+
+
+#ifndef __PLAN_ONE_H__
+#define __PLAN_ONE_H__
+
+extern int plan_one_init_voice(void);
+extern void plan_one_exit_voice(void);
+extern int plan_one_start_bt_voice(int up_vol);
+extern int plan_one_stop_bt_voice(void);
+extern int plan_one_start_bt_record(void);
+extern int plan_one_stop_bt_record(void);
+extern int plan_one_mixer_buf(char *buffer, int bytes);
+extern int plan_one_init(void);
+extern void plan_one_exit(void);
+
+#endif
+
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planThree/manage.c b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planThree/manage.c
new file mode 100644
index 0000000..403e495
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planThree/manage.c
@@ -0,0 +1,649 @@
+
+#define LOG_TAG "codec_audio"
+#define LOG_NDEBUG 0
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <poll.h>
+
+#include <sys/ioctl.h>
+
+#include <stdbool.h>
+#include <utils/Log.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <pthread.h>
+#include <alloca.h>
+
+
+
+#include <sound/asound.h>
+//#include <tinyalsa/asoundlib.h>
+
+#include <semaphore.h>
+
+#include "codec_utils.h"
+
+
+
+struct record_data{
+	unsigned char* record_buf;      //record
+	int record_lenth;
+volatile	int lenwrite;
+volatile	int lenwritedown;
+volatile	int lenwriteup;
+ volatile	int lenread;
+};
+
+static struct record_data record_data;
+
+static sem_t g_sem_record;
+static bool g_enable_record;
+
+static struct dev_stream g_bp_send_stream ;
+static struct dev_stream g_bp_receive_stream ;
+static struct dev_stream g_bt_send_stream ;
+static struct dev_stream g_bt_receive_stream ;
+static struct dev_stream g_codec_send_stream ;
+static struct dev_stream g_codec_receive_stream ;
+
+static struct stream_transfer g_bt_upload_voice ;
+static struct stream_transfer g_bt_download_voice ;
+
+static struct stream_transfer g_bp_upload_voice ;
+static struct stream_transfer g_bp_download_voice ;
+
+static void *voice_down_thread(void *param);
+static void *voice_up_thread(void *param);
+static void *voice_bt_down_thread(void *param);
+static void *voice_bt_up_thread(void *param);
+static void *manager_thread(void *param);
+static void *manage_voice_thread(void *param);
+
+static int stream_transfer(struct stream_transfer *stream_transfer);
+
+extern struct pcm_config bp_i2s_out_config ;
+extern struct pcm_config bp_i2s_in_config ;
+extern struct pcm_config bt_pcm_out_config;
+extern struct pcm_config bt_pcm_in_config ;
+extern struct pcm_config codec_out_config ;
+extern struct pcm_config codec_in_config ;
+
+static int create_voice_manager(struct stream_transfer *transfer, voice_thread func, void *parg)
+{
+	int ret;
+	pthread_attr_t attr;
+
+
+	ret = sem_init(&transfer->sem, 0, 0);
+	if (ret) {
+		ALOGE("err: sem_init failed, ret=%d\n", ret);
+		goto sem_init_failed;
+	}
+
+	ret = pthread_attr_init (&attr);
+	if (ret != 0) {
+		ALOGE("err: pthread_attr_init failed err=%s", strerror(ret));
+		goto pthread_attr_init_failed;
+	}
+
+	ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+	if (ret != 0) {
+		ALOGE("err: pthread_attr_setdetachstate failed err=%s", strerror(ret));
+		goto pthread_attr_setdetachstate_failed;
+	}
+
+	transfer->manage_thread_run_flag = 1;
+	transfer->voice_thread_run_flag = 0;
+	transfer->voice_thread_exit_flag = 1;
+	transfer->record_flag = 0;
+	transfer->func = func;
+
+	ret = pthread_create(&transfer->pid, &attr, transfer->func, parg);
+	if (ret) {
+		ALOGE("err: pthread_create failed, ret=%d\n", ret);
+		goto pthread_create_failed;
+	}
+
+	return 0;
+
+pthread_create_failed:
+pthread_attr_setdetachstate_failed:
+pthread_attr_init_failed:
+	transfer->manage_thread_run_flag = 0;
+	transfer->voice_thread_run_flag = 0;
+	transfer->voice_thread_exit_flag = 1;
+	transfer->record_flag = 0;
+	transfer->func = func;
+	sem_destroy(&transfer->sem);
+
+sem_init_failed:
+	return -1;
+}
+
+//start phone voice , except bt
+int plan_three_start_voice(void)
+{
+	g_bp_upload_voice.voice_thread_run_flag = 1;
+	g_bp_download_voice.voice_thread_run_flag = 1;
+
+	g_bp_upload_voice.voice_thread_exit_flag = 1;
+	g_bp_download_voice.voice_thread_exit_flag = 1;
+
+#ifdef ENABLE_BT
+	while(!(g_bt_download_voice.voice_thread_exit_flag && g_bt_upload_voice.voice_thread_exit_flag) ){
+		ALOGD("plan_three_start_voice: wait bt voice ending");
+		usleep(1000);
+	}
+#endif
+
+	ALOGD("start_bp_voice g_bp_upload_voice.voice_thread_run_flag = %d", g_bp_upload_voice.voice_thread_run_flag);
+
+	sem_post(&g_bp_download_voice.sem);
+	sem_post(&g_bp_upload_voice.sem);
+
+	return 0;
+}
+
+//stop phone voice , except bt
+int plan_three_stop_voice(void)
+{
+	g_bp_upload_voice.voice_thread_run_flag = 0;
+	g_bp_download_voice.voice_thread_run_flag = 0;
+
+	pcm_stop(g_bp_upload_voice.stream_sender->dev);
+	pcm_stop(g_bp_upload_voice.stream_receiver->dev);
+	pcm_stop(g_bp_download_voice.stream_sender->dev);
+	pcm_stop(g_bp_download_voice.stream_receiver->dev);
+
+	while(!(g_bp_download_voice.voice_thread_exit_flag && g_bp_upload_voice.voice_thread_exit_flag )){
+		ALOGD("plan_three_stop_voice:  wait bp voice ending");
+		usleep(1000);
+	}
+	return 0;
+}
+
+
+int plan_three_start_bt_voice(int up_vol)
+{
+#ifdef ENABLE_BT
+	g_bt_upload_voice.voice_thread_run_flag = 1;
+	g_bt_download_voice.voice_thread_run_flag = 1;
+	g_bt_upload_voice.voice_thread_exit_flag = 1;
+	g_bt_download_voice.voice_thread_exit_flag = 1;
+
+	while(!(g_bp_download_voice.voice_thread_exit_flag && g_bp_upload_voice.voice_thread_exit_flag )){
+		ALOGD("plan_three_start_bt_voice: wait bp voice ending");
+		usleep(1000);
+	}
+	ALOGD("start_bt_voice g_bt_upload_voice.voice_thread_run_flag = %d", g_bt_upload_voice.voice_thread_run_flag);
+
+	sem_post(&g_bt_download_voice.sem);
+	sem_post(&g_bt_upload_voice.sem);
+#endif
+
+	return 0;
+}
+
+int plan_three_stop_bt_voice(void)
+{
+#ifdef ENABLE_BT
+	g_bt_upload_voice.voice_thread_run_flag = 0;
+	g_bt_download_voice.voice_thread_run_flag = 0;
+
+	pcm_stop(g_bt_upload_voice.stream_sender->dev);
+	pcm_stop(g_bt_upload_voice.stream_receiver->dev);
+	pcm_stop(g_bt_download_voice.stream_sender->dev);
+	pcm_stop(g_bt_download_voice.stream_receiver->dev);
+
+	while(!(g_bt_download_voice.voice_thread_exit_flag && g_bt_upload_voice.voice_thread_exit_flag )){
+		ALOGD("plan_three_stop_bt_voice:  wait bt voice ending");
+		usleep(1000);
+	}
+#endif
+	return 0;
+}
+
+static int g_exit_mixer_buf = 0; // 0 start , 1 wait exit
+
+int plan_three_mixer_buf(char *buf, int bytes)
+{
+
+    int     Retlen = bytes;
+    unsigned char* bufReadingPtr;
+
+		if(g_enable_record == false){
+			return 0;
+		}	
+
+    while(1)
+    {
+	if(record_data.lenwrite - record_data.lenread >= bytes)
+        {
+            bufReadingPtr = record_data.record_buf + (record_data.lenread%record_data.record_lenth);
+            if((bufReadingPtr+bytes) > (record_data.record_buf+record_data.record_lenth))
+            {
+            	ALOGV("bufReadingPtr:0x%p, Len:%d", bufReadingPtr,bytes);
+                int len1 = (record_data.record_buf + record_data.record_lenth - bufReadingPtr);
+                memcpy((void *)buf,(void *)bufReadingPtr,len1);
+                memcpy((void *)((char *)buf+len1),(void *)record_data.record_buf,bytes-len1);
+            }
+            else
+            {
+            	ALOGV("7 bufReadingPtr:0x%p, Len:%d",bufReadingPtr,bytes);
+                memcpy(buf,bufReadingPtr,bytes);
+            }
+            Retlen = bytes;
+            record_data.lenread += bytes;
+	    break;
+       } else {	
+		ALOGD("mixer wait2");	
+		g_exit_mixer_buf = 0;
+		sem_wait(&g_sem_record);	
+		if(g_enable_record == false){
+			break;
+		}	
+        }
+    }
+	ALOGD("3 mixer bytes = %d", Retlen);
+	g_exit_mixer_buf = 1;
+
+	return Retlen;;
+}
+
+int plan_three_start_record(void)
+{
+	int record_size=0;
+	char *record_buf = NULL;
+	int i=0,ret;
+	struct list_buf *new;
+
+	memset(&(record_data), 0, sizeof(struct record_data));
+
+	record_size = g_bp_upload_voice.voice_thread_run_flag == 1 ? g_bp_upload_voice.stream_sender->buf_size * 10: g_bt_upload_voice.stream_sender->buf_size * 10;
+
+	record_data.record_buf = (unsigned char *)malloc(record_size);
+	if (record_data.record_buf == NULL ){
+		ALOGD(" fail to malloc record_data.record_buf");
+		return -1;
+	}
+	record_data.record_lenth = record_size; 
+	memset(record_data.record_buf, 0, sizeof(record_data.record_lenth));
+
+	ALOGD("record_data.record_lenth:%d, record_data.record_buf:%p", record_data.record_lenth, record_data.record_buf);
+
+	ret = sem_init(&g_sem_record, 0, 0);
+	if (ret) {
+		ALOGE("err: g_sem_record failed, ret=%d\n", ret);
+		return -1;
+	}
+
+	g_bt_upload_voice.record_flag = 1;
+	g_bt_download_voice.record_flag = 1;
+	g_bp_upload_voice.record_flag = 1;
+	g_bp_download_voice.record_flag = 1;
+	
+	g_exit_mixer_buf = 0;
+	
+	g_enable_record = true;
+	ALOGD("plan_three_start_record");
+	return 0;
+}
+
+int plan_three_stop_record(void)
+{
+	g_bt_upload_voice.record_flag = 0;
+	g_bt_download_voice.record_flag = 0;
+	g_bp_upload_voice.record_flag = 0;
+	g_bp_download_voice.record_flag = 0;
+	g_enable_record =false;
+
+	memset(&(record_data), 0, sizeof(struct record_data));	
+	
+	while(g_exit_mixer_buf == 0){
+		sem_post(&g_sem_record);
+		usleep(1000);
+	}
+	sem_destroy(&g_sem_record);
+
+
+	if (record_data.record_buf){
+		free(record_data.record_buf);
+	}
+	ALOGD("plan_three_stop_record");
+	return 0;
+}
+
+
+
+int plan_three_init_voice(void)
+{
+	int ret=-1;
+
+	g_enable_record = false;
+
+	memset(&g_bp_send_stream, 0, sizeof(struct dev_stream));
+	memset(&g_bp_receive_stream, 0, sizeof(struct dev_stream));
+	memset(&g_bt_send_stream, 0, sizeof(struct dev_stream));
+	memset(&g_bt_receive_stream, 0, sizeof(struct dev_stream));
+	memset(&g_codec_send_stream, 0, sizeof(struct dev_stream));
+	memset(&g_codec_receive_stream, 0, sizeof(struct dev_stream));
+
+	memset(&g_bt_upload_voice, 0, sizeof(struct stream_transfer));
+	memset(&g_bt_download_voice, 0, sizeof(struct stream_transfer));
+
+	memset(&g_bp_upload_voice, 0, sizeof(struct stream_transfer));
+	memset(&g_bp_download_voice, 0, sizeof(struct stream_transfer));
+
+
+//===============================
+	//bp
+	g_bp_send_stream.type = BP;
+	g_bp_send_stream.direction = SENDER; //RECEIVER;
+	g_bp_send_stream.config= bp_i2s_in_config; 
+
+	g_bp_receive_stream.type = BP;
+	g_bp_receive_stream.direction = RECEIVER;
+	g_bp_receive_stream.config= bp_i2s_out_config; 
+
+	//pcm
+	g_bt_send_stream.type = BT;
+	g_bt_send_stream.direction = SENDER; //RECEIVER;
+	g_bt_send_stream.config= bt_pcm_in_config; 
+
+	g_bt_receive_stream.type = BT;
+	g_bt_receive_stream.direction = RECEIVER;
+	g_bt_receive_stream.config= bt_pcm_out_config; 
+
+	//codec
+	g_codec_send_stream.type = CODEC;
+	g_codec_send_stream.direction = SENDER;
+	g_codec_send_stream.config= codec_in_config; 
+
+	g_codec_receive_stream.type = CODEC;
+	g_codec_receive_stream.direction = RECEIVER;
+	g_codec_receive_stream.config= codec_out_config; 
+
+
+//===============================
+	//bt upload voice, and download voice
+	g_bt_upload_voice.stream_sender= &g_bt_send_stream ;
+	g_bt_upload_voice.stream_receiver= &g_bp_receive_stream ;
+	g_bt_upload_voice.voice_direction = UPSTREAM;
+                       
+	g_bt_download_voice.stream_sender= &g_bp_send_stream;
+	g_bt_download_voice.stream_receiver= &g_bt_receive_stream;
+	g_bt_download_voice.voice_direction = DOWNSTREAM ;
+
+	//bp upload voice, and download voice
+	g_bp_upload_voice.stream_sender= &g_codec_send_stream ;
+	g_bp_upload_voice.stream_receiver= &g_bp_receive_stream ;
+	g_bp_upload_voice.voice_direction = UPSTREAM;
+                       
+	g_bp_download_voice.stream_sender= &g_bp_send_stream;
+	g_bp_download_voice.stream_receiver= &g_codec_receive_stream;
+	g_bp_download_voice.voice_direction = DOWNSTREAM;
+
+
+#if ENABLE_BT
+	ret = create_voice_manager(&g_bt_upload_voice, manage_voice_thread, &g_bt_upload_voice);
+	if (ret <0 ){
+		ALOGE("err: create bt voice_manager uploading of voice failed, ret=%d\n", ret);
+		return -1;
+	}
+	ret = create_voice_manager(&g_bt_download_voice, manage_voice_thread, &g_bt_download_voice);
+	if (ret <0 ){
+		ALOGE("err: create bt voice_manager downloading of voice failed, ret=%d\n", ret);
+		return -1;
+	}
+#endif
+
+	ret = create_voice_manager(&g_bp_upload_voice, manage_voice_thread, &g_bp_upload_voice);
+	if (ret <0 ){
+		ALOGE("err: create bp voice_manager uploading of voice failed, ret=%d\n", ret);
+		return -1;
+	}
+
+	ret = create_voice_manager(&g_bp_download_voice, manage_voice_thread, &g_bp_download_voice);
+	if (ret <0 ){
+		ALOGE("err: create bp voice_manager downloading of voice failed, ret=%d\n", ret);
+		return -1;
+	}
+
+	return 0;
+}
+
+void plan_three_exit_voice(void)
+{
+	g_enable_record = false;
+
+	g_bt_upload_voice.manage_thread_run_flag= 0;
+	g_bt_download_voice.manage_thread_run_flag= 0;
+	g_bp_upload_voice.manage_thread_run_flag= 0;
+	g_bp_download_voice.manage_thread_run_flag= 0;
+
+	sem_post(&g_bt_download_voice.sem);
+	sem_post(&g_bt_upload_voice.sem);
+	sem_post(&g_bp_download_voice.sem);
+	sem_post(&g_bp_upload_voice.sem);
+
+	close_stream(&g_bt_send_stream);
+	close_stream(&g_bt_receive_stream);
+	close_stream(&g_codec_send_stream);
+	close_stream(&g_codec_receive_stream); 
+	close_stream(&g_bp_send_stream);
+	close_stream(&g_bp_receive_stream);
+
+	sem_destroy(&g_bt_download_voice.sem);
+	sem_destroy(&g_bt_upload_voice.sem);
+	sem_destroy(&g_bp_download_voice.sem);
+	sem_destroy(&g_bp_upload_voice.sem);
+	
+	memset(&g_bt_upload_voice, 0, sizeof(struct stream_transfer));
+	memset(&g_bt_download_voice, 0, sizeof(struct stream_transfer));
+	memset(&g_bp_upload_voice, 0, sizeof(struct stream_transfer));
+	memset(&g_bp_download_voice, 0, sizeof(struct stream_transfer));
+}
+
+
+
+static void *manage_voice_thread(void *param)
+{
+	int ret = 0;
+	struct stream_transfer *transfer_stream = (struct stream_transfer*)param;
+
+	while(transfer_stream->manage_thread_run_flag){
+
+		ALOGV("common manager thread sleep\n");
+		sem_wait(&(transfer_stream->sem));
+		ALOGV("common manager thread wakeup\n");
+
+		if(transfer_stream->voice_thread_run_flag){
+			ret = init_stream(transfer_stream->stream_receiver);
+			if (ret <0 ){
+				ALOGE("err: voice_thread init stream receive_stream failed, ret=%d, ****LINE:%d,FUNC:%s", ret, __LINE__, __FUNCTION__);
+				return NULL;
+			}
+
+			ret = init_stream(transfer_stream->stream_sender);
+			if (ret <0 ){
+				ALOGE("err: voice_thread init stream  send_stream failed, ret=%d, ****LINE:%d,FUNC:%s", ret, __LINE__, __FUNCTION__);
+				return NULL;
+			}
+
+			transfer_stream->voice_thread_exit_flag = 0;
+
+			ALOGD("voice_thread start\n");
+			stream_transfer(transfer_stream);
+			ALOGD("voice_thread end\n");
+
+
+			close_stream(transfer_stream->stream_receiver);
+			close_stream(transfer_stream->stream_sender);
+
+			transfer_stream->voice_thread_exit_flag = 1;
+		}
+	}
+
+	ALOGD("common manager thread exit\n");
+
+	return param;
+}
+
+
+static int stream_transfer(struct stream_transfer *stream_transfer)
+{
+
+	struct dev_stream *stream_sender;
+	struct dev_stream *stream_receiver;
+	short* Srcptr;
+	short* Drcptr;
+	int size_transfer = 0;
+	int ret   =0;
+	int exit_flag   =0;
+    	int i=0;
+
+	stream_sender = stream_transfer->stream_sender;
+	stream_receiver = stream_transfer->stream_receiver;
+	size_transfer = stream_sender->buf_size;
+
+
+#ifdef  START_ZERO_BUFFER
+	/*  */
+	memset(stream_sender->buf, 0, stream_sender->buf_size);
+	pcm_write(stream_receiver->dev, stream_sender->buf, stream_sender->buf_size);
+#endif
+
+
+	ret =pcm_wait(stream_sender->dev, 0);
+	ret =pcm_wait(stream_receiver->dev, 0);
+
+	pcm_stop(stream_receiver->dev);
+	pcm_start(stream_receiver->dev);
+
+
+	/* pa */
+	memset(stream_sender->buf, 0, stream_sender->buf_size);
+	pcm_write(stream_receiver->dev, stream_sender->buf, stream_sender->buf_size);
+
+    ALOGV("%s transfer start ok",stream_sender == &g_bp_send_stream ? "down":"up");
+
+	while( 1 ){
+
+		if ( (!stream_transfer->voice_thread_run_flag)){
+			break;	
+		}
+#if 0
+		if (SNDRV_PCM_STATE_XRUN == get_pcm_state(stream_sender->dev) ){
+			//ALOGD("read  SNDRV_PCM_STATE_XRUN ");
+			if(ioctl(stream_sender->dev->fd, SNDRV_PCM_IOCTL_PREPARE)){
+                		ALOGE("in read, fail to prepare SNDRV_PCM_STATE_XRUN ");
+			}
+			//usleep(3 * 1000);
+			ret =pcm_wait(stream_sender->dev, 0);
+			//ALOGD("pcm_read, pcm_wait ret=%d", ret);
+
+			//ALOGD("read after prepare state:%d ",get_pcm_state(stream_sender->dev));
+		}
+#endif
+		ret = pcm_read(stream_sender->dev, stream_sender->buf, size_transfer);
+		if (ret != 0) {
+			//exit_flag = 1;
+			// ALOGE("%s", stream_sender->dev->error);
+			//break;
+            continue;
+		}else if(stream_sender == &g_bp_send_stream) {
+            unsigned short *buf = (unsigned short*)stream_sender->buf;
+            ALOGV("from bp %x,%x,%x,%x",buf[0],buf[1],buf[2],buf[3]);
+        }else{
+            ALOGV("from codec");
+            // memset(stream_sender->buf,0,size_transfer);
+        }
+
+		if ( (!stream_transfer->voice_thread_run_flag)){
+			break;	
+		}
+#if 0
+		if (SNDRV_PCM_STATE_XRUN == get_pcm_state(stream_receiver->dev) ){
+			//ALOGD("write  SNDRV_PCM_STATE_XRUN ");
+			pcm_stop(stream_receiver->dev);
+			usleep(3 * 1000);
+			//ALOGD("write after stop state:%d ",get_pcm_state(stream_receiver->dev));
+			pcm_start(stream_receiver->dev);
+
+
+			ret =pcm_wait(stream_receiver->dev, 0);
+			//ALOGD("pcm_write, pcm_wait ret=%d", ret);
+
+			//usleep(3 * 1000);
+			//ALOGD("write after prepare state:%d ",get_pcm_state(stream_receiver->dev));
+		}
+#endif
+		ret = pcm_write(stream_receiver->dev, stream_sender->buf, size_transfer);
+		if (ret != 0) {
+			//exit_flag = 1;
+			// ALOGE("%s", stream_receiver->dev->error);
+		}else if(stream_receiver == &g_bp_receive_stream) {
+            ALOGV("to bp");
+        }else
+            ALOGV("to codec");
+
+		if ( (!stream_transfer->voice_thread_run_flag)){
+			break;	
+		}
+
+		if (stream_transfer->record_flag == 1){
+			//,.
+			if (stream_transfer->voice_direction == UPSTREAM){
+				Srcptr = (short*)(stream_sender->buf);
+				Drcptr = (short*)(record_data.record_buf + (record_data.lenwriteup%record_data.record_lenth));
+				if(record_data.lenwriteup >= record_data.lenwritedown)
+				{
+					memcpy(Drcptr,Srcptr,size_transfer);
+				}
+				else
+				{
+					int i;
+					for(i=0;i<size_transfer/2;i++,Drcptr++)
+					{
+						*Drcptr = (*Drcptr + *Srcptr++)/2;
+					}
+					record_data.lenwrite += size_transfer;
+
+				}
+				record_data.lenwriteup += size_transfer;
+				//ALOGD("stream is upload");
+			} else {
+				Srcptr = (short*)(stream_sender->buf);
+				Drcptr = (short*)(record_data.record_buf + (record_data.lenwritedown%record_data.record_lenth));
+				if(record_data.lenwritedown >= record_data.lenwriteup)
+				{
+					memcpy(Drcptr,Srcptr,size_transfer);
+				}
+				else
+				{
+
+					for(i=0;i<size_transfer/2;i++,Drcptr++)
+					{
+						*Drcptr = ((int)*Drcptr + (int)(*Srcptr++))/2;
+					}
+					record_data.lenwrite += size_transfer;
+				}
+				record_data.lenwritedown += size_transfer;
+			}	
+			sem_post(&g_sem_record);
+		}
+
+		if ( (!stream_transfer->voice_thread_run_flag)){
+			break;	
+		}
+	}
+
+	return 0;
+}
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planThree/plan.c b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planThree/plan.c
new file mode 100644
index 0000000..530c625
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planThree/plan.c
@@ -0,0 +1,479 @@
+
+#define LOG_TAG "codec_audio_plan_three"
+#define LOG_NDEBUG 0
+
+#include <stdlib.h>
+#include <string.h>
+#include <utils/Log.h>
+
+#include <cutils/properties.h>
+
+#include <system/audio.h>
+
+
+#include "hal_codec.h"
+#include "plan.h"
+
+
+static bool g_is_bp_thread_running = false;
+static int no_earpiece = 0;
+static bool wake_lock = false;
+
+static int set_normal_volume(struct codec_client *client, int path, int vol)
+{
+	int headset_on=0, headphone_on=0, speaker_on=0;
+
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+
+	if (speaker_on){
+		ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		mixer_ctl_set_value(client->mixer_ctls->lineout_volume_control, 0, vol);
+	} else if ((headset_on || headphone_on)){
+		ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		mixer_ctl_set_value(client->mixer_ctls->master_playback_volume, 0, vol);
+	}
+
+	return 0;
+}
+
+static bool last_path_is_bt = false ;
+
+static int set_normal_path(struct codec_client *client, int path)
+{
+	int headset_on=0, headphone_on=0, speaker_on=0, earpiece_on=0;
+
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+        earpiece_on = path & AUDIO_DEVICE_OUT_EARPIECE;
+
+	if (g_is_bp_thread_running){
+		g_is_bp_thread_running = false;
+		plan_three_stop_voice();
+		// mixer_ctl_set_value(client->mixer_ctls->audio_phone_end_call, 0, 1);
+	}
+
+	if(last_path_is_bt){
+		last_path_is_bt = false;
+		plan_three_stop_bt_voice();
+		// mixer_ctl_set_value(client->mixer_ctls->audio_phone_end_call, 0, 1);
+	}
+
+	if(wake_lock){
+		releaseWakeLock();
+		wake_lock=false;
+	}
+
+        // mixer_ctl_set_value(client->mixer_ctls->audio_linein_in, 0, 0);  //turn off fm
+
+
+	if (speaker_on){
+		mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 1);
+	} else {
+		mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 0);
+	} 
+	// if ((headset_on || headphone_on) && speaker_on){
+		// ALOGV("in normal mode, headset and speaker on,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		// mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "spk_headset");
+        // } else if(earpiece_on && (no_earpiece!=1)) {
+               // mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "earpiece");// "spk" : "headset");
+               // ALOGV("in normal mode, earpiece on,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	// } else if(headset_on | headphone_on) {
+		// mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "headset");
+		// ALOGV("in normal mode, headset on,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	// } else {
+		// ALOGV("in normal mode, speaker on,****LINE:%d,FUNC:%s, speaker_on=%d", __LINE__,__FUNCTION__, speaker_on);
+		// mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "spk" );
+	// }
+
+	return 0;
+}
+
+static int set_normal_record_enable(struct codec_client *client, bool enable)
+{
+	// mixer_ctl_set_value(client->mixer_ctls->audio_fm_record, 0, 0);
+    mixer_ctl_set_value(client->mixer_ctls->audio_phone_voice_record, 0, 0);
+    if(enable) {
+        mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+    }else {
+        mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 0);
+    }
+	ALOGV("normal record mode 4,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+static int set_normal_record(struct codec_client *client, int path)
+{
+	ALOGV("normal record mode 4,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+
+static int set_fm_volume(struct codec_client *client, int path, int volume)
+{	int speaker_on=0,headset_on=0 ,headphone_on=0;
+	int level;
+
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+
+	if (volume >= 10) {
+		level = 5;
+	} else if (volume >= 8){
+		level = 4;
+	} else if (volume >= 6){
+		level = 3;
+	} else if (volume >= 4){
+		level = 2;
+	} else if (volume >= 2){
+		level = 1;
+	} else {
+		level = 0;
+	}
+
+	if (speaker_on){
+		mixer_ctl_set_value(client->mixer_ctls->linein_g_boost_stage_output_mixer_control, 0, client->vol_array->fm_speaker_line_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->lineout_volume_control, 0, client->vol_array->fm_speaker_spk_gain[level]);
+	} else {
+		mixer_ctl_set_value(client->mixer_ctls->linein_g_boost_stage_output_mixer_control, 0,  client->vol_array->fm_headset_line_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->master_playback_volume, 0, client->vol_array->fm_headset_hp_gain[level]);
+	}
+
+	ALOGV("4 set fm , adev_set_voice_volume, volume: %d, level=%d", volume, level);
+	return 0;
+}
+
+static int set_fm_path(struct codec_client *client, int path)
+{
+	int headset_on=0, headphone_on=0, speaker_on=0;
+
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+
+	// mixer_ctl_set_value(client->mixer_ctls->audio_phone_end_call, 0, 1);
+	// mixer_ctl_set_value(client->mixer_ctls->audio_linein_in, 0, 1);  
+
+	if (speaker_on){
+		// mixer_ctl_set_value(client->mixer_ctls->audio_headphone_out, 0, 0);
+		mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 1);
+	} else {
+		mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 0);
+		// mixer_ctl_set_value(client->mixer_ctls->audio_headphone_out, 0, 1);
+	} 
+	ALOGV("FM mode 4, devices is %s, ****LINE:%d,FUNC:%s", speaker_on ? "spk" : "headset",__LINE__,__FUNCTION__);
+
+	return 0;
+}
+static int set_fm_record_enable(struct codec_client *client, bool enable)
+{
+	mixer_ctl_set_value(client->mixer_ctls->audio_phone_voice_record, 0, 0);
+
+	// if (enable){
+		// mixer_ctl_set_value(client->mixer_ctls->audio_fm_record, 0, 1);
+	// } else {
+		// mixer_ctl_set_value(client->mixer_ctls->audio_fm_record, 0, 0);
+	// }
+	ALOGV("fm record mode 4,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+static int set_fm_record(struct codec_client *client, int path)
+{
+	ALOGV("FM record mode 4, ****LINE:%d,FUNC:%s", __LINE__,__FUNCTION__);
+
+	return 0;
+}
+
+
+
+static int set_factory_volume(struct codec_client *client, int path, int vol)
+{
+	ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+static int set_factory_path(struct codec_client *client, int path)
+{
+	// mixer_ctl_set_value(client->mixer_ctls->audio_phone_end_call, 0, 1);
+	// mixer_ctl_set_value(client->mixer_ctls->audio_linein_in, 0, 1);  
+
+
+
+	if (g_is_bp_thread_running == false){
+		plan_three_start_voice();
+		g_is_bp_thread_running = true;
+	}
+
+    mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+
+	// if(no_earpiece == 0)	{
+		// mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+		// mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+// 
+		// mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "earpiece");// "spk" : "headset");
+		// ALOGV("in earpiece ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	// } else if(no_earpiece == 1) {
+		// mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+		// mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+// 
+		// mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "spk");// "spk" : "headset");
+	// }
+
+    mixer_ctl_set_value(client->mixer_ctls->master_playback_volume, 0, 60);
+	mixer_ctl_set_value(client->mixer_ctls->lineout_volume_control, 0, 30);
+
+	ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+
+
+static int set_phone_volume(struct codec_client *client, int path, int volume)
+{
+	int level;
+	int speaker_on=0,headset_on=0 ,headphone_on=0,earpiece_on=0;
+	int speaker_vol=0, headset_vol=0, earpiece_vol=0;
+
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // with mic
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // no mic 
+	earpiece_on = path & AUDIO_DEVICE_OUT_EARPIECE;
+
+	if (volume >= 10) {
+		level = 5;
+	} else if (volume >= 8){
+		level = 4;
+	} else if (volume >= 6){
+		level = 3;
+	} else if (volume >= 4){
+		level = 2;
+	} else if (volume >= 2){
+		level = 1;
+	} else {
+		level = 0;
+	}
+
+	ALOGD("adev_set_voice_volume, speaker_on: %d, earpiece_on: %d, headset_on: %d", speaker_on ,earpiece_on, headset_on);
+	ALOGD("adev_set_voice_volume, volume:%d, level: %d", volume, level);
+
+	if (speaker_on  || (earpiece_on  && (no_earpiece == 1))){
+		//mixer_ctl_set_value(client->mixer_ctls->phonep_phonen_pre_amp_gain_control, 0, client->vol_array->speaker_phonepn_gain[level]);
+		//mixer_ctl_set_value(client->mixer_ctls->phone_g_boost_stage_output_mixer_control, 0, client->vol_array->speaker_mixer_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->lineout_volume_control, 0, client->vol_array->speaker_spk_gain[level]);
+		ALOGD("adev_set_voice_volume, speaker volume:%d ", client->vol_array->speaker_spk_gain[level]);
+	} else if (earpiece_on && (no_earpiece == 0) ){
+		//mixer_ctl_set_value(client->mixer_ctls->phonep_phonen_pre_amp_gain_control, 0, client->vol_array->earpiece_phonepn_gain[level]);
+		//mixer_ctl_set_value(client->mixer_ctls->phone_g_boost_stage_output_mixer_control, 0, client->vol_array->earpiece_mixer_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->master_playback_volume, 0, client->vol_array->earpiece_hp_gain[level]);
+		ALOGD("adev_set_voice_volume, earpiece volume:%d ", client->vol_array->earpiece_hp_gain[level]);
+	} else if (headset_on || headphone_on){
+		//mixer_ctl_set_value(client->mixer_ctls->phonep_phonen_pre_amp_gain_control, 0, client->vol_array->headset_phonepn_gain[level]);
+		//mixer_ctl_set_value(client->mixer_ctls->phone_g_boost_stage_output_mixer_control, 0, client->vol_array->headset_mixer_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->master_playback_volume, 0, client->vol_array->headset_hp_gain[level]);
+		ALOGD("adev_set_voice_volume, headset volume:%d ", client->vol_array->headset_hp_gain[level]);
+	}
+
+	return 0;
+}
+
+
+static bool is_in_record = false;
+static bool bluetooth_in_record = false;
+
+static int set_phone_path(struct codec_client *client, int path)
+{
+    int ret = -1;
+    int earpiece_on=0, headset_on=0, headphone_on=0, bt_on=0, speaker_on=0;
+    int pa_should_on=0;
+
+    headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+    headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+    speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+    earpiece_on = path & AUDIO_DEVICE_OUT_EARPIECE;
+    bt_on = path & AUDIO_DEVICE_OUT_ALL_SCO;
+
+    ALOGV("mode= phone mode 4, devices is 0x%x, ****LINE:%d,FUNC:%s", path, __LINE__,__FUNCTION__);
+
+    if(!wake_lock){
+        grabPartialWakeLock();
+        wake_lock=true;
+    }
+
+    if(last_path_is_bt){
+        last_path_is_bt = false;
+        plan_three_stop_bt_voice();
+#if 0
+        if(mixer_ctl_get_value(client->mixer_ctls->audio_adc_phone_in, 0) == 1 ){
+            ALOGV("mode= phone audio_adc_phone_in=1");
+            mixer_ctl_set_value(client->mixer_ctls->audio_adc_phone_in, 0, 0);
+            mixer_ctl_set_value(client->mixer_ctls->audio_dac_phone_out, 0, 0);
+        }
+#endif
+    }
+
+    if (g_is_bp_thread_running == false){
+        plan_three_start_voice();
+        g_is_bp_thread_running = true;
+    }
+
+
+    // if(mixer_ctl_get_value(client->mixer_ctls->audio_linein_in,0)){
+        // mixer_ctl_set_value(client->mixer_ctls->audio_linein_in, 0, 0); //turn off fm
+    // }
+
+#if 0
+    if(earpiece_on && (no_earpiece == 0))	{
+        mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+        mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+
+        mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "earpiece");// "spk" : "headset");
+        ALOGV("in earpiece ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+    } else if(speaker_on || (earpiece_on  && (no_earpiece == 1))) {
+        mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+        mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+
+        mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "spk");// "spk" : "headset");
+        ALOGV("in speaker pa ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+    } else if (headphone_on) { //no mic hp3p 
+        mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+        mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+        mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "headset");// "spk" : "headset");
+        ALOGV("in wire head with no mic ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+    } else if (headset_on) {  //mic // hp4p
+        mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 0);
+        mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 1);
+        mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "headset");// "spk" : "headset");
+        ALOGV("in wire head with mic ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+    } else if (bt_on) {
+        if (g_is_bp_thread_running == true){
+            plan_three_stop_voice();
+            g_is_bp_thread_running = false;
+        }
+
+        mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 0);
+        mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+
+        ALOGV("in bluetooth ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+        mixer_ctl_set_value(client->mixer_ctls->audio_adc_phone_in, 0, 1);
+        mixer_ctl_set_value(client->mixer_ctls->audio_dac_phone_out, 0, 1);
+        plan_three_start_bt_voice(client->vol_array->up_pcm_gain);
+        last_path_is_bt = true;
+        //property_set(BLUETOOTH_VOICE, "on");
+        //adev->bluetooth_voice = true;
+    }
+#else
+    mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+    mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+#endif
+    return 0;
+}
+
+static int set_phone_record_enable(struct codec_client *client, bool enable)
+{
+	int ret = 0;
+
+	// mixer_ctl_set_value(client->mixer_ctls->audio_fm_record, 0, 0);
+
+	if (enable){
+		mixer_ctl_set_value(client->mixer_ctls->audio_phone_voice_record, 0, 1);
+
+		client->record_ops->set_record_source(false);	
+
+		if(client->record_ops->start_record(4096) < 0){ // update later !!!! 
+			ALOGE("common start record failed, ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+			return -1;
+		}
+
+		ret =plan_three_start_record();
+		if (ret) {
+			ALOGE("err: plan_three_start_record, ret=%d\n", ret);
+			return -1;
+		}
+		is_in_record = true;
+	} else {
+		if (is_in_record == true){
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_voice_record, 0, 0);
+			plan_three_stop_record();	
+			client->record_ops->stop_record();	
+			is_in_record = false;
+		}
+	}
+	ALOGV("phone record mode 4,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+static int set_phone_record(struct codec_client *client, int path)
+{
+	ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+static int record_read_pcm_buf(struct codec_client *client, void* buffer, int bytes)
+{
+	ALOGV("1****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	
+	return plan_three_mixer_buf(buffer, bytes);
+}
+
+int plan_three_init(void)
+{
+	int ret = -1;
+	char prop_value[20];
+
+	ret = property_get("audio.without.earpiece", prop_value, "0");
+	if (ret > 0)
+	{		
+		if (atoi(prop_value) == 1)
+		{
+			no_earpiece = 1;
+			ALOGD("get property audio.without.earpiece: %d", no_earpiece);
+		}
+	}
+
+	ret = plan_three_init_voice();
+
+	ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+
+	return ret;
+}
+
+void plan_three_exit(void)
+{
+	plan_three_exit_voice();
+	ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+}
+
+
+
+
+struct normal_ops plan_three_normal_ops = {
+    .set_normal_volume=set_normal_volume,
+    .set_normal_path=set_normal_path,
+    .set_normal_record_enable =set_normal_record_enable, 
+    .set_normal_record=set_normal_record,
+};
+
+struct fm_ops plan_three_fm_ops = {
+    .set_fm_volume=set_fm_volume,
+    .set_fm_path=set_fm_path,
+    .set_fm_record_enable =set_fm_record_enable, 
+    .set_fm_record=set_fm_record,
+};
+
+struct factory_ops plan_three_factory_ops= {
+    .set_factory_volume=set_factory_volume,
+    .set_factory_path=set_factory_path,
+};
+
+struct phone_ops plan_three_phone_ops= {
+    .set_phone_volume=set_phone_volume,
+    .set_phone_path=set_phone_path,
+    .set_phone_record_enable =set_phone_record_enable, 
+    .set_phone_record=set_phone_record,
+    .record_read_pcm_buf=record_read_pcm_buf,
+};
+
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planThree/plan.h b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planThree/plan.h
new file mode 100644
index 0000000..1aaa00f
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planThree/plan.h
@@ -0,0 +1,20 @@
+
+
+#ifndef __PLAN_three_H__
+#define __PLAN_three_H__
+
+extern int plan_three_init_voice(void);
+extern void plan_three_exit_voice(void);
+extern int plan_three_start_bt_voice(int up_vol);
+extern int plan_three_stop_bt_voice(void);
+extern int plan_three_start_record(void);
+extern int plan_three_stop_record(void);
+extern int plan_three_mixer_buf(char *buffer, int bytes);
+extern int plan_three_init(void);
+extern void plan_three_exit(void);
+
+extern int plan_three_start_voice(void);
+extern int plan_three_stop_voice(void);
+#endif
+
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planTwo/manage.c b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planTwo/manage.c
new file mode 100644
index 0000000..20c621e
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planTwo/manage.c
@@ -0,0 +1,649 @@
+
+#define LOG_TAG "codec_audio_plan_two"
+#define LOG_NDEBUG 0
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <poll.h>
+
+#include <sys/ioctl.h>
+
+#include <stdbool.h>
+#include <utils/Log.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <pthread.h>
+#include <alloca.h>
+
+
+
+#include <sound/asound.h>
+//#include <tinyalsa/asoundlib.h>
+
+#include <semaphore.h>
+
+#include "codec_utils.h"
+
+
+
+struct record_data{
+	unsigned char* record_buf;      //record
+	int record_lenth;
+volatile	int lenwrite;
+volatile	int lenwritedown;
+volatile	int lenwriteup;
+ volatile	int lenread;
+};
+
+static struct record_data record_data;
+
+static sem_t g_sem_record;
+static bool g_enable_record;
+
+static struct dev_stream g_bp_send_stream ;
+static struct dev_stream g_bp_receive_stream ;
+static struct dev_stream g_bt_send_stream ;
+static struct dev_stream g_bt_receive_stream ;
+static struct dev_stream g_codec_send_stream ;
+static struct dev_stream g_codec_receive_stream ;
+
+static struct stream_transfer g_bt_upload_voice ;
+static struct stream_transfer g_bt_download_voice ;
+
+static struct stream_transfer g_bp_upload_voice ;
+static struct stream_transfer g_bp_download_voice ;
+
+static void *voice_down_thread(void *param);
+static void *voice_up_thread(void *param);
+static void *voice_bt_down_thread(void *param);
+static void *voice_bt_up_thread(void *param);
+static void *manager_thread(void *param);
+static void *manage_voice_thread(void *param);
+
+static int stream_transfer(struct stream_transfer *stream_transfer);
+
+extern struct pcm_config bp_i2s_out_config ;
+extern struct pcm_config bp_i2s_in_config ;
+extern struct pcm_config bt_pcm_out_config;
+extern struct pcm_config bt_pcm_in_config ;
+extern struct pcm_config codec_out_config ;
+extern struct pcm_config codec_in_config ;
+
+static int create_voice_manager(struct stream_transfer *transfer, voice_thread func, void *parg)
+{
+	int ret;
+	pthread_attr_t attr;
+
+
+	ret = sem_init(&transfer->sem, 0, 0);
+	if (ret) {
+		ALOGE("err: sem_init failed, ret=%d\n", ret);
+		goto sem_init_failed;
+	}
+
+	ret = pthread_attr_init (&attr);
+	if (ret != 0) {
+		ALOGE("err: pthread_attr_init failed err=%s", strerror(ret));
+		goto pthread_attr_init_failed;
+	}
+
+	ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+	if (ret != 0) {
+		ALOGE("err: pthread_attr_setdetachstate failed err=%s", strerror(ret));
+		goto pthread_attr_setdetachstate_failed;
+	}
+
+	transfer->manage_thread_run_flag = 1;
+	transfer->voice_thread_run_flag = 0;
+	transfer->voice_thread_exit_flag = 1;
+	transfer->record_flag = 0;
+	transfer->func = func;
+
+	ret = pthread_create(&transfer->pid, &attr, transfer->func, parg);
+	if (ret) {
+		ALOGE("err: pthread_create failed, ret=%d\n", ret);
+		goto pthread_create_failed;
+	}
+
+	return 0;
+
+pthread_create_failed:
+pthread_attr_setdetachstate_failed:
+pthread_attr_init_failed:
+	transfer->manage_thread_run_flag = 0;
+	transfer->voice_thread_run_flag = 0;
+	transfer->voice_thread_exit_flag = 1;
+	transfer->record_flag = 0;
+	transfer->func = func;
+	sem_destroy(&transfer->sem);
+
+sem_init_failed:
+	return -1;
+}
+
+//start phone voice , except bt
+int plan_two_start_voice(void)
+{
+	g_bp_upload_voice.voice_thread_run_flag = 1;
+	g_bp_download_voice.voice_thread_run_flag = 1;
+
+	g_bp_upload_voice.voice_thread_exit_flag = 1;
+	g_bp_download_voice.voice_thread_exit_flag = 1;
+
+	while(!(g_bt_download_voice.voice_thread_exit_flag && g_bt_upload_voice.voice_thread_exit_flag) ){
+		ALOGD("plan_two_start_voice: wait bt voice ending");
+		usleep(1000);
+	}
+
+	ALOGD("start_bp_voice g_bp_upload_voice.voice_thread_run_flag = %d", g_bp_upload_voice.voice_thread_run_flag);
+
+	sem_post(&g_bp_download_voice.sem);
+	sem_post(&g_bp_upload_voice.sem);
+
+	return 0;
+}
+
+//stop phone voice , except bt
+int plan_two_stop_voice(void)
+{
+	g_bp_upload_voice.voice_thread_run_flag = 0;
+	g_bp_download_voice.voice_thread_run_flag = 0;
+
+	pcm_stop(g_bp_upload_voice.stream_sender->dev);
+	pcm_stop(g_bp_upload_voice.stream_receiver->dev);
+	pcm_stop(g_bp_download_voice.stream_sender->dev);
+	pcm_stop(g_bp_download_voice.stream_receiver->dev);
+
+	while(!(g_bp_download_voice.voice_thread_exit_flag && g_bp_upload_voice.voice_thread_exit_flag )){
+		ALOGD("plan_two_stop_voice:  wait bp voice ending");
+		usleep(1000);
+	}
+	return 0;
+}
+
+
+int plan_two_start_bt_voice(int up_vol)
+{
+	g_bt_upload_voice.voice_thread_run_flag = 1;
+	g_bt_download_voice.voice_thread_run_flag = 1;
+	g_bt_upload_voice.voice_thread_exit_flag = 1;
+	g_bt_download_voice.voice_thread_exit_flag = 1;
+
+	while(!(g_bp_download_voice.voice_thread_exit_flag && g_bp_upload_voice.voice_thread_exit_flag )){
+		ALOGD("plan_two_start_bt_voice: wait bp voice ending");
+		usleep(1000);
+	}
+	ALOGD("start_bt_voice g_bt_upload_voice.voice_thread_run_flag = %d", g_bt_upload_voice.voice_thread_run_flag);
+
+	sem_post(&g_bt_download_voice.sem);
+	sem_post(&g_bt_upload_voice.sem);
+
+	return 0;
+}
+
+int plan_two_stop_bt_voice(void)
+{
+	g_bt_upload_voice.voice_thread_run_flag = 0;
+	g_bt_download_voice.voice_thread_run_flag = 0;
+
+	pcm_stop(g_bt_upload_voice.stream_sender->dev);
+	pcm_stop(g_bt_upload_voice.stream_receiver->dev);
+	pcm_stop(g_bt_download_voice.stream_sender->dev);
+	pcm_stop(g_bt_download_voice.stream_receiver->dev);
+
+	while(!(g_bt_download_voice.voice_thread_exit_flag && g_bt_upload_voice.voice_thread_exit_flag )){
+		ALOGD("plan_two_stop_bt_voice:  wait bt voice ending");
+		usleep(1000);
+	}
+	return 0;
+}
+
+static int g_exit_mixer_buf = 0; // 0 start , 1 wait exit
+
+int plan_two_mixer_buf(char *buf, int bytes)
+{
+
+    int     Retlen = bytes;
+    unsigned char* bufReadingPtr;
+
+		if(g_enable_record == false){
+			return 0;
+		}	
+
+    while(1)
+    {
+	if(record_data.lenwrite - record_data.lenread >= bytes)
+        {
+            bufReadingPtr = record_data.record_buf + (record_data.lenread%record_data.record_lenth);
+            if((bufReadingPtr+bytes) > (record_data.record_buf+record_data.record_lenth))
+            {
+            	ALOGV("bufReadingPtr:0x%p, Len:%d", bufReadingPtr,bytes);
+                int len1 = (record_data.record_buf + record_data.record_lenth - bufReadingPtr);
+                memcpy((void *)buf,(void *)bufReadingPtr,len1);
+                memcpy((void *)((char *)buf+len1),(void *)record_data.record_buf,bytes-len1);
+            }
+            else
+            {
+            	ALOGV("7 bufReadingPtr:0x%p, Len:%d",bufReadingPtr,bytes);
+                memcpy(buf,bufReadingPtr,bytes);
+            }
+            Retlen = bytes;
+            record_data.lenread += bytes;
+	    break;
+       } else {	
+		ALOGD("mixer wait2");	
+		g_exit_mixer_buf = 0;
+		sem_wait(&g_sem_record);	
+		if(g_enable_record == false){
+			break;
+		}	
+        }
+    }
+	ALOGD("3 mixer bytes = %d", Retlen);
+	g_exit_mixer_buf = 1;
+
+	return Retlen;;
+}
+
+int plan_two_start_record(void)
+{
+	int record_size=0;
+	char *record_buf = NULL;
+	int i=0,ret;
+	struct list_buf *new;
+
+	memset(&(record_data), 0, sizeof(struct record_data));
+
+	record_size = g_bp_upload_voice.voice_thread_run_flag == 1 ? g_bp_upload_voice.stream_sender->buf_size * 10: g_bt_upload_voice.stream_sender->buf_size * 10;
+
+	record_data.record_buf = (unsigned char *)malloc(record_size);
+	if (record_data.record_buf == NULL ){
+		ALOGD(" fail to malloc record_data.record_buf");
+		return -1;
+	}
+	record_data.record_lenth = record_size; 
+	memset(record_data.record_buf, 0, sizeof(record_data.record_lenth));
+
+	ALOGD("record_data.record_lenth:%d, record_data.record_buf:%p", record_data.record_lenth, record_data.record_buf);
+
+	ret = sem_init(&g_sem_record, 0, 0);
+	if (ret) {
+		ALOGE("err: g_sem_record failed, ret=%d\n", ret);
+		return -1;
+	}
+
+	g_bt_upload_voice.record_flag = 1;
+	g_bt_download_voice.record_flag = 1;
+	g_bp_upload_voice.record_flag = 1;
+	g_bp_download_voice.record_flag = 1;
+	
+	g_exit_mixer_buf = 0;
+	
+	g_enable_record = true;
+	ALOGD("plan_two_start_record");
+	return 0;
+}
+
+int plan_two_stop_record(void)
+{
+	g_bt_upload_voice.record_flag = 0;
+	g_bt_download_voice.record_flag = 0;
+	g_bp_upload_voice.record_flag = 0;
+	g_bp_download_voice.record_flag = 0;
+	g_enable_record =false;
+
+	memset(&(record_data), 0, sizeof(struct record_data));	
+	
+	while(g_exit_mixer_buf == 0){
+		sem_post(&g_sem_record);
+		usleep(1000);
+	}
+	sem_destroy(&g_sem_record);
+
+
+	if (record_data.record_buf){
+		free(record_data.record_buf);
+	}
+	ALOGD("plan_two_stop_record");
+	return 0;
+}
+
+
+
+int plan_two_init_voice(void)
+{
+	int ret=-1;
+
+	g_enable_record = false;
+
+	memset(&g_bp_send_stream, 0, sizeof(struct dev_stream));
+	memset(&g_bp_receive_stream, 0, sizeof(struct dev_stream));
+	memset(&g_bt_send_stream, 0, sizeof(struct dev_stream));
+	memset(&g_bt_receive_stream, 0, sizeof(struct dev_stream));
+	memset(&g_codec_send_stream, 0, sizeof(struct dev_stream));
+	memset(&g_codec_receive_stream, 0, sizeof(struct dev_stream));
+
+	memset(&g_bt_upload_voice, 0, sizeof(struct stream_transfer));
+	memset(&g_bt_download_voice, 0, sizeof(struct stream_transfer));
+
+	memset(&g_bp_upload_voice, 0, sizeof(struct stream_transfer));
+	memset(&g_bp_download_voice, 0, sizeof(struct stream_transfer));
+
+
+//===============================
+	//bp
+	g_bp_send_stream.type = BP;
+	g_bp_send_stream.direction = SENDER; //RECEIVER;
+	g_bp_send_stream.config= bp_i2s_in_config; 
+
+	g_bp_receive_stream.type = BP;
+	g_bp_receive_stream.direction = RECEIVER;
+	g_bp_receive_stream.config= bp_i2s_out_config; 
+
+	//pcm
+	g_bt_send_stream.type = BT;
+	g_bt_send_stream.direction = SENDER; //RECEIVER;
+	g_bt_send_stream.config= bt_pcm_in_config; 
+
+	g_bt_receive_stream.type = BT;
+	g_bt_receive_stream.direction = RECEIVER;
+	g_bt_receive_stream.config= bt_pcm_out_config; 
+
+	//codec
+	g_codec_send_stream.type = CODEC;
+	g_codec_send_stream.direction = SENDER;
+	g_codec_send_stream.config= codec_in_config; 
+
+	g_codec_receive_stream.type = CODEC;
+	g_codec_receive_stream.direction = RECEIVER;
+	g_codec_receive_stream.config= codec_out_config; 
+
+
+//===============================
+	//bt upload voice, and download voice
+	g_bt_upload_voice.stream_sender= &g_bt_send_stream ;
+	g_bt_upload_voice.stream_receiver= &g_bp_receive_stream ;
+	g_bt_upload_voice.voice_direction = UPSTREAM;
+                       
+	g_bt_download_voice.stream_sender= &g_bp_send_stream;
+	g_bt_download_voice.stream_receiver= &g_bt_receive_stream;
+	g_bt_download_voice.voice_direction = DOWNSTREAM ;
+
+	//bp upload voice, and download voice
+	g_bp_upload_voice.stream_sender= &g_codec_send_stream ;
+	g_bp_upload_voice.stream_receiver= &g_bp_receive_stream ;
+	g_bp_upload_voice.voice_direction = UPSTREAM;
+                       
+	g_bp_download_voice.stream_sender= &g_bp_send_stream;
+	g_bp_download_voice.stream_receiver= &g_codec_receive_stream;
+	g_bp_download_voice.voice_direction = DOWNSTREAM;
+
+
+#if 0
+	ret = create_voice_manager(&g_bt_upload_voice, voice_bt_up_thread, &g_bt_upload_voice);
+	if (ret <0 ){
+		ALOGE("err: create voice_manager uploading of voice failed, ret=%d\n", ret);
+		return -1;
+	}
+
+	ret = create_voice_manager(&g_bt_download_voice, voice_bt_down_thread, &g_bt_download_voice);
+	if (ret <0 ){
+		ALOGE("err: create voice_manager downloading of voice failed, ret=%d\n", ret);
+		return -1;
+	}
+#else
+	ret = create_voice_manager(&g_bt_upload_voice, manage_voice_thread, &g_bt_upload_voice);
+	if (ret <0 ){
+		ALOGE("err: create bt voice_manager uploading of voice failed, ret=%d\n", ret);
+		return -1;
+	}
+
+	ret = create_voice_manager(&g_bt_download_voice, manage_voice_thread, &g_bt_download_voice);
+	if (ret <0 ){
+		ALOGE("err: create bt voice_manager downloading of voice failed, ret=%d\n", ret);
+		return -1;
+	}
+
+	ret = create_voice_manager(&g_bp_upload_voice, manage_voice_thread, &g_bp_upload_voice);
+	if (ret <0 ){
+		ALOGE("err: create bp voice_manager uploading of voice failed, ret=%d\n", ret);
+		return -1;
+	}
+
+	ret = create_voice_manager(&g_bp_download_voice, manage_voice_thread, &g_bp_download_voice);
+	if (ret <0 ){
+		ALOGE("err: create bp voice_manager downloading of voice failed, ret=%d\n", ret);
+		return -1;
+	}
+#endif
+
+	return 0;
+}
+
+void plan_two_exit_voice(void)
+{
+	g_enable_record = false;
+
+	g_bt_upload_voice.manage_thread_run_flag= 0;
+	g_bt_download_voice.manage_thread_run_flag= 0;
+	g_bp_upload_voice.manage_thread_run_flag= 0;
+	g_bp_download_voice.manage_thread_run_flag= 0;
+
+	sem_post(&g_bt_download_voice.sem);
+	sem_post(&g_bt_upload_voice.sem);
+	sem_post(&g_bp_download_voice.sem);
+	sem_post(&g_bp_upload_voice.sem);
+
+	close_stream(&g_bt_send_stream);
+	close_stream(&g_bt_receive_stream);
+	close_stream(&g_codec_send_stream);
+	close_stream(&g_codec_receive_stream); 
+	close_stream(&g_bp_send_stream);
+	close_stream(&g_bp_receive_stream);
+
+	sem_destroy(&g_bt_download_voice.sem);
+	sem_destroy(&g_bt_upload_voice.sem);
+	sem_destroy(&g_bp_download_voice.sem);
+	sem_destroy(&g_bp_upload_voice.sem);
+	
+	memset(&g_bt_upload_voice, 0, sizeof(struct stream_transfer));
+	memset(&g_bt_download_voice, 0, sizeof(struct stream_transfer));
+	memset(&g_bp_upload_voice, 0, sizeof(struct stream_transfer));
+	memset(&g_bp_download_voice, 0, sizeof(struct stream_transfer));
+}
+
+
+
+static void *manage_voice_thread(void *param)
+{
+	int ret = 0;
+	struct stream_transfer *transfer_stream = (struct stream_transfer*)param;
+
+	while(transfer_stream->manage_thread_run_flag){
+
+		ALOGV("common manager thread sleep\n");
+		sem_wait(&(transfer_stream->sem));
+		ALOGV("common manager thread wakeup\n");
+
+		if(transfer_stream->voice_thread_run_flag){
+			ret = init_stream(transfer_stream->stream_receiver);
+			if (ret <0 ){
+				ALOGE("err: voice_thread init stream receive_stream failed, ret=%d, ****LINE:%d,FUNC:%s", ret, __LINE__, __FUNCTION__);
+				return NULL;
+			}
+
+			ret = init_stream(transfer_stream->stream_sender);
+			if (ret <0 ){
+				ALOGE("err: voice_thread init stream  send_stream failed, ret=%d, ****LINE:%d,FUNC:%s", ret, __LINE__, __FUNCTION__);
+				return NULL;
+			}
+
+			transfer_stream->voice_thread_exit_flag = 0;
+
+			ALOGD("voice_thread start\n");
+			stream_transfer(transfer_stream);
+			ALOGD("voice_thread end\n");
+
+
+			close_stream(transfer_stream->stream_receiver);
+			close_stream(transfer_stream->stream_sender);
+
+			transfer_stream->voice_thread_exit_flag = 1;
+		}
+	}
+
+	ALOGD("common manager thread exit\n");
+
+	return param;
+}
+
+
+static int stream_transfer(struct stream_transfer *stream_transfer)
+{
+
+	struct dev_stream *stream_sender;
+	struct dev_stream *stream_receiver;
+	short* Srcptr;
+	short* Drcptr;
+	int size_transfer = 0;
+	int ret   =0;
+	int exit_flag   =0;
+    	int i=0;
+
+	stream_sender = stream_transfer->stream_sender;
+	stream_receiver = stream_transfer->stream_receiver;
+	size_transfer = stream_sender->buf_size;
+
+
+#ifdef  START_ZERO_BUFFER
+	/*  */
+	memset(stream_sender->buf, 0, stream_sender->buf_size);
+	pcm_write(stream_receiver->dev, stream_sender->buf, stream_sender->buf_size);
+#endif
+
+
+	ret =pcm_wait(stream_sender->dev, 0);
+	ret =pcm_wait(stream_receiver->dev, 0);
+
+	pcm_stop(stream_receiver->dev);
+	pcm_start(stream_receiver->dev);
+
+
+	/* pa */
+	memset(stream_sender->buf, 0, stream_sender->buf_size);
+	pcm_write(stream_receiver->dev, stream_sender->buf, stream_sender->buf_size);
+
+
+	while( 1 ){
+
+		if ( (!stream_transfer->voice_thread_run_flag)){
+			break;	
+		}
+#if 0
+		if (SNDRV_PCM_STATE_XRUN == get_pcm_state(stream_sender->dev) ){
+			//ALOGD("read  SNDRV_PCM_STATE_XRUN ");
+			if(ioctl(stream_sender->dev->fd, SNDRV_PCM_IOCTL_PREPARE)){
+                		ALOGE("in read, fail to prepare SNDRV_PCM_STATE_XRUN ");
+			}
+			//usleep(3 * 1000);
+			ret =pcm_wait(stream_sender->dev, 0);
+			//ALOGD("pcm_read, pcm_wait ret=%d", ret);
+
+			//ALOGD("read after prepare state:%d ",get_pcm_state(stream_sender->dev));
+		}
+#endif
+		ret = pcm_read(stream_sender->dev, stream_sender->buf, size_transfer);
+		if (ret != 0) {
+			//exit_flag = 1;
+			ALOGE("err: read codec err:%s, ret=%d", strerror(errno), ret);
+			//break;
+		}
+
+
+
+		if ( (!stream_transfer->voice_thread_run_flag)){
+			break;	
+		}
+#if 0
+		if (SNDRV_PCM_STATE_XRUN == get_pcm_state(stream_receiver->dev) ){
+			//ALOGD("write  SNDRV_PCM_STATE_XRUN ");
+			pcm_stop(stream_receiver->dev);
+			usleep(3 * 1000);
+			//ALOGD("write after stop state:%d ",get_pcm_state(stream_receiver->dev));
+			pcm_start(stream_receiver->dev);
+
+
+			ret =pcm_wait(stream_receiver->dev, 0);
+			//ALOGD("pcm_write, pcm_wait ret=%d", ret);
+
+			//usleep(3 * 1000);
+			//ALOGD("write after prepare state:%d ",get_pcm_state(stream_receiver->dev));
+		}
+#endif
+		ret = pcm_write(stream_receiver->dev, stream_sender->buf, size_transfer);
+		if (ret != 0) {
+			//exit_flag = 1;
+			ALOGE("err: write pcm err:%s, ret=%d", strerror(errno), ret);
+		}
+
+		if ( (!stream_transfer->voice_thread_run_flag)){
+			break;	
+		}
+
+
+
+		if (stream_transfer->record_flag == 1){
+			//,.
+			if (stream_transfer->voice_direction == UPSTREAM){
+				Srcptr = (short*)(stream_sender->buf);
+				Drcptr = (short*)(record_data.record_buf + (record_data.lenwriteup%record_data.record_lenth));
+				if(record_data.lenwriteup >= record_data.lenwritedown)
+				{
+					memcpy(Drcptr,Srcptr,size_transfer);
+				}
+				else
+				{
+					int i;
+					for(i=0;i<size_transfer/2;i++,Drcptr++)
+					{
+						*Drcptr = (*Drcptr + *Srcptr++)/2;
+					}
+					record_data.lenwrite += size_transfer;
+
+				}
+				record_data.lenwriteup += size_transfer;
+				//ALOGD("stream is upload");
+			} else {
+				Srcptr = (short*)(stream_sender->buf);
+				Drcptr = (short*)(record_data.record_buf + (record_data.lenwritedown%record_data.record_lenth));
+				if(record_data.lenwritedown >= record_data.lenwriteup)
+				{
+					memcpy(Drcptr,Srcptr,size_transfer);
+				}
+				else
+				{
+
+					for(i=0;i<size_transfer/2;i++,Drcptr++)
+					{
+						*Drcptr = ((int)*Drcptr + (int)(*Srcptr++))/2;
+					}
+					record_data.lenwrite += size_transfer;
+				}
+				record_data.lenwritedown += size_transfer;
+			}	
+			sem_post(&g_sem_record);
+		}
+
+		if ( (!stream_transfer->voice_thread_run_flag)){
+			break;	
+		}
+	}
+
+	return 0;
+}
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planTwo/plan_two.c b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planTwo/plan_two.c
new file mode 100644
index 0000000..839d769
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planTwo/plan_two.c
@@ -0,0 +1,464 @@
+
+#define LOG_TAG "codec_audio_plan_two"
+#define LOG_NDEBUG 0
+
+#include <stdlib.h>
+#include <string.h>
+#include <utils/Log.h>
+
+#include <cutils/properties.h>
+
+#include <system/audio.h>
+
+
+#include "hal_codec.h"
+#include "plan_two.h"
+
+
+static bool g_is_bp_thread_running = false;
+static int no_earpiece = 0;
+static bool wake_lock = false;
+
+static int set_normal_volume(struct codec_client *client, int path, int vol)
+{
+	int headset_on=0, headphone_on=0, speaker_on=0;
+
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+
+	if (speaker_on){
+		ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		mixer_ctl_set_value(client->mixer_ctls->lineout_volume_control, 0, vol);
+	} else if ((headset_on || headphone_on)){
+		ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		mixer_ctl_set_value(client->mixer_ctls->master_playback_volume, 0, vol);
+	}
+
+	return 0;
+}
+
+static bool last_path_is_bt = false ;
+
+static int set_normal_path(struct codec_client *client, int path)
+{
+	int headset_on=0, headphone_on=0, speaker_on=0, earpiece_on=0;
+
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+        earpiece_on = path & AUDIO_DEVICE_OUT_EARPIECE;
+
+	if (g_is_bp_thread_running){
+		g_is_bp_thread_running = false;
+		plan_two_stop_voice();
+		mixer_ctl_set_value(client->mixer_ctls->audio_phone_end_call, 0, 1);
+	}
+
+	if(last_path_is_bt){
+		last_path_is_bt = false;
+		plan_two_stop_bt_voice();
+		mixer_ctl_set_value(client->mixer_ctls->audio_phone_end_call, 0, 1);
+	}
+
+	if(wake_lock){
+		releaseWakeLock();
+		wake_lock=false;
+	}
+
+        mixer_ctl_set_value(client->mixer_ctls->audio_linein_in, 0, 0);  //turn off fm
+
+
+	if ((headset_on || headphone_on) && speaker_on){
+		ALOGV("in normal mode, headset and speaker on,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "spk_headset");
+        } else if(earpiece_on && (no_earpiece!=1)) {
+               mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "earpiece");// "spk" : "headset");
+               ALOGV("in normal mode, earpiece on,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	} else if(headset_on | headphone_on) {
+		mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "headset");
+		ALOGV("in normal mode, headset on,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	} else {
+		ALOGV("in normal mode, speaker on,****LINE:%d,FUNC:%s, speaker_on=%d", __LINE__,__FUNCTION__, speaker_on);
+		mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "spk" );
+	}
+
+	return 0;
+}
+
+static int set_normal_record_enable(struct codec_client *client, bool enable)
+{
+	mixer_ctl_set_value(client->mixer_ctls->audio_fm_record, 0, 0);
+	mixer_ctl_set_value(client->mixer_ctls->audio_phone_voice_record, 0, 0);
+	ALOGV("normal record mode 4,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+static int set_normal_record(struct codec_client *client, int path)
+{
+	ALOGV("normal record mode 4,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+
+static int set_fm_volume(struct codec_client *client, int path, int volume)
+{	int speaker_on=0,headset_on=0 ,headphone_on=0;
+	int level;
+
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+
+	if (volume >= 10) {
+		level = 5;
+	} else if (volume >= 8){
+		level = 4;
+	} else if (volume >= 6){
+		level = 3;
+	} else if (volume >= 4){
+		level = 2;
+	} else if (volume >= 2){
+		level = 1;
+	} else {
+		level = 0;
+	}
+
+	if (speaker_on){
+		mixer_ctl_set_value(client->mixer_ctls->linein_g_boost_stage_output_mixer_control, 0, client->vol_array->fm_speaker_line_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->lineout_volume_control, 0, client->vol_array->fm_speaker_spk_gain[level]);
+	} else {
+		mixer_ctl_set_value(client->mixer_ctls->linein_g_boost_stage_output_mixer_control, 0,  client->vol_array->fm_headset_line_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->master_playback_volume, 0, client->vol_array->fm_headset_hp_gain[level]);
+	}
+
+	ALOGV("4 set fm , adev_set_voice_volume, volume: %d, level=%d", volume, level);
+	return 0;
+}
+
+static int set_fm_path(struct codec_client *client, int path)
+{
+	int headset_on=0, headphone_on=0, speaker_on=0;
+
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+
+	mixer_ctl_set_value(client->mixer_ctls->audio_phone_end_call, 0, 1);
+	mixer_ctl_set_value(client->mixer_ctls->audio_linein_in, 0, 1);  
+
+	if (speaker_on){
+		mixer_ctl_set_value(client->mixer_ctls->audio_headphone_out, 0, 0);
+		mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 1);
+	} else {
+		mixer_ctl_set_value(client->mixer_ctls->audio_speaker_out, 0, 0);
+		mixer_ctl_set_value(client->mixer_ctls->audio_headphone_out, 0, 1);
+	} 
+	ALOGV("FM mode 4, devices is %s, ****LINE:%d,FUNC:%s", speaker_on ? "spk" : "headset",__LINE__,__FUNCTION__);
+
+	return 0;
+}
+static int set_fm_record_enable(struct codec_client *client, bool enable)
+{
+	mixer_ctl_set_value(client->mixer_ctls->audio_phone_voice_record, 0, 0);
+
+	if (enable){
+		mixer_ctl_set_value(client->mixer_ctls->audio_fm_record, 0, 1);
+	} else {
+		mixer_ctl_set_value(client->mixer_ctls->audio_fm_record, 0, 0);
+	}
+	ALOGV("fm record mode 4,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+static int set_fm_record(struct codec_client *client, int path)
+{
+	ALOGV("FM record mode 4, ****LINE:%d,FUNC:%s", __LINE__,__FUNCTION__);
+
+	return 0;
+}
+
+
+
+static int set_factory_volume(struct codec_client *client, int path, int vol)
+{
+	ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+static int set_factory_path(struct codec_client *client, int path)
+{
+	mixer_ctl_set_value(client->mixer_ctls->audio_phone_end_call, 0, 1);
+	mixer_ctl_set_value(client->mixer_ctls->audio_linein_in, 0, 1);  
+
+
+
+	if (g_is_bp_thread_running == false){
+		plan_two_start_voice();
+		g_is_bp_thread_running = true;
+	}
+
+	if(no_earpiece == 0)	{
+		mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+		mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+
+		mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "earpiece");// "spk" : "headset");
+		ALOGV("in earpiece ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	} else if(no_earpiece == 1) {
+		mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+		mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+
+		mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "spk");// "spk" : "headset");
+	}
+
+    mixer_ctl_set_value(client->mixer_ctls->master_playback_volume, 0, 60);
+	mixer_ctl_set_value(client->mixer_ctls->lineout_volume_control, 0, 30);
+
+	ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+
+
+static int set_phone_volume(struct codec_client *client, int path, int volume)
+{
+	int level;
+	int speaker_on=0,headset_on=0 ,headphone_on=0,earpiece_on=0;
+	int speaker_vol=0, headset_vol=0, earpiece_vol=0;
+
+	speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+	headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // with mic
+	headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // no mic 
+	earpiece_on = path & AUDIO_DEVICE_OUT_EARPIECE;
+
+	if (volume >= 10) {
+		level = 5;
+	} else if (volume >= 8){
+		level = 4;
+	} else if (volume >= 6){
+		level = 3;
+	} else if (volume >= 4){
+		level = 2;
+	} else if (volume >= 2){
+		level = 1;
+	} else {
+		level = 0;
+	}
+
+	ALOGD("adev_set_voice_volume, speaker_on: %d, earpiece_on: %d, headset_on: %d", speaker_on ,earpiece_on, headset_on);
+	ALOGD("adev_set_voice_volume, volume:%d, level: %d", volume, level);
+
+	if (speaker_on  || (earpiece_on  && (no_earpiece == 1))){
+		//mixer_ctl_set_value(client->mixer_ctls->phonep_phonen_pre_amp_gain_control, 0, client->vol_array->speaker_phonepn_gain[level]);
+		//mixer_ctl_set_value(client->mixer_ctls->phone_g_boost_stage_output_mixer_control, 0, client->vol_array->speaker_mixer_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->lineout_volume_control, 0, client->vol_array->speaker_spk_gain[level]);
+		ALOGD("adev_set_voice_volume, speaker volume:%d ", client->vol_array->speaker_spk_gain[level]);
+	} else if (earpiece_on && (no_earpiece == 0) ){
+		//mixer_ctl_set_value(client->mixer_ctls->phonep_phonen_pre_amp_gain_control, 0, client->vol_array->earpiece_phonepn_gain[level]);
+		//mixer_ctl_set_value(client->mixer_ctls->phone_g_boost_stage_output_mixer_control, 0, client->vol_array->earpiece_mixer_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->master_playback_volume, 0, client->vol_array->earpiece_hp_gain[level]);
+		ALOGD("adev_set_voice_volume, earpiece volume:%d ", client->vol_array->earpiece_hp_gain[level]);
+	} else if (headset_on || headphone_on){
+		//mixer_ctl_set_value(client->mixer_ctls->phonep_phonen_pre_amp_gain_control, 0, client->vol_array->headset_phonepn_gain[level]);
+		//mixer_ctl_set_value(client->mixer_ctls->phone_g_boost_stage_output_mixer_control, 0, client->vol_array->headset_mixer_gain[level]);
+		mixer_ctl_set_value(client->mixer_ctls->master_playback_volume, 0, client->vol_array->headset_hp_gain[level]);
+		ALOGD("adev_set_voice_volume, headset volume:%d ", client->vol_array->headset_hp_gain[level]);
+	}
+
+	return 0;
+}
+
+
+static bool is_in_record = false;
+static bool bluetooth_in_record = false;
+
+static int set_phone_path(struct codec_client *client, int path)
+{
+    int ret = -1;
+    int earpiece_on=0, headset_on=0, headphone_on=0, bt_on=0, speaker_on=0;
+    int pa_should_on=0;
+
+    headset_on = path & AUDIO_DEVICE_OUT_WIRED_HEADSET;  // hp4p
+    headphone_on = path & AUDIO_DEVICE_OUT_WIRED_HEADPHONE; // hp3p 
+    speaker_on = path & AUDIO_DEVICE_OUT_SPEAKER;
+    earpiece_on = path & AUDIO_DEVICE_OUT_EARPIECE;
+    bt_on = path & AUDIO_DEVICE_OUT_ALL_SCO;
+
+	ALOGV("mode= phone mode 4, devices is 0x%x, ****LINE:%d,FUNC:%s", path, __LINE__,__FUNCTION__);
+
+	if(!wake_lock){
+		grabPartialWakeLock();
+		wake_lock=true;
+	}
+
+	if(last_path_is_bt){
+		last_path_is_bt = false;
+		plan_two_stop_bt_voice();
+#if 1
+		if(mixer_ctl_get_value(client->mixer_ctls->audio_adc_phone_in, 0) == 1 ){
+			ALOGV("mode= phone audio_adc_phone_in=1");
+			mixer_ctl_set_value(client->mixer_ctls->audio_adc_phone_in, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_dac_phone_out, 0, 0);
+		}
+#endif
+	}
+
+	if (g_is_bp_thread_running == false){
+		plan_two_start_voice();
+		g_is_bp_thread_running = true;
+	}
+
+
+	if(mixer_ctl_get_value(client->mixer_ctls->audio_linein_in,0)){
+		mixer_ctl_set_value(client->mixer_ctls->audio_linein_in, 0, 0); //turn off fm
+	}
+
+#if 1
+		if(earpiece_on && (no_earpiece == 0))	{
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+
+			mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "earpiece");// "spk" : "headset");
+			ALOGV("in earpiece ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		} else if(speaker_on || (earpiece_on  && (no_earpiece == 1))) {
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+
+			mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "spk");// "spk" : "headset");
+			ALOGV("in speaker pa ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		} else if (headphone_on) { //no mic hp3p 
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 1);
+			mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "headset");// "spk" : "headset");
+			ALOGV("in wire head with no mic ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		} else if (headset_on) {  //mic // hp4p
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 1);
+			mixer_ctl_set_enum_by_string(client->mixer_ctls->audio_spk_headset_switch, "headset");// "spk" : "headset");
+			ALOGV("in wire head with mic ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+		} else if (bt_on) {
+	if (g_is_bp_thread_running == true){
+		plan_two_stop_voice();
+		g_is_bp_thread_running = false;
+	}
+
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_main_mic, 0, 0);
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_headset_mic, 0, 0);
+
+			ALOGV("in bluetooth ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+			mixer_ctl_set_value(client->mixer_ctls->audio_adc_phone_in, 0, 1);
+			mixer_ctl_set_value(client->mixer_ctls->audio_dac_phone_out, 0, 1);
+			plan_two_start_bt_voice(client->vol_array->up_pcm_gain);
+			last_path_is_bt = true;
+			//property_set(BLUETOOTH_VOICE, "on");
+			//adev->bluetooth_voice = true;
+		}
+#endif
+	return 0;
+}
+
+static int set_phone_record_enable(struct codec_client *client, bool enable)
+{
+	int ret = 0;
+
+	mixer_ctl_set_value(client->mixer_ctls->audio_fm_record, 0, 0);
+
+	if (enable){
+		mixer_ctl_set_value(client->mixer_ctls->audio_phone_voice_record, 0, 1);
+
+		client->record_ops->set_record_source(false);	
+
+		if(client->record_ops->start_record(4096) < 0){ // update later !!!! 
+			ALOGE("common start record failed, ****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+			return -1;
+		}
+
+		ret =plan_two_start_record();
+		if (ret) {
+			ALOGE("err: plan_two_start_record, ret=%d\n", ret);
+			return -1;
+		}
+		is_in_record = true;
+	} else {
+		if (is_in_record == true){
+			mixer_ctl_set_value(client->mixer_ctls->audio_phone_voice_record, 0, 0);
+			plan_two_stop_record();	
+			client->record_ops->stop_record();	
+			is_in_record = false;
+		}
+	}
+	ALOGV("phone record mode 4,****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+static int set_phone_record(struct codec_client *client, int path)
+{
+	ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	return 0;
+}
+
+static int record_read_pcm_buf(struct codec_client *client, void* buffer, int bytes)
+{
+	ALOGV("1****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+	
+	return plan_two_mixer_buf(buffer, bytes);
+}
+
+int plan_two_init(void)
+{
+	int ret = -1;
+	char prop_value[20];
+
+	ret = property_get("audio.without.earpiece", prop_value, "0");
+	if (ret > 0)
+	{		
+		if (atoi(prop_value) == 1)
+		{
+			no_earpiece = 1;
+			ALOGD("get property audio.without.earpiece: %d", no_earpiece);
+		}
+	}
+
+	ret = plan_two_init_voice();
+
+	ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+
+	return ret;
+}
+
+void plan_two_exit(void)
+{
+	plan_two_exit_voice();
+	ALOGV("****LINE:%d,FUNC:%s",__LINE__,__FUNCTION__);
+}
+
+
+
+
+struct normal_ops plan_two_normal_ops = {
+    .set_normal_volume=set_normal_volume,
+    .set_normal_path=set_normal_path,
+    .set_normal_record_enable =set_normal_record_enable, 
+    .set_normal_record=set_normal_record,
+};
+
+struct fm_ops plan_two_fm_ops = {
+    .set_fm_volume=set_fm_volume,
+    .set_fm_path=set_fm_path,
+    .set_fm_record_enable =set_fm_record_enable, 
+    .set_fm_record=set_fm_record,
+};
+
+struct factory_ops plan_two_factory_ops= {
+    .set_factory_volume=set_factory_volume,
+    .set_factory_path=set_factory_path,
+};
+
+struct phone_ops plan_two_phone_ops= {
+    .set_phone_volume=set_phone_volume,
+    .set_phone_path=set_phone_path,
+    .set_phone_record_enable =set_phone_record_enable, 
+    .set_phone_record=set_phone_record,
+    .record_read_pcm_buf=record_read_pcm_buf,
+};
+
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planTwo/plan_two.h b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planTwo/plan_two.h
new file mode 100644
index 0000000..d58bd3d
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/codec_devices/planTwo/plan_two.h
@@ -0,0 +1,20 @@
+
+
+#ifndef __PLAN_TWO_H__
+#define __PLAN_TWO_H__
+
+extern int plan_two_init_voice(void);
+extern void plan_two_exit_voice(void);
+extern int plan_two_start_bt_voice(int up_vol);
+extern int plan_two_stop_bt_voice(void);
+extern int plan_two_start_record(void);
+extern int plan_two_stop_record(void);
+extern int plan_two_mixer_buf(char *buffer, int bytes);
+extern int plan_two_init(void);
+extern void plan_two_exit(void);
+
+extern int plan_two_start_voice(void);
+extern int plan_two_stop_voice(void);
+#endif
+
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/codec_utils.c b/softwinner/common/hardware/audio/libcodec_audio/codec_utils.c
new file mode 100644
index 0000000..e6bfe03
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/codec_utils.c
@@ -0,0 +1,402 @@
+
+#define LOG_TAG "codec_audio"
+#define LOG_NDEBUG 0
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <utils/Log.h>
+#include <cutils/properties.h>
+
+#include "asoundlib.h"
+
+#include "codec_utils.h"
+
+struct pcm_config bp_i2s_out_config =
+{
+	.channels = 1,
+	.rate = 8000,
+	.period_size = 512,
+	.period_count = 4,
+	.format = PCM_FORMAT_S16_LE,
+	.start_threshold = 0,
+	.stop_threshold = 0,
+	.silence_threshold = 0,
+};
+
+struct pcm_config bp_i2s_in_config =
+{
+	.channels = 1,
+	.rate = 8000,
+	.period_size = 512,
+	.period_count = 4,
+	.format = PCM_FORMAT_S16_LE,
+	.start_threshold = 0,
+	.stop_threshold = 0,
+	.silence_threshold = 0,
+};
+
+struct pcm_config bt_pcm_out_config =
+{
+	.channels = 1,
+	.rate = 8000,
+	.period_size = 512,
+	.period_count =4,
+	.format = PCM_FORMAT_S16_LE,
+	.start_threshold = 0,
+	.stop_threshold = 0,
+	.silence_threshold = 0,
+};
+
+struct pcm_config bt_pcm_in_config =
+{
+	.channels = 1,
+	.rate = 8000,                
+	.period_size = 512,          
+	.period_count = 4,           
+	.format = PCM_FORMAT_S16_LE, 
+	.start_threshold = 0,        
+	.stop_threshold = 0,         
+	.silence_threshold = 0,  
+};
+
+struct pcm_config codec_out_config =
+{
+	.channels = 1,
+	.rate = 8000,                
+	.period_size = 512,          
+	.period_count = 4,           
+	.format = PCM_FORMAT_S16_LE, 
+	.start_threshold = 0,        
+	.stop_threshold = 0,         
+	.silence_threshold = 0,  
+
+};
+struct pcm_config codec_in_config =
+{
+	.channels = 1,
+	.rate = 8000,                
+	.period_size = 512,          
+	.period_count = 4,           
+	.format = PCM_FORMAT_S16_LE, 
+	.start_threshold = 0,        
+	.stop_threshold = 0,         
+	.silence_threshold = 0,  
+};
+
+
+void grabPartialWakeLock() 
+{
+	c_plus_plus_grabPartialWakeLock();
+}
+
+void releaseWakeLock() 
+{
+	c_plus_plus_releaseWakeLock();
+}
+
+char *audio_dev_name[3]={"audiocodec","sndpcm", "sndi2s"} ;
+
+int init_stream(struct dev_stream *dev_stream) 
+{
+	enum device_type dev_type = CARD_UNKNOWN;
+	int dev_direction =0;
+	int dev_node = -1;
+
+	switch (dev_stream->type){
+		case BT: 
+        case BP_PCM:
+		case BT_FM: 
+			dev_type = CARD_PCM;
+			break;	
+		case BP: 
+		case FM: 
+			dev_type = CARD_I2S;
+            break;
+		case CODEC: 
+			dev_type = CARD_CODEC;
+			break;	
+		default:
+			dev_type = CARD_UNKNOWN;				
+	};
+
+	if(dev_type == CARD_UNKNOWN){
+		ALOGE("unknown stream");
+		return -1;
+	}
+
+	dev_node = pcm_get_node_number(audio_dev_name[dev_type]);
+	if (dev_node < 0) {
+		ALOGE("err: get %s node number failed ", audio_dev_name[dev_type]);
+		return -1;
+	}
+
+    ALOGV("%s(%d):%s,%d",__func__,__LINE__,audio_dev_name[dev_type],dev_node);
+
+
+	dev_direction = dev_stream->direction == SENDER ? PCM_IN : PCM_OUT;
+
+	dev_stream->dev = pcm_open(dev_node, 0, dev_direction, &(dev_stream->config));
+	if (!pcm_is_ready(dev_stream->dev )) {
+		ALOGE("err: Unable to open  device (%s)", pcm_get_error(dev_stream->dev));
+		goto open_failed;
+	}
+
+	if (dev_direction == PCM_IN){ //only pcm_in alloc buffer
+		dev_stream->buf_size = pcm_get_buffer_size(dev_stream->dev);
+		dev_stream->buf = (void *)malloc(dev_stream->buf_size);
+		if (dev_stream->buf == NULL) {
+			ALOGE("Unable to allocate %d bytes", dev_stream->buf_size);
+			goto malloc_failed;
+		}
+		//ALOGD("sender stream type:%d, pcm_read buf=%d bytes",dev_stream->type, dev_stream->buf_size);
+	}
+	memset(dev_stream->buf, 0, dev_stream->buf_size);
+
+	ALOGD("dev_stream dev node =%d, type=%d, direction:%s, buf size:%d", 
+			dev_node, dev_stream->type, dev_stream->direction == SENDER ? "PCM_IN" : "PCM_OUT", pcm_get_buffer_size(dev_stream->dev));
+
+    	return 0;
+malloc_failed:
+	if (dev_stream->dev){
+		pcm_close(dev_stream->dev);	
+	}
+
+open_failed:
+    	return -1;
+}
+
+void close_stream(struct dev_stream *dev_stream) 
+{
+
+	if (dev_stream->buf){
+		free(dev_stream->buf);	
+	}
+
+	if (dev_stream->dev){
+		pcm_close(dev_stream->dev);	
+	}
+}
+
+void ReduceVolume(char *buf, int size, int repeat)
+{
+        int i,j;
+        int zhen_shu;
+        signed long minData = -0x8000;
+        signed long maxData = 0x7FFF;
+        signed short data ;
+        unsigned char low, hight;
+
+        if(!size){
+                return;
+        }   
+
+	zhen_shu = size - size%2;
+
+        for(i=0; i<zhen_shu; i+=2){
+		low = buf[i];
+                hight = buf[i+1];
+                data = low | (hight << 8);  
+                for(j=0; j< repeat; j++){
+                        data = data / 1.25;    
+                        if(data < minData){
+                                data = minData; 
+                        } else if (data > 0x7fff){
+                                data = maxData;
+                        }   
+                }   
+                buf[i] = (data) & 0x00ff;
+                buf[i+1] = ((data)>>8) & 0xff;
+        } 
+}
+
+
+int get_mixer(struct mixer_ctls *mixer_ctls)
+{
+    struct mixer *mixer;
+
+    mixer = mixer_open(0);
+    if (!mixer) {
+	    ALOGE("Unable to open the mixer, aborting.");
+	    return -1;
+    }
+
+
+    // mixer_ctls->phonep_phonen_pre_amp_gain_control = mixer_get_ctl_by_name(mixer,
+		    // MIXER_PHONEP_PHONEN_PRE_AMP_GAIN_CONTROL);
+    // if (!mixer_ctls->phonep_phonen_pre_amp_gain_control) {
+	    // ALOGE("Unable to find '%s' mixer control",MIXER_PHONEP_PHONEN_PRE_AMP_GAIN_CONTROL);
+	    // goto error_out;
+    // }
+
+    // mixer_ctls->phoneout_gain_control = mixer_get_ctl_by_name(mixer,
+		    // MIXER_PHONEOUT_GAIN_CONTROL);
+    // if (!mixer_ctls->phoneout_gain_control) {
+	    // ALOGE("Unable to find '%s' mixer control",MIXER_PHONEOUT_GAIN_CONTROL);
+	    // goto error_out;
+    // }
+
+    // mixer_ctls->phone_g_boost_stage_output_mixer_control = mixer_get_ctl_by_name(mixer,
+		    // MIXER_PHONE_G_BOOST_STAGE_OUTPUT_MIXER_CONTROL);
+    // if (!mixer_ctls->phone_g_boost_stage_output_mixer_control) {
+	    // ALOGE("Unable to find '%s' mixer control",MIXER_PHONE_G_BOOST_STAGE_OUTPUT_MIXER_CONTROL);
+	    // goto error_out;
+    // }
+
+    mixer_ctls->master_playback_volume = mixer_get_ctl_by_name(mixer,
+		    MIXER_MASTER_PLAYBACK_VOLUME);
+    if (!mixer_ctls->master_playback_volume) {
+	    ALOGE("Unable to find '%s' mixer control",MIXER_MASTER_PLAYBACK_VOLUME);
+	    goto error_out;
+    }
+
+    mixer_ctls->lineout_volume_control = mixer_get_ctl_by_name(mixer,
+		    MIXER_LINEOUT_VOLUME_CONTROL);
+    if (!mixer_ctls->lineout_volume_control) {
+	    ALOGE("Unable to find '%s' mixer control",MIXER_LINEOUT_VOLUME_CONTROL);
+	    goto error_out;
+    }
+
+    mixer_ctls->linein_g_boost_stage_output_mixer_control = mixer_get_ctl_by_name(mixer,
+		    MIXER_LINEIN_G_BOOST_STAGE_OUTPUT_MIXER_CONTROL);
+    if (!mixer_ctls->linein_g_boost_stage_output_mixer_control) {
+	    ALOGE("Unable to find '%s' mixer control",MIXER_LINEIN_G_BOOST_STAGE_OUTPUT_MIXER_CONTROL);
+	    goto error_out;
+    }
+
+    mixer_ctls->audio_phone_out = mixer_get_ctl_by_name(mixer,
+		    MIXER_AUDIO_PHONE_OUT);
+    if (!mixer_ctls->audio_phone_out) {
+	    ALOGE("Unable to find '%s' mixer control",MIXER_AUDIO_PHONE_OUT);
+	    goto error_out;
+    }
+    // mixer_ctls->audio_phone_in = mixer_get_ctl_by_name(mixer,
+		    // MIXER_AUDIO_PHONE_IN);
+    // if (!mixer_ctls->audio_phone_in) {
+	    // ALOGE("Unable to find '%s' mixer control",MIXER_AUDIO_PHONE_IN);
+	    // goto error_out;
+    // }
+
+    mixer_ctls->audio_earpiece_out = mixer_get_ctl_by_name(mixer,
+		    MIXER_AUDIO_EARPIECE_OUT);
+    if (!mixer_ctls->audio_earpiece_out) {
+	    ALOGE("Unable to find '%s' mixer control",MIXER_AUDIO_EARPIECE_OUT);
+	    goto error_out;
+    }
+    // mixer_ctls->audio_headphone_out = mixer_get_ctl_by_name(mixer,
+		    // MIXER_AUDIO_HEADPHONE_OUT);
+    // if (!mixer_ctls->audio_headphone_out) {
+	    // ALOGE("Unable to find '%s' mixer control",MIXER_AUDIO_HEADPHONE_OUT);
+	    // goto error_out;
+    // }
+    mixer_ctls->audio_speaker_out = mixer_get_ctl_by_name(mixer,
+		    MIXER_AUDIO_SPEAKER_OUT);
+    if (!mixer_ctls->audio_speaker_out) {
+	    ALOGE("Unable to find '%s' mixer control",MIXER_AUDIO_SPEAKER_OUT);
+	    goto error_out;
+    }
+
+    // mixer_ctls->audio_adc_phone_in= mixer_get_ctl_by_name(mixer,
+		    // MIXER_AUDIO_ADC_PHONE_IN);
+    // if (!mixer_ctls->audio_adc_phone_in) {
+	    // ALOGE("Unable to find '%s' mixer control", MIXER_AUDIO_ADC_PHONE_IN);
+	    // goto error_out;
+    // }
+    mixer_ctls->audio_dac_phone_out= mixer_get_ctl_by_name(mixer,
+		    MIXER_AUDIO_DAC_PHONE_OUT);
+    if (!mixer_ctls->audio_dac_phone_out) {
+	    ALOGE("Unable to find '%s' mixer control", MIXER_AUDIO_DAC_PHONE_OUT);
+	    goto error_out;
+    }
+
+    mixer_ctls->audio_phone_main_mic= mixer_get_ctl_by_name(mixer,
+		    MIXER_AUDIO_PHONE_MAIN_MIC);
+    if (!mixer_ctls->audio_phone_main_mic) {
+	    ALOGE("Unable to find '%s' mixer control", MIXER_AUDIO_PHONE_MAIN_MIC);
+	    goto error_out;
+    }
+
+    mixer_ctls->audio_phone_headset_mic= mixer_get_ctl_by_name(mixer,
+		    MIXER_AUDIO_PHONE_HEADSET_MIC);
+    if (!mixer_ctls->audio_phone_headset_mic) {
+	    ALOGE("Unable to find '%s' mixer control", MIXER_AUDIO_PHONE_HEADSET_MIC);
+	    goto error_out;
+    }
+
+    mixer_ctls->audio_phone_voice_record= mixer_get_ctl_by_name(mixer,
+		    MIXER_AUDIO_PHONE_VOICE_RECORDER);
+    if (!mixer_ctls->audio_phone_voice_record) {
+	    ALOGE("Unable to find '%s' mixer control", MIXER_AUDIO_PHONE_VOICE_RECORDER);
+	    goto error_out;
+    }
+
+    // mixer_ctls->audio_linein_in = mixer_get_ctl_by_name(mixer,
+		    // MIXER_AUDIO_LINEIN_IN);
+    // if (!mixer_ctls->audio_linein_in) {
+	    // ALOGE("Unable to find '%s' mixer control",MIXER_AUDIO_LINEIN_IN);
+	    // goto error_out;
+    // }
+/*
+    mixer_ctls->audio_fm_headset = mixer_get_ctl_by_name(mixer,
+		    MIXER_AUDIO_FM_HEADSET);
+    if (!mixer_ctls->audio_fm_headset) {
+	    ALOGE("Unable to find '%s' mixer control",MIXER_AUDIO_FM_HEADSET);
+	    goto error_out;
+    }
+
+    mixer_ctls->audio_fm_speaker = mixer_get_ctl_by_name(mixer,
+		    MIXER_AUDIO_FM_SPEAKER);
+    if (!mixer_ctls->audio_fm_speaker) {
+	    ALOGE("Unable to find '%s' mixer control",MIXER_AUDIO_FM_SPEAKER);
+	    goto error_out;
+    }
+
+    mixer_ctls->audio_spk_switch = mixer_get_ctl_by_name(mixer,
+		    MIXER_AUDIO_SPK_SWITCH);
+    if (!mixer_ctls->audio_spk_switch) {
+	    ALOGE("Unable to find '%s' mixer control",MIXER_AUDIO_SPK_SWITCH);
+	    goto error_out;
+    }
+*/
+    // mixer_ctls->audio_spk_headset_switch = mixer_get_ctl_by_name(mixer,
+		    // MIXER_AUDIO_NORMAL_SPEAKER_HEADSET);
+    // if (!mixer_ctls->audio_spk_headset_switch) {
+	    // ALOGE("Unable to find '%s' mixer control",MIXER_AUDIO_NORMAL_SPEAKER_HEADSET);
+	    // goto error_out;
+    // }
+
+    // mixer_ctls->audio_phone_end_call = mixer_get_ctl_by_name(mixer,MIXER_AUDIO_PHONE_ENDCALL);
+    // if (!mixer_ctls->audio_phone_end_call) {
+	    // ALOGE("Unable to find '%s' mixer control",MIXER_AUDIO_PHONE_ENDCALL);
+	    // goto error_out;
+    // }
+
+    // mixer_ctls->audio_fm_record = mixer_get_ctl_by_name(mixer,MIXER_AUDIO_FM_RECORD);
+    // if (!mixer_ctls->audio_fm_record) {
+	    // ALOGE("Unable to find '%s' mixer control",MIXER_AUDIO_FM_RECORD);
+	    // goto error_out;
+    // }
+
+    mixer_ctls->audio_mic1_gain = mixer_get_ctl_by_name(mixer,
+		    MIXER_AUDIO_MIC1_GAIN_CONTROL);
+    if (!mixer_ctls->audio_mic1_gain) {
+	    ALOGE("Unable to find '%s' mixer control", MIXER_AUDIO_MIC1_GAIN_CONTROL);
+	    goto error_out;
+    }
+
+    mixer_ctls->audio_mic2_gain = mixer_get_ctl_by_name(mixer,
+		    MIXER_AUDIO_MIC2_GAIN_CONTROL);
+    if (!mixer_ctls->audio_mic2_gain) {
+	    ALOGE("Unable to find '%s' mixer control", MIXER_AUDIO_MIC2_GAIN_CONTROL);
+	    goto error_out;
+    }
+
+    return 0;
+
+error_out:  
+    mixer_close(mixer);
+    return -1;
+}
+
+
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/codec_utils.h b/softwinner/common/hardware/audio/libcodec_audio/codec_utils.h
new file mode 100644
index 0000000..8d0cd05
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/codec_utils.h
@@ -0,0 +1,148 @@
+
+#ifndef __CODEC_UTILS_H__
+#define __CODEC_UTILS_H__
+
+#include "asoundlib.h"
+#include <pthread.h>
+#include <semaphore.h>
+
+typedef enum voice_type {
+    BT,
+    FM,
+    BT_FM,
+    CODEC,
+    BP,
+    BP_PCM,
+}voice_type_t;
+
+enum device_type {
+    CARD_UNKNOWN=-1,
+    CARD_CODEC=0,
+    CARD_PCM=1,
+    CARD_I2S=2,
+};
+
+typedef enum voice_direction {
+    DOWNSTREAM,
+    UPSTREAM,
+}voice_direction_t;
+
+extern char *audio_dev_name[3];
+ 
+
+typedef enum stream_direction_type {
+    SENDER, 
+    RECEIVER,
+}stream_direction_type_t;
+
+struct dev_stream{
+    voice_type_t type;
+    stream_direction_type_t direction;
+    struct pcm_config config;
+
+    struct pcm * dev;
+    char *buf;
+    unsigned int buf_size;
+};
+
+typedef void *(* voice_thread)(void *param);
+
+struct stream_transfer{
+    struct dev_stream *stream_sender;
+    struct dev_stream *stream_receiver;
+
+    voice_direction_t  voice_direction;
+    sem_t sem;
+    pthread_t pid;
+    voice_thread func;
+
+    volatile int manage_thread_run_flag;    //flag, 
+    volatile int voice_thread_run_flag;          //flag, 
+    volatile int voice_thread_exit_flag;          //flag, 
+    volatile int record_flag;          //flag, 
+};
+
+int init_stream(struct dev_stream *dev_stream);
+void close_stream(struct dev_stream *dev_stream);
+
+void ReduceVolume(char *buf, int size, int repeat);
+
+extern struct pcm_config bt_pcm_out_config;
+extern struct pcm_config bt_pcm_in_config ;
+extern struct pcm_config codec_out_config ;
+extern struct pcm_config codec_in_config ;
+
+
+
+/* Mixer control names */
+#define MIXER_MASTER_PLAYBACK_VOLUME   					"Master Playback Volume"
+#define MIXER_LINEIN_G_BOOST_STAGE_OUTPUT_MIXER_CONTROL	"LINEIN APM Volume"
+#define MIXER_LINEOUT_VOLUME_CONTROL					"Line output Volume"
+#define MIXER_PHONE_G_BOOST_STAGE_OUTPUT_MIXER_CONTROL	"PHONE_G boost stage output mixer control"
+#define MIXER_PHONEOUT_GAIN_CONTROL						"Phoneout gain control"
+#define MIXER_PHONEP_PHONEN_PRE_AMP_GAIN_CONTROL		"PHONEP-PHONEN pre-amp gain control"
+
+#define MIXER_AUDIO_MIC1_GAIN_CONTROL		"Mic1 gain Volume"
+#define MIXER_AUDIO_MIC2_GAIN_CONTROL		"Mic2 gain Volume"
+
+//#define MIXER_AUDIO_SPK_SWITCH                          "Audio Spk Switch"
+#define MIXER_AUDIO_PHONE_OUT             				"Audio phone out"
+#define MIXER_AUDIO_PHONE_IN             				"Audio phone in"
+#define MIXER_AUDIO_PHONE_RECORD             			"Audio phone record"
+#define MIXER_AUDIO_EARPIECE_OUT             			"Audio earpiece out"
+#define MIXER_AUDIO_HEADPHONE_OUT             			"Audio headphone out"
+#define MIXER_AUDIO_SPEAKER_OUT             			"Audio speaker out"
+#define MIXER_AUDIO_LINEIN_RECORD             			"Audio linein record"
+#define MIXER_AUDIO_LINEIN_IN             				"Audio linein in"
+
+#define MIXER_AUDIO_DAC_PHONE_OUT	"Audio dac phoneout"
+#define MIXER_AUDIO_ADC_PHONE_IN	"Audio adc phonein"
+#define MIXER_AUDIO_PHONE_MAIN_MIC 	"Audio phone phonemic"
+#define MIXER_AUDIO_PHONE_HEADSET_MIC 	"Audio phone headsetmic"
+#define MIXER_AUDIO_PHONE_VOICE_RECORDER 	"Audio phone capture"
+#define MIXER_AUDIO_FM_HEADSET             				"Audio fm headset"
+#define MIXER_AUDIO_FM_SPEAKER             				"Audio fm speaker"
+#define MIXER_AUDIO_NORMAL_SPEAKER_HEADSET    				"Speaker Function"
+
+#define MIXER_AUDIO_PHONE_ENDCALL 	"Audio phone endcall"
+#define MIXER_AUDIO_FM_RECORD	 	"Audio linein record"
+struct mixer_ctls
+{
+    struct mixer_ctl *master_playback_volume;		
+    struct mixer_ctl *linein_g_boost_stage_output_mixer_control;	
+    struct mixer_ctl *lineout_volume_control;	
+    struct mixer_ctl *phone_g_boost_stage_output_mixer_control;
+    struct mixer_ctl *phoneout_gain_control;	
+    struct mixer_ctl *phonep_phonen_pre_amp_gain_control;		
+    struct mixer_ctl *audio_spk_switch;
+    struct mixer_ctl *audio_phone_out;     
+    struct mixer_ctl *audio_phone_in ;     
+    struct mixer_ctl *audio_phone_record;  
+    struct mixer_ctl *audio_earpiece_out;   
+    struct mixer_ctl *audio_headphone_out;  
+    struct mixer_ctl *audio_speaker_out;   
+    struct mixer_ctl *audio_linein_record ;
+    struct mixer_ctl *audio_linein_in ;    
+    struct mixer_ctl *audio_fm_headset ;    
+    struct mixer_ctl *audio_fm_speaker ;    
+    struct mixer_ctl *audio_adc_phone_in;   
+    struct mixer_ctl *audio_dac_phone_out;   
+    struct mixer_ctl *audio_phone_main_mic;
+    struct mixer_ctl *audio_phone_headset_mic; 
+    struct mixer_ctl *audio_phone_voice_record; 
+    struct mixer_ctl *audio_phone_end_call; 
+    struct mixer_ctl *audio_fm_record; 
+    struct mixer_ctl *audio_spk_headset_switch;
+    struct mixer_ctl *audio_mic1_gain; 
+    struct mixer_ctl *audio_mic2_gain;
+};  
+
+int get_mixer(struct mixer_ctls *mixer_ctls);
+extern void c_plus_plus_grabPartialWakeLock();
+extern void c_plus_plus_releaseWakeLock();
+void grabPartialWakeLock();
+void releaseWakeLock();
+#endif
+
+
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/hal_codec.h b/softwinner/common/hardware/audio/libcodec_audio/hal_codec.h
new file mode 100644
index 0000000..354fb99
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/hal_codec.h
@@ -0,0 +1,87 @@
+
+#ifndef __HAL_CODEC_H__
+#define __HAL_CODEC_H__
+
+#include <stdbool.h>
+#include "codec_utils.h"
+
+struct codec_client {
+    struct mixer_ctls *mixer_ctls;
+    struct normal_ops *normal_ops;
+    struct fm_ops *fm_ops;
+    struct factory_ops *factory_ops;
+    struct phone_ops *phone_ops;
+    struct phone_common_record_ops *record_ops;
+    struct volume_array *vol_array;
+};
+
+
+struct normal_ops {
+    int (*set_normal_volume)(struct codec_client *client, int path, int vol);
+    int (*set_normal_path)(struct codec_client *client, int path);
+    int (*set_normal_record_enable)(struct codec_client *client, bool enable);
+    int (*set_normal_record)(struct codec_client *client, int path);
+};
+
+struct fm_ops {
+    int (*set_fm_volume)(struct codec_client *client, int path, int vol);
+    int (*set_fm_path)(struct codec_client *client, int path);
+    int (*set_fm_record_enable)(struct codec_client *client, bool enable);
+    int (*set_fm_record)(struct codec_client *client, int path);
+    int (*record_read_pcm_buf)(struct codec_client *client, void* buffer, int bytes);
+};
+
+struct factory_ops {
+    int (*set_factory_volume)(struct codec_client *client, int path, int vol);
+    int (*set_factory_path)(struct codec_client *client, int path);
+};
+
+struct phone_ops {
+    int (*set_phone_volume)(struct codec_client *client, int path, int vol);
+    int (*set_phone_path)(struct codec_client *client, int path);
+    int (*set_phone_record_enable)(struct codec_client *client, bool enable);
+    int (*set_phone_record)(struct codec_client *client, int path);
+    int (*record_read_pcm_buf)(struct codec_client *client, void* buffer, int bytes);
+};
+
+struct phone_common_record_ops {
+   int (*set_record_source)(bool is_record_from_adc);
+   int (*start_record)(int record_buf_size);
+   void (*stop_record)(void);
+   int (*init_record)(struct codec_client *client);
+   void (*exit_record)(void);
+};
+
+
+struct other_ops {
+    int (*other_op)(char *name);
+};
+
+struct volume_array{
+	int earpiece_phonepn_gain[6];
+	int earpiece_mixer_gain[6];
+	int earpiece_hp_gain[6];
+
+	int headset_phonepn_gain[6];
+	int headset_mixer_gain[6];
+	int headset_hp_gain[6];
+
+	int speaker_phonepn_gain[6];
+	int speaker_mixer_gain[6];
+	int speaker_spk_gain[6];
+
+	int fm_headset_line_gain[6];
+	int fm_headset_hp_gain[6];
+
+	int fm_speaker_line_gain[6];
+	int fm_speaker_spk_gain[6];
+
+	int up_pcm_gain;
+//	int fm_record_gain;
+};
+
+
+
+#endif
+
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/mixer.c b/softwinner/common/hardware/audio/libcodec_audio/mixer.c
new file mode 100644
index 0000000..ee4f3c4
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/mixer.c
@@ -0,0 +1,416 @@
+/* mixer.c
+**
+** Copyright 2011, The Android Open Source Project
+**
+** Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are met:
+**     * Redistributions of source code must retain the above copyright
+**       notice, this list of conditions and the following disclaimer.
+**     * Redistributions in binary form must reproduce the above copyright
+**       notice, this list of conditions and the following disclaimer in the
+**       documentation and/or other materials provided with the distribution.
+**     * Neither the name of The Android Open Source Project nor the names of
+**       its contributors may be used to endorse or promote products derived
+**       from this software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY The Android Open Source Project ``AS IS'' AND
+** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+** ARE DISCLAIMED. IN NO EVENT SHALL The Android Open Source Project BE LIABLE
+** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+** SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+** CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+** DAMAGE.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+
+#include <linux/ioctl.h>
+#define __force
+#define __bitwise
+#define __user
+#include <sound/asound.h>
+
+#include "asoundlib.h"
+
+struct mixer_ctl {
+    struct mixer *mixer;
+    struct snd_ctl_elem_info *info;
+    char **ename;
+};
+
+struct mixer {
+    int fd;
+    struct snd_ctl_elem_info *info;
+    struct mixer_ctl *ctl;
+    unsigned int count;
+};
+
+void mixer_close(struct mixer *mixer)
+{
+    unsigned int n,m;
+
+    if (!mixer)
+        return;
+
+    if (mixer->fd >= 0)
+        close(mixer->fd);
+
+    if (mixer->ctl) {
+        for (n = 0; n < mixer->count; n++) {
+            if (mixer->ctl[n].ename) {
+                unsigned int max = mixer->ctl[n].info->value.enumerated.items;
+                for (m = 0; m < max; m++)
+                    free(mixer->ctl[n].ename[m]);
+                free(mixer->ctl[n].ename);
+            }
+        }
+        free(mixer->ctl);
+    }
+
+    if (mixer->info)
+        free(mixer->info);
+
+    free(mixer);
+
+    /* TODO: verify frees */
+}
+
+struct mixer *mixer_open(unsigned int card)
+{
+    struct snd_ctl_elem_list elist;
+    struct snd_ctl_elem_info tmp;
+    struct snd_ctl_elem_id *eid = NULL;
+    struct mixer *mixer = NULL;
+    unsigned int n, m;
+    int fd;
+    char fn[256];
+
+    snprintf(fn, sizeof(fn), "/dev/snd/controlC%u", card);
+    fd = open(fn, O_RDWR);
+    if (fd < 0)
+        return 0;
+
+    memset(&elist, 0, sizeof(elist));
+    if (ioctl(fd, SNDRV_CTL_IOCTL_ELEM_LIST, &elist) < 0)
+        goto fail;
+
+    mixer = calloc(1, sizeof(*mixer));
+    if (!mixer)
+        goto fail;
+
+    mixer->ctl = calloc(elist.count, sizeof(struct mixer_ctl));
+    mixer->info = calloc(elist.count, sizeof(struct snd_ctl_elem_info));
+    if (!mixer->ctl || !mixer->info)
+        goto fail;
+
+    eid = calloc(elist.count, sizeof(struct snd_ctl_elem_id));
+    if (!eid)
+        goto fail;
+
+    mixer->count = elist.count;
+    mixer->fd = fd;
+    elist.space = mixer->count;
+    elist.pids = eid;
+    if (ioctl(fd, SNDRV_CTL_IOCTL_ELEM_LIST, &elist) < 0)
+        goto fail;
+
+    for (n = 0; n < mixer->count; n++) {
+        struct snd_ctl_elem_info *ei = mixer->info + n;
+        ei->id.numid = eid[n].numid;
+        if (ioctl(fd, SNDRV_CTL_IOCTL_ELEM_INFO, ei) < 0)
+            goto fail;
+        mixer->ctl[n].info = ei;
+        mixer->ctl[n].mixer = mixer;
+        if (ei->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
+            char **enames = calloc(ei->value.enumerated.items, sizeof(char*));
+            if (!enames)
+                goto fail;
+            mixer->ctl[n].ename = enames;
+            for (m = 0; m < ei->value.enumerated.items; m++) {
+                memset(&tmp, 0, sizeof(tmp));
+                tmp.id.numid = ei->id.numid;
+                tmp.value.enumerated.item = m;
+                if (ioctl(fd, SNDRV_CTL_IOCTL_ELEM_INFO, &tmp) < 0)
+                    goto fail;
+                enames[m] = strdup(tmp.value.enumerated.name);
+                if (!enames[m])
+                    goto fail;
+            }
+        }
+    }
+
+    free(eid);
+    return mixer;
+
+fail:
+    /* TODO: verify frees in failure case */
+    if (eid)
+        free(eid);
+    if (mixer)
+        mixer_close(mixer);
+    else if (fd >= 0)
+        close(fd);
+    return 0;
+}
+
+unsigned int mixer_get_num_ctls(struct mixer *mixer)
+{
+    if (!mixer)
+        return 0;
+
+    return mixer->count;
+}
+
+struct mixer_ctl *mixer_get_ctl(struct mixer *mixer, unsigned int id)
+{
+    if (mixer && (id < mixer->count))
+        return mixer->ctl + id;
+
+    return NULL;
+}
+
+struct mixer_ctl *mixer_get_ctl_by_name(struct mixer *mixer, const char *name)
+{
+    unsigned int n;
+
+    if (!mixer)
+        return NULL;
+
+    for (n = 0; n < mixer->count; n++)
+        if (!strcmp(name, (char*) mixer->info[n].id.name))
+            return mixer->ctl + n;
+
+    return NULL;
+}
+
+const char *mixer_ctl_get_name(struct mixer_ctl *ctl)
+{
+    if (!ctl)
+        return NULL;
+
+    return (const char *)ctl->info->id.name;
+}
+
+enum mixer_ctl_type mixer_ctl_get_type(struct mixer_ctl *ctl)
+{
+    if (!ctl)
+        return MIXER_CTL_TYPE_UNKNOWN;
+
+    switch (ctl->info->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:    return MIXER_CTL_TYPE_BOOL;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER:    return MIXER_CTL_TYPE_INT;
+    case SNDRV_CTL_ELEM_TYPE_ENUMERATED: return MIXER_CTL_TYPE_ENUM;
+    case SNDRV_CTL_ELEM_TYPE_BYTES:      return MIXER_CTL_TYPE_BYTE;
+    case SNDRV_CTL_ELEM_TYPE_IEC958:     return MIXER_CTL_TYPE_IEC958;
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64:  return MIXER_CTL_TYPE_INT64;
+    default:                             return MIXER_CTL_TYPE_UNKNOWN;
+    };
+}
+
+const char *mixer_ctl_get_type_string(struct mixer_ctl *ctl)
+{
+    if (!ctl)
+        return "";
+
+    switch (ctl->info->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:    return "BOOL";
+    case SNDRV_CTL_ELEM_TYPE_INTEGER:    return "INT";
+    case SNDRV_CTL_ELEM_TYPE_ENUMERATED: return "ENUM";
+    case SNDRV_CTL_ELEM_TYPE_BYTES:      return "BYTE";
+    case SNDRV_CTL_ELEM_TYPE_IEC958:     return "IEC958";
+    case SNDRV_CTL_ELEM_TYPE_INTEGER64:  return "INT64";
+    default:                             return "Unknown";
+    };
+}
+
+unsigned int mixer_ctl_get_num_values(struct mixer_ctl *ctl)
+{
+    if (!ctl)
+        return 0;
+
+    return ctl->info->count;
+}
+
+static int percent_to_int(struct snd_ctl_elem_info *ei, int percent)
+{
+    int range;
+
+    if (percent > 100)
+        percent = 100;
+    else if (percent < 0)
+        percent = 0;
+
+    range = (ei->value.integer.max - ei->value.integer.min);
+
+    return ei->value.integer.min + (range * percent) / 100;
+}
+
+static int int_to_percent(struct snd_ctl_elem_info *ei, int value)
+{
+    int range = (ei->value.integer.max - ei->value.integer.min);
+
+    if (range == 0)
+        return 0;
+
+    return ((value - ei->value.integer.min) / range) * 100;
+}
+
+int mixer_ctl_get_percent(struct mixer_ctl *ctl, unsigned int id)
+{
+    if (!ctl || (ctl->info->type != SNDRV_CTL_ELEM_TYPE_INTEGER))
+        return -EINVAL;
+
+    return int_to_percent(ctl->info, mixer_ctl_get_value(ctl, id));
+}
+
+int mixer_ctl_set_percent(struct mixer_ctl *ctl, unsigned int id, int percent)
+{
+    if (!ctl || (ctl->info->type != SNDRV_CTL_ELEM_TYPE_INTEGER))
+        return -EINVAL;
+
+    return mixer_ctl_set_value(ctl, id, percent_to_int(ctl->info, percent));
+}
+
+int mixer_ctl_get_value(struct mixer_ctl *ctl, unsigned int id)
+{
+    struct snd_ctl_elem_value ev;
+    int ret;
+
+    if (!ctl || (id >= ctl->info->count))
+        return -EINVAL;
+
+    memset(&ev, 0, sizeof(ev));
+    ev.id.numid = ctl->info->id.numid;
+    ret = ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_READ, &ev);
+    if (ret < 0)
+        return ret;
+
+    switch (ctl->info->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+        return !!ev.value.integer.value[id];
+
+    case SNDRV_CTL_ELEM_TYPE_INTEGER:
+        return ev.value.integer.value[id];
+
+    case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
+        return ev.value.enumerated.item[id];
+
+    case SNDRV_CTL_ELEM_TYPE_BYTES:
+        return ev.value.bytes.data[id];
+
+    default:
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+int mixer_ctl_set_value(struct mixer_ctl *ctl, unsigned int id, int value)
+{
+    struct snd_ctl_elem_value ev;
+    int ret;
+
+    if (!ctl || (id >= ctl->info->count))
+        return -EINVAL;
+
+    memset(&ev, 0, sizeof(ev));
+    ev.id.numid = ctl->info->id.numid;
+    ret = ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_READ, &ev);
+    if (ret < 0)
+        return ret;
+
+    switch (ctl->info->type) {
+    case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
+        ev.value.integer.value[id] = !!value;
+        break;
+
+    case SNDRV_CTL_ELEM_TYPE_INTEGER:
+        ev.value.integer.value[id] = value;
+        break;
+
+    case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
+        ev.value.enumerated.item[id] = value;
+        break;
+
+    default:
+        return -EINVAL;
+    }
+
+    return ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_WRITE, &ev);
+}
+
+int mixer_ctl_get_range_min(struct mixer_ctl *ctl)
+{
+    int ret;
+
+    if (!ctl || (ctl->info->type != SNDRV_CTL_ELEM_TYPE_INTEGER))
+        return -EINVAL;
+
+    return ctl->info->value.integer.min;
+}
+
+int mixer_ctl_get_range_max(struct mixer_ctl *ctl)
+{
+    int ret;
+
+    if (!ctl || (ctl->info->type != SNDRV_CTL_ELEM_TYPE_INTEGER))
+        return -EINVAL;
+
+    return ctl->info->value.integer.max;
+}
+
+unsigned int mixer_ctl_get_num_enums(struct mixer_ctl *ctl)
+{
+    if (!ctl)
+        return 0;
+
+    return ctl->info->value.enumerated.items;
+}
+
+const char *mixer_ctl_get_enum_string(struct mixer_ctl *ctl,
+                                      unsigned int enum_id)
+{
+    int ret;
+
+    if (!ctl || (ctl->info->type != SNDRV_CTL_ELEM_TYPE_ENUMERATED) ||
+        (enum_id >= ctl->info->value.enumerated.items))
+        return NULL;
+
+    return (const char *)ctl->ename[enum_id];
+}
+
+int mixer_ctl_set_enum_by_string(struct mixer_ctl *ctl, const char *string)
+{
+    unsigned int i, num_enums;
+    struct snd_ctl_elem_value ev;
+    int ret;
+
+    if (!ctl || (ctl->info->type != SNDRV_CTL_ELEM_TYPE_ENUMERATED))
+        return -EINVAL;
+
+    num_enums = ctl->info->value.enumerated.items;
+    for (i = 0; i < num_enums; i++) {
+        if (!strcmp(string, ctl->ename[i])) {
+            memset(&ev, 0, sizeof(ev));
+            ev.value.enumerated.item[0] = i;
+            ev.id.numid = ctl->info->id.numid;
+            ret = ioctl(ctl->mixer->fd, SNDRV_CTL_IOCTL_ELEM_WRITE, &ev);
+            if (ret < 0)
+                return ret;
+            return 0;
+        }
+    }
+
+    return -EINVAL;
+}
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/pcm.c b/softwinner/common/hardware/audio/libcodec_audio/pcm.c
new file mode 100644
index 0000000..aa51fb9
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/pcm.c
@@ -0,0 +1,791 @@
+/* pcm.c
+**
+** Copyright 2011, The Android Open Source Project
+**
+** Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are met:
+**     * Redistributions of source code must retain the above copyright
+**       notice, this list of conditions and the following disclaimer.
+**     * Redistributions in binary form must reproduce the above copyright
+**       notice, this list of conditions and the following disclaimer in the
+**       documentation and/or other materials provided with the distribution.
+**     * Neither the name of The Android Open Source Project nor the names of
+**       its contributors may be used to endorse or promote products derived
+**       from this software without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY The Android Open Source Project ``AS IS'' AND
+** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+** ARE DISCLAIMED. IN NO EVENT SHALL The Android Open Source Project BE LIABLE
+** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+** SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+** CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+** DAMAGE.
+*/
+
+#define LOG_TAG "codec_audio"
+#define LOG_NDEBUG 0
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <poll.h>
+
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+#include <limits.h>
+#include <utils/Log.h>
+
+#include <linux/ioctl.h>
+#define __force
+#define __bitwise
+#define __user
+#include <sound/asound.h>
+
+#include "asoundlib.h"
+
+#define PARAM_MAX SNDRV_PCM_HW_PARAM_LAST_INTERVAL
+#define SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP (1<<2)
+
+static inline int param_is_mask(int p)
+{
+    return (p >= SNDRV_PCM_HW_PARAM_FIRST_MASK) &&
+        (p <= SNDRV_PCM_HW_PARAM_LAST_MASK);
+}
+
+static inline int param_is_interval(int p)
+{
+    return (p >= SNDRV_PCM_HW_PARAM_FIRST_INTERVAL) &&
+        (p <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL);
+}
+
+static inline struct snd_interval *param_to_interval(struct snd_pcm_hw_params *p, int n)
+{
+    return &(p->intervals[n - SNDRV_PCM_HW_PARAM_FIRST_INTERVAL]);
+}
+
+static inline struct snd_mask *param_to_mask(struct snd_pcm_hw_params *p, int n)
+{
+    return &(p->masks[n - SNDRV_PCM_HW_PARAM_FIRST_MASK]);
+}
+
+static void param_set_mask(struct snd_pcm_hw_params *p, int n, unsigned int bit)
+{
+    if (bit >= SNDRV_MASK_MAX)
+        return;
+    if (param_is_mask(n)) {
+        struct snd_mask *m = param_to_mask(p, n);
+        m->bits[0] = 0;
+        m->bits[1] = 0;
+        m->bits[bit >> 5] |= (1 << (bit & 31));
+    }
+}
+
+static void param_set_min(struct snd_pcm_hw_params *p, int n, unsigned int val)
+{
+    if (param_is_interval(n)) {
+        struct snd_interval *i = param_to_interval(p, n);
+        i->min = val;
+    }
+}
+
+static void param_set_int(struct snd_pcm_hw_params *p, int n, unsigned int val)
+{
+    if (param_is_interval(n)) {
+        struct snd_interval *i = param_to_interval(p, n);
+        i->min = val;
+        i->max = val;
+        i->integer = 1;
+    }
+}
+
+static unsigned int param_get_int(struct snd_pcm_hw_params *p, int n)
+{
+    if (param_is_interval(n)) {
+        struct snd_interval *i = param_to_interval(p, n);
+        if (i->integer)
+            return i->max;
+    }
+    return 0;
+}
+
+static void param_init(struct snd_pcm_hw_params *p)
+{
+    int n;
+
+    memset(p, 0, sizeof(*p));
+    for (n = SNDRV_PCM_HW_PARAM_FIRST_MASK;
+         n <= SNDRV_PCM_HW_PARAM_LAST_MASK; n++) {
+            struct snd_mask *m = param_to_mask(p, n);
+            m->bits[0] = ~0;
+            m->bits[1] = ~0;
+    }
+    for (n = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL;
+         n <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; n++) {
+            struct snd_interval *i = param_to_interval(p, n);
+            i->min = 0;
+            i->max = ~0;
+    }
+}
+
+
+
+
+unsigned int pcm_get_buffer_size(struct pcm *pcm)
+{
+    return pcm->buffer_size;
+}
+
+const char* pcm_get_error(struct pcm *pcm)
+{
+    return pcm->error;
+}
+
+static int _oops(struct pcm *pcm, int e, const char *fmt, ...)
+{
+    va_list ap;
+    int sz;
+
+    va_start(ap, fmt);
+    vsnprintf(pcm->error, PCM_ERROR_MAX, fmt, ap);
+    va_end(ap);
+    sz = strlen(pcm->error);
+
+    if (errno)
+        snprintf(pcm->error + sz, PCM_ERROR_MAX - sz,
+                 ": %s", strerror(e));
+    return -1;
+}
+
+#define oops(_pcm,e,fmt,...) _oops(_pcm,e,"%s(%d) " fmt, __func__,__LINE__,##__VA_ARGS__)
+
+static unsigned int pcm_format_to_alsa(enum pcm_format format)
+{
+    switch (format) {
+    case PCM_FORMAT_S32_LE:
+        return SNDRV_PCM_FORMAT_S32_LE;
+    default:
+    case PCM_FORMAT_S16_LE:
+        return SNDRV_PCM_FORMAT_S16_LE;
+    };
+}
+
+static unsigned int pcm_format_to_bits(enum pcm_format format)
+{
+    switch (format) {
+    case PCM_FORMAT_S32_LE:
+        return 32;
+    default:
+    case PCM_FORMAT_S16_LE:
+        return 16;
+    };
+}
+
+unsigned int pcm_bytes_to_frames(struct pcm *pcm, unsigned int bytes)
+{
+    return bytes / (pcm->config.channels *
+        (pcm_format_to_bits(pcm->config.format) >> 3));
+}
+
+unsigned int pcm_frames_to_bytes(struct pcm *pcm, unsigned int frames)
+{
+    return frames * pcm->config.channels *
+        (pcm_format_to_bits(pcm->config.format) >> 3);
+}
+
+static int pcm_sync_ptr(struct pcm *pcm, int flags) {
+    if (pcm->sync_ptr) {
+        pcm->sync_ptr->flags = flags;
+        if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_SYNC_PTR, pcm->sync_ptr) < 0)
+            return -1;
+    }
+    return 0;
+}
+
+static int pcm_hw_mmap_status(struct pcm *pcm) {
+
+    if (pcm->sync_ptr)
+        return 0;
+
+    int page_size = sysconf(_SC_PAGE_SIZE);
+    pcm->mmap_status = mmap(NULL, page_size, PROT_READ, MAP_FILE | MAP_SHARED,
+                            pcm->fd, SNDRV_PCM_MMAP_OFFSET_STATUS);
+    if (pcm->mmap_status == MAP_FAILED)
+        pcm->mmap_status = NULL;
+    if (!pcm->mmap_status)
+        goto mmap_error;
+
+    pcm->mmap_control = mmap(NULL, page_size, PROT_READ | PROT_WRITE,
+                             MAP_FILE | MAP_SHARED, pcm->fd, SNDRV_PCM_MMAP_OFFSET_CONTROL);
+    if (pcm->mmap_control == MAP_FAILED)
+        pcm->mmap_control = NULL;
+    if (!pcm->mmap_control) {
+        munmap(pcm->mmap_status, page_size);
+        pcm->mmap_status = NULL;
+        goto mmap_error;
+    }
+    if (pcm->flags & PCM_MMAP)
+        pcm->mmap_control->avail_min = pcm->config.avail_min;
+    else
+        pcm->mmap_control->avail_min = 1;
+
+    return 0;
+
+mmap_error:
+
+    pcm->sync_ptr = calloc(1, sizeof(*pcm->sync_ptr));
+    if (!pcm->sync_ptr)
+        return -ENOMEM;
+    pcm->mmap_status = &pcm->sync_ptr->s.status;
+    pcm->mmap_control = &pcm->sync_ptr->c.control;
+    if (pcm->flags & PCM_MMAP)
+        pcm->mmap_control->avail_min = pcm->config.avail_min;
+    else
+        pcm->mmap_control->avail_min = 1;
+
+    pcm_sync_ptr(pcm, 0);
+
+    return 0;
+}
+
+static void pcm_hw_munmap_status(struct pcm *pcm) {
+    if (pcm->sync_ptr) {
+        free(pcm->sync_ptr);
+        pcm->sync_ptr = NULL;
+    } else {
+        int page_size = sysconf(_SC_PAGE_SIZE);
+        if (pcm->mmap_status)
+            munmap(pcm->mmap_status, page_size);
+        if (pcm->mmap_control)
+            munmap(pcm->mmap_control, page_size);
+    }
+    pcm->mmap_status = NULL;
+    pcm->mmap_control = NULL;
+}
+
+int pcm_get_htimestamp(struct pcm *pcm, unsigned int *avail,
+                       struct timespec *tstamp)
+{
+    int frames;
+    int rc;
+    snd_pcm_uframes_t hw_ptr;
+
+    if (!pcm_is_ready(pcm))
+        return -1;
+
+    rc = pcm_sync_ptr(pcm, SNDRV_PCM_SYNC_PTR_APPL|SNDRV_PCM_SYNC_PTR_HWSYNC);
+    if (rc < 0)
+        return -1;
+
+    if ((pcm->mmap_status->state != PCM_STATE_RUNNING) &&
+            (pcm->mmap_status->state != PCM_STATE_DRAINING))
+        return -1;
+
+    *tstamp = pcm->mmap_status->tstamp;
+    if (tstamp->tv_sec == 0 && tstamp->tv_nsec == 0)
+        return -1;
+
+    hw_ptr = pcm->mmap_status->hw_ptr;
+    if (pcm->flags & PCM_IN)
+        frames = hw_ptr - pcm->mmap_control->appl_ptr;
+    else
+        frames = hw_ptr + pcm->buffer_size - pcm->mmap_control->appl_ptr;
+
+    if (frames < 0)
+        frames += pcm->boundary;
+    else if (frames > (int)pcm->boundary)
+        frames -= pcm->boundary;
+
+    *avail = (unsigned int)frames;
+
+    return 0;
+}
+
+int pcm_write(struct pcm *pcm, void *data, unsigned int count)
+{
+    struct snd_xferi x;
+
+    if (pcm->flags & PCM_IN)
+        return -EINVAL;
+
+    x.buf = data;
+    x.frames = count / (pcm->config.channels *
+                        pcm_format_to_bits(pcm->config.format) / 8);
+
+    for (;;) {
+        if (!pcm->running) {
+            if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_PREPARE))
+                return oops(pcm, errno, "cannot prepare channel");
+            if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_WRITEI_FRAMES, &x))
+                return oops(pcm, errno, "cannot write initial data");
+            pcm->running = 1;
+            return 0;
+        }
+        if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_WRITEI_FRAMES, &x)) {
+            pcm->running = 0;
+            if (errno == EPIPE) {
+                /* we failed to make our window -- try to restart */
+                pcm->underruns++;
+                continue;
+            }
+            return oops(pcm, errno, "cannot write stream data");
+        }
+        return 0;
+    }
+}
+
+int pcm_read(struct pcm *pcm, void *data, unsigned int count)
+{
+    struct snd_xferi x;
+
+    if (!(pcm->flags & PCM_IN))
+        return -EINVAL;
+
+    x.buf = data;
+    x.frames = count / (pcm->config.channels *
+                        pcm_format_to_bits(pcm->config.format) / 8);
+
+    for (;;) {
+        if (!pcm->running) {
+            if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_PREPARE))
+                return oops(pcm, errno, "cannot prepare channel");
+            if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_START))
+                return oops(pcm, errno, "cannot start channel");
+            pcm->running = 1;
+        }
+        if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_READI_FRAMES, &x)) {
+            pcm->running = 0;
+            if (errno == EPIPE) {
+                /* we failed to make our window -- try to restart */
+                pcm->underruns++;
+                continue;
+            }
+            return oops(pcm, errno, "cannot read stream data");
+        }
+        return 0;
+    }
+}
+
+static struct pcm bad_pcm = {
+    .fd = -1,
+};
+
+int pcm_close(struct pcm *pcm)
+{
+    if (pcm == &bad_pcm)
+        return 0;
+
+    pcm_hw_munmap_status(pcm);
+
+    if (pcm->flags & PCM_MMAP) {
+        pcm_stop(pcm);
+        munmap(pcm->mmap_buffer, pcm_frames_to_bytes(pcm, pcm->buffer_size));
+    }
+
+    if (pcm->fd >= 0)
+        close(pcm->fd);
+    pcm->running = 0;
+    pcm->buffer_size = 0;
+    pcm->fd = -1;
+    free(pcm);
+    return 0;
+}
+
+int get_pcm_state(struct pcm *pcm)
+{
+    struct snd_pcm_status status;
+
+    if (pcm == &bad_pcm)
+        return 0;
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_STATUS, &status) < 0)
+        return oops(pcm, errno, "cannot  pcm_state");
+
+    return status.state;
+}
+
+struct pcm *pcm_open(unsigned int card, unsigned int device,
+                     unsigned int flags, struct pcm_config *config)
+{
+    struct pcm *pcm;
+    struct snd_pcm_info info;
+    struct snd_pcm_hw_params params;
+    struct snd_pcm_sw_params sparams;
+    char fn[256];
+    int rc;
+
+    pcm = calloc(1, sizeof(struct pcm));
+    if (!pcm || !config)
+        return &bad_pcm; /* TODO: could support default config here */
+
+    pcm->config = *config;
+
+    snprintf(fn, sizeof(fn), "/dev/snd/pcmC%uD%u%c", card, device,
+             flags & PCM_IN ? 'c' : 'p');
+
+    pcm->flags = flags;
+    pcm->fd = open(fn, O_RDWR);
+    if (pcm->fd < 0) {
+        oops(pcm, errno, "cannot open device '%s'", fn);
+        return pcm;
+    }
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_INFO, &info)) {
+        oops(pcm, errno, "cannot get info");
+        goto fail_close;
+    }
+
+    param_init(&params);
+    param_set_mask(&params, SNDRV_PCM_HW_PARAM_FORMAT,
+                   pcm_format_to_alsa(config->format));
+    param_set_mask(&params, SNDRV_PCM_HW_PARAM_SUBFORMAT,
+                   SNDRV_PCM_SUBFORMAT_STD);
+    param_set_min(&params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, config->period_size);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS,
+                  pcm_format_to_bits(config->format));
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_FRAME_BITS,
+                  pcm_format_to_bits(config->format) * config->channels);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_CHANNELS,
+                  config->channels);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_PERIODS, config->period_count);
+    param_set_int(&params, SNDRV_PCM_HW_PARAM_RATE, config->rate);
+
+    if (flags & PCM_NOIRQ) {
+
+        if (!(flags & PCM_MMAP)) {
+            oops(pcm, -EINVAL, "noirq only currently supported with mmap().");
+            goto fail;
+        }
+
+        params.flags |= SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP;
+        pcm->noirq_frames_per_msec = config->rate / 1000;
+    }
+
+    if (flags & PCM_MMAP)
+        param_set_mask(&params, SNDRV_PCM_HW_PARAM_ACCESS,
+                   SNDRV_PCM_ACCESS_MMAP_INTERLEAVED);
+    else
+        param_set_mask(&params, SNDRV_PCM_HW_PARAM_ACCESS,
+                   SNDRV_PCM_ACCESS_RW_INTERLEAVED);
+
+
+    ALOGV("pcm %s hw_params",fn);
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_HW_PARAMS, &params)) {
+        oops(pcm, errno, "cannot set hw params");
+        goto fail_close;
+    }
+
+    /* get our refined hw_params */
+    config->period_size = param_get_int(&params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+    config->period_count = param_get_int(&params, SNDRV_PCM_HW_PARAM_PERIODS);
+    pcm->buffer_size = config->period_count * config->period_size;
+
+    if (flags & PCM_MMAP) {
+        pcm->mmap_buffer = mmap(NULL, pcm_frames_to_bytes(pcm, pcm->buffer_size),
+                                PROT_READ | PROT_WRITE, MAP_FILE | MAP_SHARED, pcm->fd, 0);
+        if (pcm->mmap_buffer == MAP_FAILED) {
+            oops(pcm, -errno, "failed to mmap buffer %d bytes\n",
+                 pcm_frames_to_bytes(pcm, pcm->buffer_size));
+            goto fail_close;
+        }
+    }
+
+
+    memset(&sparams, 0, sizeof(sparams));
+    sparams.tstamp_mode = SNDRV_PCM_TSTAMP_ENABLE;
+    sparams.period_step = 1;
+
+    if (!config->start_threshold)
+        pcm->config.start_threshold = sparams.start_threshold =
+            config->period_count * config->period_size / 2;
+    else
+        sparams.start_threshold = config->start_threshold;
+
+    /* pick a high stop threshold - todo: does this need further tuning */
+    if (!config->stop_threshold)
+        pcm->config.stop_threshold = sparams.stop_threshold =
+            config->period_count * config->period_size;
+    else
+        sparams.stop_threshold = config->stop_threshold;
+
+    if (!pcm->config.avail_min) {
+        if (pcm->flags & PCM_MMAP)
+            pcm->config.avail_min = sparams.avail_min = pcm->config.period_size;
+        else
+            pcm->config.avail_min = sparams.avail_min = 1;
+    } else
+        sparams.avail_min = config->avail_min;
+
+    sparams.xfer_align = config->period_size / 2; /* needed for old kernels */
+    sparams.silence_size = 0;
+    sparams.silence_threshold = config->silence_threshold;
+    pcm->boundary = sparams.boundary = pcm->buffer_size;
+
+    while (pcm->boundary * 2 <= LONG_MAX - pcm->buffer_size)
+		pcm->boundary *= 2;
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_SW_PARAMS, &sparams)) {
+        oops(pcm, errno, "cannot set sw params");
+        goto fail;
+    }
+
+    rc = pcm_hw_mmap_status(pcm);
+    if (rc < 0) {
+        oops(pcm, rc, "mmap status failed");
+        goto fail;
+    }
+
+    pcm->underruns = 0;
+    return pcm;
+
+fail:
+    if (flags & PCM_MMAP)
+        munmap(pcm->mmap_buffer, pcm_frames_to_bytes(pcm, pcm->buffer_size));
+fail_close:
+    close(pcm->fd);
+    pcm->fd = -1;
+    return pcm;
+}
+
+int pcm_is_ready(struct pcm *pcm)
+{
+    return pcm->fd >= 0;
+}
+
+int pcm_start(struct pcm *pcm)
+{
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_PREPARE) < 0)
+        return oops(pcm, errno, "cannot prepare channel");
+
+    if (pcm->flags & PCM_MMAP)
+	    pcm_sync_ptr(pcm, 0);
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_START) < 0)
+        return oops(pcm, errno, "cannot start channel");
+
+    pcm->running = 1;
+    return 0;
+}
+
+int pcm_stop(struct pcm *pcm)
+{
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_DROP) < 0)
+        return oops(pcm, errno, "cannot stop channel");
+
+    pcm->running = 0;
+    return 0;
+}
+
+static inline int pcm_mmap_playback_avail(struct pcm *pcm)
+{
+    int avail;
+
+    avail = pcm->mmap_status->hw_ptr + pcm->buffer_size - pcm->mmap_control->appl_ptr;
+
+    if (avail < 0)
+        avail += pcm->boundary;
+    else if (avail > (int)pcm->boundary)
+        avail -= pcm->boundary;
+
+    return avail;
+}
+
+static inline int pcm_mmap_capture_avail(struct pcm *pcm)
+{
+    int avail = pcm->mmap_status->hw_ptr - pcm->mmap_control->appl_ptr;
+    if (avail < 0)
+        avail += pcm->boundary;
+    return avail;
+}
+
+static inline int pcm_mmap_avail(struct pcm *pcm)
+{
+    pcm_sync_ptr(pcm, SNDRV_PCM_SYNC_PTR_HWSYNC);
+    if (pcm->flags & PCM_IN)
+        return pcm_mmap_capture_avail(pcm);
+    else
+        return pcm_mmap_playback_avail(pcm);
+}
+
+static void pcm_mmap_appl_forward(struct pcm *pcm, int frames)
+{
+    unsigned int appl_ptr = pcm->mmap_control->appl_ptr;
+    appl_ptr += frames;
+
+    /* check for boundary wrap */
+    if (appl_ptr > pcm->boundary)
+         appl_ptr -= pcm->boundary;
+    pcm->mmap_control->appl_ptr = appl_ptr;
+}
+
+int pcm_mmap_begin(struct pcm *pcm, void **areas, unsigned int *offset,
+                   unsigned int *frames)
+{
+    unsigned int continuous, copy_frames, avail;
+
+    /* return the mmap buffer */
+    *areas = pcm->mmap_buffer;
+
+    /* and the application offset in frames */
+    *offset = pcm->mmap_control->appl_ptr % pcm->buffer_size;
+
+    avail = pcm_mmap_avail(pcm);
+    if (avail > pcm->buffer_size)
+        avail = pcm->buffer_size;
+    continuous = pcm->buffer_size - *offset;
+
+    /* we can only copy frames if the are availabale and continuos */
+    copy_frames = *frames;
+    if (copy_frames > avail)
+        copy_frames = avail;
+    if (copy_frames > continuous)
+        copy_frames = continuous;
+    *frames = copy_frames;
+
+    return 0;
+}
+
+int pcm_mmap_commit(struct pcm *pcm, unsigned int offset, unsigned int frames)
+{
+    /* update the application pointer in userspace and kernel */
+    pcm_mmap_appl_forward(pcm, frames);
+    pcm_sync_ptr(pcm, 0);
+
+    return frames;
+}
+
+int pcm_avail_update(struct pcm *pcm)
+{
+    pcm_sync_ptr(pcm, 0);
+    return pcm_mmap_avail(pcm);
+}
+
+int pcm_state(struct pcm *pcm)
+{
+    int err = pcm_sync_ptr(pcm, 0);
+    if (err < 0)
+        return err;
+
+    return pcm->mmap_status->state;
+}
+
+int pcm_set_avail_min(struct pcm *pcm, int avail_min)
+{
+    if ((~pcm->flags) & (PCM_MMAP | PCM_NOIRQ))
+        return -ENOSYS;
+
+    pcm->config.avail_min = avail_min;
+    return 0;
+}
+
+int pcm_wait(struct pcm *pcm, int timeout)
+{
+    struct pollfd pfd;
+    int err;
+
+    pfd.fd = pcm->fd;
+    pfd.events = POLLIN | POLLOUT | POLLERR | POLLNVAL;
+
+    do {
+        /* let's wait for avail or timeout */
+        err = poll(&pfd, 1, timeout);
+        if (err < 0)
+            return -errno;
+
+        /* timeout ? */
+        if (err == 0)
+            return 0;
+
+        /* have we been interrupted ? */
+        if (errno == -EINTR)
+            continue;
+
+        /* check for any errors */
+        if (pfd.revents & (POLLERR | POLLNVAL)) {
+            switch (get_pcm_state(pcm)) {
+            case PCM_STATE_XRUN:
+                return -EPIPE;
+            case PCM_STATE_SUSPENDED:
+                return -ESTRPIPE;
+            case PCM_STATE_DISCONNECTED:
+                return -ENODEV;
+            default:
+		continue;
+//                return -EIO;
+            }
+        }
+    /* poll again if fd not ready for IO */
+    } while (!(pfd.revents & (POLLIN | POLLOUT)));
+
+    return 1;
+}
+
+
+/*  */
+int pcm_get_node_number(char *name)
+{
+	char card[32];
+	char id[32];
+	int i = 0;
+	int j = 0;
+	int fd = 0;
+	int ret = 0;
+
+	for(i = 0; i < 10; i++){
+		memset(card, 0, 32);
+		memset(id, 0, 32);
+
+		/* "/sys/class/sound/cardx" */
+		sprintf(card, "/sys/class/sound/card%d", i);
+		ret = access(card, F_OK);
+		if(ret != 0){
+			continue;
+		}
+
+		/* "/sys/class/sound/cardx/id" */
+		strcat(card, "/id");
+		ret = access(card, F_OK);
+		if(ret != 0){
+			continue;
+		}
+
+		/* compare */
+		fd = open(card, O_RDONLY);
+		if(fd < 0){
+			continue;
+		}
+
+		ret = read(fd, id, 32);
+		if(ret < 0){
+			close(fd);
+			continue;
+		}
+
+		/*  */
+		for(j = 0; j < 32; j++){
+			if(id[j] == 0x0a){
+		            id[j] = 0;
+			}
+		}
+
+		if(!strcmp(id, name)){
+			close(fd);
+			return i;
+		}
+
+		close(fd);
+	}
+	return -1;
+}
+
+
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/record.c b/softwinner/common/hardware/audio/libcodec_audio/record.c
new file mode 100644
index 0000000..8ba17f2
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/record.c
@@ -0,0 +1,300 @@
+
+
+#define LOG_TAG "codec_audio_plan_record"
+#define LOG_NDEBUG 0
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <errno.h>
+
+#include <utils/Log.h>
+
+#include "codec_utils.h"
+#include "record.h"
+#include "hal_codec.h"
+#include "wav.h"
+
+struct record_private{
+	volatile bool manage_thread_run_flag;
+	volatile bool record_thread_run_flag;
+	volatile bool is_record_from_adc;
+	volatile bool is_record_exit;
+	volatile bool is_adc_stream_opened;
+	struct dev_stream record_stream;
+	struct codec_client *client;
+	char *buf;
+	int buf_size;
+	sem_t sem;
+
+
+};
+static struct record_private g_record;
+
+
+static void *record_data(void *param);
+static void *record_manage_thread(void *param);
+static int create_record_manage();
+
+struct phone_common_record_ops phone_common_record_ops ={
+	.set_record_source = set_record_source,
+	.init_record = init_record,
+	.exit_record = exit_record,
+	.start_record = start_record,
+	.stop_record = stop_record,
+};
+
+int set_record_source(bool is_record_from_adc)
+{
+
+	if(g_record.is_record_from_adc == is_record_from_adc ){
+		return 0;
+	}
+
+	g_record.is_record_from_adc = is_record_from_adc;
+
+	if(is_record_from_adc == true){
+		g_record.record_stream.type = CODEC;
+		g_record.record_stream.config= codec_in_config; 
+		g_record.record_stream.direction = SENDER;
+	} else {
+		if(g_record.record_stream.dev){
+			pcm_stop(g_record.record_stream.dev);
+			ALOGD("pcm_stop record_stream");
+		}
+	}
+
+	ALOGD("set_record_source is_record_from_adc=%d", g_record.is_record_from_adc);
+
+	return 0;
+}
+
+int start_record(int record_buf_size)
+{
+	if(record_buf_size != 0){
+		g_record.buf = (char *)malloc(record_buf_size);
+		if (g_record.buf  == NULL ){
+			ALOGD(" fail to malloc record_buf size=%d", record_buf_size);
+			return -1;
+		}
+		g_record.buf_size = record_buf_size;
+	}
+
+	g_record.record_thread_run_flag = 1;
+
+/*	g_record.is_record_from_adc = is_record_from_adc;
+
+	if(is_record_from_adc == true){
+		g_record.record_stream.type = CODEC;
+		g_record.record_stream.config= codec_in_config; 
+		g_record.record_stream.direction = SENDER;
+	}
+*/
+	g_record.is_adc_stream_opened = false;
+
+	ALOGD("start_record record_thread_run_flag=%d, is_record_from_adc=%d", g_record.record_thread_run_flag, g_record.is_record_from_adc);
+
+	g_record.is_record_exit =0;
+
+	sem_post(&g_record.sem);
+	return 0;
+}
+
+void stop_record(void)
+{
+	g_record.record_thread_run_flag = 0;
+
+
+	if(g_record.is_record_from_adc == true){
+		pcm_stop(g_record.record_stream.dev);
+	}
+
+	while(!g_record.is_record_exit){
+		ALOGD("wait record exit flag");
+		usleep(10000);
+	}
+	if(g_record.buf){
+		free(g_record.buf);
+	}
+	g_record.buf_size = 0;
+
+	if(g_record.is_record_from_adc == true){
+		memset(&(g_record.record_stream), 0, sizeof(struct dev_stream));
+	}
+
+	g_record.is_record_from_adc = false;
+	g_record.is_adc_stream_opened = false;
+
+	ALOGD("stop_record record_thread_run_flag=%d, is_record_from_adc=%d", g_record.record_thread_run_flag, g_record.is_record_from_adc);
+}
+
+int init_record(struct codec_client *client)
+{
+	int ret;
+
+	memset(&(g_record), 0, sizeof(struct record_private));
+
+	ret = sem_init(&g_record.sem, 0, 0);
+	if (ret) {
+		ALOGE("err: record sem failed, ret=%d\n", ret);
+		return -1;
+	}
+
+	g_record.manage_thread_run_flag = 1;
+
+	g_record.client = client;
+
+	ret = create_record_manage();
+	if (ret <0 ){
+		g_record.manage_thread_run_flag = 0;
+		ALOGE("err: create record_manager, ret=%d\n", ret);
+		return -1;
+	}
+
+	return 0;
+}
+
+void exit_record()
+{
+	g_record.record_thread_run_flag = 0;
+	g_record.manage_thread_run_flag = 0;
+
+	sem_post(&g_record.sem);
+	sem_destroy(&g_record.sem);
+	memset(&(g_record), 0, sizeof(struct record_private));
+}
+
+
+static int create_record_manage()
+{
+	int ret;
+	pthread_attr_t attr;
+	pthread_t thread_id;
+
+	ret = pthread_attr_init (&attr);
+	if (ret != 0) {
+		ALOGE("err: pthread_attr_init failed err=%s", strerror(ret));
+		goto failed;
+	}
+
+	ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+	if (ret != 0) {
+		ALOGE("err: pthread_attr_setdetachstate failed err=%s", strerror(ret));
+		goto failed;
+	}
+
+	ret = pthread_create(&thread_id, &attr, record_manage_thread, &g_record);
+	if (ret) {
+		ALOGE("err: pthread_create failed, ret=%d\n", ret);
+		goto failed;
+	}
+	return 0;
+failed:
+	return -1;
+}
+
+
+static volatile long int g_total_size = 0;
+
+static void *record_manage_thread(void *param)
+{
+	int ret = 0;
+	struct record_private *record = (struct record_private*)param;
+
+
+	while(record->manage_thread_run_flag){
+
+		ALOGV("record manager thread sleep\n");
+		sem_wait(&(record->sem));
+		ALOGV("record manager thread wakeup\n");
+
+		if(record->record_thread_run_flag){
+
+			g_record.is_record_exit = 0;
+			g_total_size = 0 ;
+
+			wav_start();
+
+    			ALOGD("record thread start");
+			record_data(param);
+
+			ALOGD("record thread end, g_total_size %ld" ,g_total_size);
+			wav_end(g_total_size);
+
+			if(g_record.is_adc_stream_opened == true ){
+				close_stream(&(record->record_stream));
+				g_record.is_adc_stream_opened = false;
+				ALOGV("close_stream  record");
+			}
+
+			g_record.is_record_exit = 1;
+
+
+		}
+	}
+
+    ALOGD("record manager thread exit\n");
+	return param;
+}
+
+
+
+//phone record except bt 
+static void *record_data(void *param)
+{
+	int ret = 0;
+	int exit_flag   =0;
+	char *tmp_buf;
+	int  data_count;
+	struct record_private *record = (struct record_private*)param;
+
+	while(1){
+		if( g_record.is_record_from_adc == true ){
+			if(g_record.is_adc_stream_opened == false){
+				if( (ret = init_stream(&(record->record_stream)) ) < 0 ){
+					ALOGE("err: init_stream  record_stream failed, ret=%d, ****LINE:%d,FUNC:%s", ret, __LINE__, __FUNCTION__);
+					g_record.is_record_exit = 1;
+					exit_flag = 1;
+					//return NULL;
+				}
+				g_record.is_adc_stream_opened = true;
+			}
+
+			ret = pcm_read(record->record_stream.dev, record->record_stream.buf, record->record_stream.buf_size);
+			if (ret != 0) {
+				exit_flag = 1;
+				ALOGE("err: record_data:%s, ret=%d", strerror(errno), ret);
+				//break;
+			}
+			tmp_buf = record->record_stream.buf;
+			data_count = record->record_stream.buf_size;
+		} else {
+			if(g_record.is_adc_stream_opened == true ){
+				close_stream(&(record->record_stream));
+				g_record.is_adc_stream_opened = false;
+				ALOGV("close_stream  record");
+			}
+
+		        ALOGD("record_data");
+			ret = record->client->phone_ops->record_read_pcm_buf(record->client, record->buf, record->buf_size);
+			tmp_buf = record->buf;
+			data_count = ret;
+		}
+
+
+		if (wav_save(tmp_buf, data_count)){
+			g_total_size += data_count;
+			ALOGD(" record count=%ld", g_total_size);		
+		}
+
+		if ( (!record->record_thread_run_flag) || (exit_flag == 1)){
+			ALOGD(" record data exit, record->record_thread_run_flag=%d, exit_flag=%d", record->record_thread_run_flag, exit_flag);	
+			break;	
+		}	
+	}
+
+	return param;
+}
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/record.h b/softwinner/common/hardware/audio/libcodec_audio/record.h
new file mode 100644
index 0000000..63963a9
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/record.h
@@ -0,0 +1,17 @@
+
+#ifndef __RECORD_H__
+#define __RECORD_H__
+
+#include "codec_utils.h"
+#include "hal_codec.h"
+
+int set_record_source(bool is_record_from_adc);
+int start_record(int record_buf_size);
+void stop_record(void);
+int init_record(struct codec_client *client);
+void exit_record();
+
+
+extern struct phone_common_record_ops phone_common_record_ops;
+
+#endif
diff --git a/softwinner/common/hardware/audio/libcodec_audio/volume_conf.c b/softwinner/common/hardware/audio/libcodec_audio/volume_conf.c
new file mode 100644
index 0000000..f31159b
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/volume_conf.c
@@ -0,0 +1,277 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+#define LOG_TAG "codec_audio"
+#define LOG_NDEBUG 0
+#include <utils/Log.h>
+
+#include "hal_codec.h"
+
+
+#define config_file "/system/etc/phone_volume.conf"
+
+#define MAX_LINE_SZ 100 
+#define CONF_SPACE ' '
+#define CONF_COMMENT '#'
+
+#define KEY_PHONE_EARPIECE  "PHONE_EARPIECE"
+#define KEY_PHONE_HEADSET   "PHONE_HEADSET"
+#define KEY_PHONE_SPEAKER   "PHONE_SPEAKER"
+
+#define KEY_BLUETOOTH_UP    "BLUETOOTH_UP"
+
+#define KEY_FM_HEADSET      "FM_HEADSET"
+#define KEY_FM_SPEAKER      "FM_SPEAKER"
+
+#define KEY_PHONEPN_GAIN 	"phonepn_gain"
+#define KEY_MIXER_GAIN 		"mixer_gain"
+#define KEY_HP_GAIN 		"hp_gain"
+#define KEY_SPK_GAIN 		"spk_gain"
+#define KEY_PCM_VOL 		"pcm_vol"
+#define KEY_LINE_GAIN 		"line_gain"
+#define KEY_PHONEPN_GAIN 	"phonepn_gain"
+
+static void free_int_list(int *p);
+static void print_array(int *array, int array_size);
+static int *process_line(FILE *fp, int *ret_len);
+
+static void free_int_list(int *p)
+{
+	if(p != NULL){
+		free(p);
+	}
+}
+
+void print_array(int *array, int array_size)
+{
+	int i = 0;
+	for(i=0; i< array_size; i++){
+		ALOGD("array[%d]=%d", i, array[i]);
+	}
+}
+
+static int * process_line(FILE *fp, int *ret_len)
+{
+	char linebuf[MAX_LINE_SZ];
+        int *val_array;
+	int array_size;
+	unsigned int i,j;
+
+	char *key_val;
+	char *line;
+
+	if (fgets(linebuf, MAX_LINE_SZ, fp) == NULL){
+		return NULL;	
+	}
+
+	line = strstr(linebuf,"=") + 1;
+
+	for(i=0,j=0; j< strlen(line); j++){
+		if (line[j] == ','){
+			i++; 
+		}
+	}
+
+	if(i==0){
+		*ret_len = 0;
+	}
+
+	array_size =  i + 1;
+	val_array = (int *)malloc( array_size * sizeof(int));
+	//ALOGD("linebuf=%s ", linebuf);
+	//ALOGD("line =%s ", line);
+	//ALOGD("array_size=%d ", array_size);
+
+	i = 0;
+	key_val = strtok(line, ",");
+
+	while(key_val != NULL){
+		val_array[i++] = atoi(key_val);
+	        //ALOGD(" i= %d, key_val=%d  ", i-1, val_array[i-1]);
+		key_val = strtok(NULL, ",");
+	}
+
+	//ALOGD(" i= %d  ", i);
+	*ret_len = i;
+	return val_array;
+}
+
+int get_volume_config(struct volume_array *vol_array)
+{
+	FILE *fp;
+	char *key_name, *key_value;
+	char linebuf[MAX_LINE_SZ];
+	char *line;
+	int *val_array=NULL;
+	int array_size=0; 
+	int i=0;
+
+	memset(vol_array, 0, 13 * 6 * sizeof(int) + sizeof(int) );
+
+	fp = fopen (config_file, "r");
+	if (fp == NULL)
+	{    
+		ALOGE("%s: Failed to open audio conf file at %s", __FUNCTION__, config_file);
+		return -1;
+	} 
+
+	while (fgets(linebuf, MAX_LINE_SZ, fp) != NULL){
+		/* trip  leading white spaces */
+		while (linebuf[i] == CONF_SPACE)
+			i++; 
+
+		/* skip  commented lines */
+		if (linebuf[i] == CONF_COMMENT)
+			continue;
+
+		line = (char*)&(linebuf[i]);
+
+		if (line == NULL)
+			continue;
+
+		key_name = strtok(line, "]");
+
+		if (key_name == NULL)
+			continue;
+
+		key_name = key_name + 1; //strip "["
+
+		if(strcmp(key_name, KEY_PHONE_EARPIECE) == 0){
+			ALOGD("key_name:%s ", key_name);
+
+			val_array = process_line(fp, &array_size);
+			if (val_array == NULL){
+				break;	
+			}
+			memcpy(vol_array->earpiece_phonepn_gain, val_array, 6 * sizeof(int));
+			//print_array(val_array, array_size);		
+			free_int_list(val_array);
+
+
+			val_array = process_line(fp, &array_size);
+			if (val_array == NULL){
+				break;	
+			}
+			memcpy(vol_array->earpiece_mixer_gain, val_array, 6 * sizeof(int));
+			//print_array(val_array, array_size);		
+			free_int_list(val_array);
+
+
+			val_array = process_line(fp, &array_size);
+			if (val_array == NULL){
+				break;	
+			}
+			memcpy(vol_array->earpiece_hp_gain, val_array, 6 * sizeof(int));
+			//print_array(val_array, array_size);		
+			free_int_list(val_array); 
+		 } else if(strcmp(key_name, KEY_PHONE_HEADSET) == 0) {
+			ALOGD("key_name:%s ", key_name);
+
+			val_array = process_line(fp, &array_size);
+			if (val_array == NULL){
+				break;	
+			}
+			memcpy(vol_array->headset_phonepn_gain, val_array, 6 * sizeof(int));
+			//print_array(val_array, array_size);		
+			free_int_list(val_array);
+			
+			val_array = process_line(fp, &array_size);
+			if (val_array == NULL){
+				break;	
+			}
+			memcpy(vol_array->headset_mixer_gain, val_array, 6 * sizeof(int));
+			//print_array(val_array, array_size);		
+			free_int_list(val_array);
+
+			val_array = process_line(fp, &array_size);
+			if (val_array == NULL){
+				break;	
+			}
+			memcpy(vol_array->headset_hp_gain, val_array, 6 * sizeof(int));
+			//print_array(val_array, array_size);		
+			free_int_list(val_array);
+		} else if(strcmp(key_name, KEY_PHONE_SPEAKER) == 0) {
+			ALOGD("key_name:%s ", key_name);
+
+			val_array = process_line(fp, &array_size);
+			if (val_array == NULL){
+				break;	
+			}
+			memcpy(vol_array->speaker_phonepn_gain, val_array, 6 * sizeof(int));
+			//print_array(val_array, array_size);		
+			free_int_list(val_array);
+			
+			val_array = process_line(fp, &array_size);
+			if (val_array == NULL){
+				break;	
+			}
+			memcpy(vol_array->speaker_mixer_gain,val_array, 6 * sizeof(int));
+			//print_array(val_array, array_size);		
+			free_int_list(val_array);
+
+			val_array = process_line(fp, &array_size);
+			if (val_array == NULL){
+				break;	
+			}
+			memcpy(vol_array->speaker_spk_gain, val_array, 6 * sizeof(int));
+			//print_array(val_array, array_size);		
+			free_int_list(val_array);
+
+		} else if(strcmp(key_name, KEY_BLUETOOTH_UP) == 0) {
+			ALOGD("key_name:%s ", key_name);
+
+			val_array = process_line(fp, &array_size);
+			if (val_array == NULL){
+				break;	
+			}
+		        memcpy(&(vol_array->up_pcm_gain), val_array, 1 * sizeof(int));
+			//print_array(val_array, array_size);		
+			free_int_list(val_array);
+			
+		} else if(strcmp(key_name, KEY_FM_HEADSET) == 0) {
+			ALOGD("key_name:%s ", key_name);
+
+			val_array = process_line(fp, &array_size);
+			if (val_array == NULL){
+				break;	
+			}
+			memcpy(vol_array->fm_headset_line_gain, val_array, 6 * sizeof(int));
+			//print_array(val_array, array_size);		
+			free_int_list(val_array);
+			
+			val_array = process_line(fp, &array_size);
+			if (val_array == NULL){
+				break;	
+			}
+			memcpy(vol_array->fm_headset_hp_gain, val_array, 6 * sizeof(int));
+			//print_array(val_array, array_size);		
+			free_int_list(val_array);
+
+		} else if(strcmp(key_name, KEY_FM_SPEAKER) == 0) {
+			ALOGD("key_name:%s ", key_name);
+
+			val_array = process_line(fp, &array_size);
+			if (val_array == NULL){
+				break;	
+			}
+			memcpy(vol_array->fm_speaker_line_gain, val_array, 6 * sizeof(int));
+			//print_array(val_array, array_size);		
+			free_int_list(val_array);
+			
+			val_array = process_line(fp, &array_size);
+			if (val_array == NULL){
+				break;	
+			}
+			memcpy(vol_array->fm_speaker_spk_gain, val_array, 6 * sizeof(int));
+			//print_array(val_array, array_size);		
+			free_int_list(val_array);
+	       }
+	}
+
+	fclose(fp);
+	if(val_array == NULL)
+		return -1;
+	return 0;
+}
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/wakelock.cpp b/softwinner/common/hardware/audio/libcodec_audio/wakelock.cpp
new file mode 100644
index 0000000..01e0eae
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/wakelock.cpp
@@ -0,0 +1,90 @@
+
+#define LOG_TAG "Audio_WakeLock"
+#define LOG_NDEBUG 0
+
+#include <utils/Log.h>
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#include <binder/Parcel.h>
+
+#include <powermanager/IPowerManager.h>
+#include <powermanager/PowerManager.h>
+#include <binder/IServiceManager.h>
+
+
+
+namespace android {
+#define ANDROID_WAKE_LOCK_NAME "libcodec_audio"
+
+static sp<IPowerManager>   gPowerManager;
+static  sp<IBinder>        gWakeLockToken;
+
+extern "C" void c_plus_plus_grabPartialWakeLock();
+extern "C" void c_plus_plus_releaseWakeLock();
+
+
+void c_plus_plus_releaseWakeLock() 
+{
+    if (gWakeLockToken != 0) {
+        ALOGV("releaseWakeLock_l() %s", ANDROID_WAKE_LOCK_NAME);
+        if (gPowerManager != 0) {
+            gPowerManager->releaseWakeLock(gWakeLockToken, 0);
+        }
+        gWakeLockToken.clear();
+    }
+}
+
+
+
+void c_plus_plus_grabPartialWakeLock() 
+{
+    if (gPowerManager == 0) {
+        // use checkService() to avoid blocking if power service is not up yet
+        sp<IBinder> binder =
+            defaultServiceManager()->checkService(String16("power"));
+        if (binder == 0) {
+            ALOGW("Thread %s cannot connect to the power manager service", ANDROID_WAKE_LOCK_NAME);
+        } else {
+            gPowerManager = interface_cast<IPowerManager>(binder);
+
+        class PMDeathRecipient : public IBinder::DeathRecipient {
+        public:
+                        PMDeathRecipient()  {}
+            virtual     ~PMDeathRecipient() {}
+
+            // IBinder::DeathRecipient
+            virtual void  binderDied(const wp<IBinder>& who){
+    				c_plus_plus_releaseWakeLock();
+				gPowerManager.clear();
+    				ALOGW("power manager service died !!!");
+			  }
+
+        private:
+                        PMDeathRecipient(const PMDeathRecipient&);
+                        PMDeathRecipient& operator = (const PMDeathRecipient&);
+        };
+
+        sp<IBinder::DeathRecipient> mDeathObserver = new PMDeathRecipient();
+
+        binder->linkToDeath(mDeathObserver);
+        }
+    }
+    if (gPowerManager != 0) {
+        sp<IBinder> binder = new BBinder();
+        status_t status = gPowerManager->acquireWakeLock(POWERMANAGER_PARTIAL_WAKE_LOCK,
+                                                         binder,
+                                                         String16(ANDROID_WAKE_LOCK_NAME));
+        if (status == NO_ERROR) {
+            gWakeLockToken = binder;
+        }
+        ALOGV("acquireWakeLock_l() %s status %d", ANDROID_WAKE_LOCK_NAME, status);
+    }
+        ALOGV("acquireWakeLock_l() 1");
+}
+
+
+}
+
+
diff --git a/softwinner/common/hardware/audio/libcodec_audio/wav.c b/softwinner/common/hardware/audio/libcodec_audio/wav.c
new file mode 100644
index 0000000..f16bf9b
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/wav.c
@@ -0,0 +1,129 @@
+
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include<time.h>
+
+
+#define LOG_TAG "bluetooth voice"
+#define LOG_NDEBUG 0
+#include <cutils/log.h>
+
+
+#include "wav.h"
+
+
+#define ID_RIFF 0x46464952
+#define ID_WAVE 0x45564157
+#define ID_FMT  0x20746d66
+#define ID_DATA 0x61746164
+
+#define FORMAT_PCM 1
+#define RECORD_NAME "/sdcard/record_test.wav"
+
+//static unsigned int frames =0;
+
+struct wav_header {
+    uint32_t riff_id;
+    uint32_t riff_sz;
+    uint32_t riff_fmt;
+    uint32_t fmt_id;//
+    uint32_t fmt_sz;
+    uint16_t audio_format;//
+    uint16_t num_channels;
+    uint32_t sample_rate;
+    uint32_t byte_rate;
+    uint16_t block_align;
+    uint16_t bits_per_sample;
+    uint32_t data_id;
+    uint32_t data_sz;
+};
+
+
+static struct wav_header header;
+static FILE *file;
+
+void wav_start()
+{
+        char *wday[]={"Sun","Mon","Tue","Wed","Thu","Fri","Sat"};
+        time_t timep;
+        struct tm *p; 
+        char filename[50]={0};
+        time(&timep);
+        p=localtime(&timep); /**/
+        //printf ("%d%d%d ", (1900+p->tm_year),( p->tm_mon), p->tm_mday);
+        //printf("%s %d:%d:%d\n", wday[p->tm_wday],p->tm_hour, p->tm_min, p->tm_sec);
+        sprintf(filename, "%s%d%d%d-%s-%d-%d-%d%s", "/sdcard/", (1900+p->tm_year),( p->tm_mon), p->tm_mday, wday[p->tm_wday],p->tm_hour, p->tm_min, p->tm_sec, ".wav");
+        //printf("buf=%s\n", filename);
+
+
+
+    header.riff_id = ID_RIFF;
+    header.riff_sz = 0;
+    header.riff_fmt = ID_WAVE;
+    header.fmt_id = ID_FMT;
+    header.fmt_sz = 16;
+    header.audio_format = FORMAT_PCM;
+    header.num_channels = 1;
+    header.sample_rate = 8000;
+    header.bits_per_sample = 16;
+    header.byte_rate = (header.bits_per_sample / 8) * (header.num_channels) * (header.sample_rate) ;
+    header.block_align = (header.num_channels) * (header.bits_per_sample / 8);
+    header.data_id = ID_DATA;
+
+    file = fopen(filename, "wb+");
+    if (!file) {
+        ALOGE("in, wav_header, Unable to create record wav ");
+        return ;
+    }
+
+    fseek(file, sizeof(struct wav_header), SEEK_SET);
+
+    int frames =1;
+    header.data_sz = frames * header.block_align;
+
+    //fseek(file, 0, SEEK_SET);
+   // fwrite(&header, sizeof(struct wav_header), 1, file);
+
+    //fclose(file);
+}
+
+int wav_save(char *buf, unsigned int buf_size)
+{
+        if (fwrite(buf, buf_size, 1, file) != 1) {
+            ALOGE("Error write record file,err:%s\n",strerror(errno));
+            return 0;
+        }    
+	return 1;
+}
+
+int wav_end(int data)
+{
+   int frames = 0;
+   
+   frames = data/( (header.bits_per_sample / 8) * (header.num_channels) ) ;
+   header.data_sz = frames * header.block_align;
+   header.riff_sz = header.data_sz + sizeof(struct wav_header) - 8  ;
+
+   fseek(file, 0, SEEK_SET);
+   fwrite(&header, sizeof(struct wav_header), 1, file);
+   ALOGD("3 Write record file end, header.data_sz=%d,header.riff_sz=%d", header.data_sz, header.riff_sz);
+ 
+   fclose(file);
+
+    return 1;
+}
+/*
+int main(int argc, char **argv) 
+{
+	char buf[1024]={0};
+ALOGE("wav start");
+wav_start();
+wav_save(buf, 1024);
+wav_end(512);
+return 0;
+}
+*/
diff --git a/softwinner/common/hardware/audio/libcodec_audio/wav.h b/softwinner/common/hardware/audio/libcodec_audio/wav.h
new file mode 100644
index 0000000..649619e
--- /dev/null
+++ b/softwinner/common/hardware/audio/libcodec_audio/wav.h
@@ -0,0 +1,9 @@
+
+#ifndef __WAV_H__
+#define __WAV_H__
+
+int wav_end(int data);
+int wav_save(char *buf, unsigned int buf_size);
+void wav_start();
+
+#endif
diff --git a/softwinner/common/hardware/audio/libril_audio/Android.mk b/softwinner/common/hardware/audio/libril_audio/Android.mk
new file mode 100644
index 0000000..1b11d92
--- /dev/null
+++ b/softwinner/common/hardware/audio/libril_audio/Android.mk
@@ -0,0 +1,51 @@
+# Copyright (C) 2011 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := libril_audio
+
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/
+#SRC_FILES := $(call find-subdir-subdir-files, bp_devices/mu509/, *.c, .h)
+#SRC_FILES := $(call find-subdir-files, *.c)
+
+#$(warning adf$(SRC_FILES))
+
+LOCAL_SRC_FILES := bp.c  \
+			bp_devices.c \
+			bp_utils.c \
+			bp_devices/mu509/mu509.c  \
+			bp_devices/mu709/mu709.c  \
+			bp_devices/oviphone_em55/em55.c \
+			bp_devices/demo/demo.c \
+			bp_devices/usi6276/usi6276.c
+
+LOCAL_C_INCLUDES += \
+	$(LOCAL_PATH)/
+	
+LOCAL_SHARED_LIBRARIES += liblog libcutils libdl
+LOCAL_MODULE_TAGS := optional
+
+include $(BUILD_SHARED_LIBRARY)
+
+
+#$(addsuffix /java, \	    ethernet \	 )
+
+#	external/tinyalsa/include \
+#	system/media/audio_utils/include \
+#	system/media/audio_effects/include \
+
+
diff --git a/softwinner/common/hardware/audio/libril_audio/bp.c b/softwinner/common/hardware/audio/libril_audio/bp.c
new file mode 100644
index 0000000..9ad284b
--- /dev/null
+++ b/softwinner/common/hardware/audio/libril_audio/bp.c
@@ -0,0 +1,71 @@
+
+#define LOG_TAG "bp_audio"
+#define LOG_NDEBUG 0
+
+#include <stdlib.h>
+#include <string.h>
+#include <utils/Log.h>
+#include <cutils/properties.h>
+
+#include "bp_devices.h"
+#include "hal_bp.h"
+
+static int bp_device_detect(void)
+{
+    int index = -1, i=-1, ret = 0;
+    char device[20]={0};
+
+    ret = property_get("ro.sw.audio.bp_device_name", device, "0");
+    if(ret <= 0){
+        ALOGE("wrn: get ro.sw.audio.bp_device_name failed");
+        return -1;
+    }
+
+    ALOGD("get ro.sw.audio.bp_device_name=%s", device);
+
+    for (i=0 ; i < bp_devices_count ; i++)
+    {
+        if (strstr(device, bp_devices[i].name) != NULL)
+        {
+            index = i;
+            break;
+        }
+    }
+    if (index == -1){
+	    index = 0 ; //default demo
+    }
+
+    ALOGD("bp_device_detect index=%d", index);
+
+
+    return index;
+}
+
+struct bp_client* bp_client_new()
+{
+    struct bp_client *client;
+    int device_index = -1;
+
+    device_index = bp_device_detect();
+
+    if (device_index < 0 || device_index > bp_devices_count)
+        return NULL;
+
+    client = (struct bp_client*) malloc(sizeof(struct bp_client));
+    memset(client, 0, sizeof(struct bp_client));
+
+    if (bp_devices[device_index].ops)
+        client->bp_ops = bp_devices[device_index].ops;
+
+    return client;
+}
+
+void bp_client_free(struct bp_client *client)
+{
+    free(client);
+    client = NULL;
+}
+
+
+
+
diff --git a/softwinner/common/hardware/audio/libril_audio/bp_devices.c b/softwinner/common/hardware/audio/libril_audio/bp_devices.c
new file mode 100644
index 0000000..9fec663
--- /dev/null
+++ b/softwinner/common/hardware/audio/libril_audio/bp_devices.c
@@ -0,0 +1,42 @@
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include "bp_devices.h"
+
+struct bp_device_desc bp_devices[] = {
+    {
+        .name = "demo",
+        .board_name = "demo_plan",
+        .ops = &demo_ops,
+        .other_ops = NULL,
+    },
+    {
+        .name = "mu509",
+        .board_name = "xxx1_plan",
+        .ops = &mu509_ops,
+        .other_ops = NULL,
+    },
+    {
+        .name = "em55",
+        .board_name = "xxx2_plan",
+        .ops = &em55_ops,
+        .other_ops = NULL,
+    },
+    {
+    	.name = "usi6276",
+		.board_name = "xxx3_plan",
+		.ops = &usi6276_ops,
+		.other_ops = NULL,
+    },
+    {
+        .name = "mu709",
+        .board_name = "xxx1_plan",
+        .ops = &mu709_ops,
+        .other_ops = NULL,
+    },
+};
+
+int bp_devices_count = sizeof(bp_devices) / sizeof(struct bp_device_desc);
+
+
diff --git a/softwinner/common/hardware/audio/libril_audio/bp_devices.h b/softwinner/common/hardware/audio/libril_audio/bp_devices.h
new file mode 100644
index 0000000..ff2cc01
--- /dev/null
+++ b/softwinner/common/hardware/audio/libril_audio/bp_devices.h
@@ -0,0 +1,34 @@
+
+#ifndef __BP_DEVICES_H__
+#define __BP_DEVICES_H__
+
+#include "hal_bp.h"
+
+struct bp_device_desc {
+    char *name;
+    char *board_name;
+
+    struct bp_ops *ops;
+    struct other_ops *other_ops;
+};
+
+extern struct bp_device_desc bp_devices[];
+extern int bp_devices_count;
+
+/* MU509 */
+extern struct bp_ops mu509_ops;
+
+extern struct bp_ops mu709_ops;
+
+/* EM55 */
+extern struct bp_ops em55_ops;
+
+/*USI6276*/
+extern struct bp_ops usi6276_ops;
+
+/* DEMO */
+extern struct bp_ops demo_ops;
+
+
+#endif
+
diff --git a/softwinner/common/hardware/audio/libril_audio/bp_devices/demo/demo.c b/softwinner/common/hardware/audio/libril_audio/bp_devices/demo/demo.c
new file mode 100644
index 0000000..c869d65
--- /dev/null
+++ b/softwinner/common/hardware/audio/libril_audio/bp_devices/demo/demo.c
@@ -0,0 +1,173 @@
+
+#define LOG_TAG "audio_ril_demo"
+#define LOG_NDEBUG 0
+
+#include <stdlib.h>
+#include <string.h>
+#include <utils/Log.h>
+
+#include <cutils/properties.h>
+
+#include "hal_bp.h"
+
+#define AT_PATH "/dev/mux2"
+
+
+//bp.
+static int demo_get_tty_dev(char *name)
+{
+   strncpy(name, AT_PATH, strlen(AT_PATH));
+   ALOGD("demo_get_tty_dev\n");
+   return 0;
+}
+
+
+//.,
+static int earpiece_vol[]={1,2,3,4,5,6};
+static int headset_vol[]={1,2,3,4,5,6};
+static int spk_vol[]={1,2,3,4,5,6};
+static int bt_vol[]={1,2,3,4,5,6};
+static int main_mic_vol[]={1,2,3,4,5,6};
+static int headset_mic_vol[]={1,2,3,4,5,6};
+
+//,
+static int demo_set_call_volume(ril_audio_path_type_t path, int volume)
+{
+	char tty_dev[32]={0};
+	char cmdline[30];
+	int level, bp_vol;
+
+
+	if (volume >= 10) {
+		level = 5;
+	} else if (volume >= 8){
+		level = 4;
+	} else if (volume >= 6){
+		level = 3;
+	} else if (volume >= 4){
+		level = 2;
+	} else if (volume >= 2){
+		level = 1;
+	} else {
+		level = 0;
+	}
+
+#if 0
+      switch(path) {
+            case RIL_AUDIO_PATH_EARPIECE:
+		sprintf(cmdline, "AT+CLVL=%d",  earpiece_vol[level]);
+            	break;
+            case RIL_AUDIO_PATH_HEADSET:
+		sprintf(cmdline, "AT+CLVL=%d",  headset_vol[level]);
+	        break;
+            case RIL_AUDIO_PATH_SPK:
+		sprintf(cmdline, "AT+CLVL=%d",  spk_vol[level]);
+                break;
+            case RIL_AUDIO_PATH_BT:
+		sprintf(cmdline, "AT+CLVL=%d",  bt_vol[level]);
+                break;
+            case RIL_AUDIO_PATH_MAIM_MIC:
+		sprintf(cmdline, "AT+CLVL=%d",  main_mic_vol[level]);
+                break;
+            case RIL_AUDIO_PATH_HEADSET_MIC:
+		sprintf(cmdline, "AT+CLVL=%d",  headset_mic_vol[level]);
+                break;
+
+	}
+#endif
+
+	demo_get_tty_dev(tty_dev);
+	//exec_at(tty_dev,cmdline);
+
+   	ALOGD("demo_set_call_volume\n");
+
+   return 0;
+}
+
+//
+static int demo_set_call_path(ril_audio_path_type_t path)
+{
+	int channel = 0;
+	char cmdline[50]={0};
+	char tty_dev[32]={0};
+
+#if 0
+      switch(path) {
+#if 0
+            case RIL_AUDIO_PATH_EARPIECE:
+                channel = 0;
+            	break;
+            case RIL_AUDIO_PATH_HEADSET:
+                channel = 0;
+	        break;
+            case RIL_AUDIO_PATH_SPK:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_BT:
+                channel = 2;
+                break;
+            case RIL_AUDIO_PATH_MAIM_MIC:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_HEADSET_MIC:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_EARPIECE_LOOP:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_HEADSET_LOOP:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_SPK_LOOP:
+                channel = 0;
+                break;
+#else
+            case RIL_AUDIO_PATH_EARPIECE:
+            case RIL_AUDIO_PATH_HEADSET:
+            case RIL_AUDIO_PATH_SPK:
+            case RIL_AUDIO_PATH_BT:
+            case RIL_AUDIO_PATH_MAIM_MIC:
+            case RIL_AUDIO_PATH_HEADSET_MIC:
+            case RIL_AUDIO_PATH_EARPIECE_LOOP:
+            case RIL_AUDIO_PATH_HEADSET_LOOP:
+            case RIL_AUDIO_PATH_SPK_LOOP:
+                channel = 2;
+                break;
+
+#endif
+            default:
+                channel = 0;
+                break;
+        }
+#endif
+
+    demo_get_tty_dev(tty_dev);
+    //sprintf(cmdline, "AT^SWSPATH=%d", channel);
+    //exec_at(tty_dev,cmdline);
+
+   ALOGD("demo_set_call_path\n");
+
+   return 0;
+}
+
+//at
+static int demo_set_call_at(char *at)
+{
+    char tty_dev[32]={0};
+
+   // demo_get_tty_dev(tty_dev);
+   //1 exec_at(tty_dev,at);
+
+   ALOGD("demo_set_call_at\n");
+   return 0;
+}
+
+struct bp_ops demo_ops = {
+    .get_tty_dev = demo_get_tty_dev,
+    .set_call_volume= demo_set_call_volume,
+    .set_call_path = demo_set_call_path,
+    .set_call_at = demo_set_call_at,
+};
+
+
+
diff --git a/softwinner/common/hardware/audio/libril_audio/bp_devices/demo/demo.h b/softwinner/common/hardware/audio/libril_audio/bp_devices/demo/demo.h
new file mode 100644
index 0000000..b332fc8
--- /dev/null
+++ b/softwinner/common/hardware/audio/libril_audio/bp_devices/demo/demo.h
@@ -0,0 +1,12 @@
+
+
+#ifndef __DEMO_H__
+#define __DEMO_H__
+
+
+
+
+
+#endif
+
+
diff --git a/softwinner/common/hardware/audio/libril_audio/bp_devices/mu509/mu509.c b/softwinner/common/hardware/audio/libril_audio/bp_devices/mu509/mu509.c
new file mode 100644
index 0000000..9197013
--- /dev/null
+++ b/softwinner/common/hardware/audio/libril_audio/bp_devices/mu509/mu509.c
@@ -0,0 +1,160 @@
+
+#define LOG_TAG "audio_ril"
+#define LOG_NDEBUG 0
+
+#include <stdlib.h>
+#include <string.h>
+#include <utils/Log.h>
+
+#include <cutils/properties.h>
+
+#include "hal_bp.h"
+
+static int mu509_get_tty_dev(char *name)
+{
+
+    char temp_name[32];
+    int no = -1;
+    int i = 0;
+    int ret = 0;
+
+    if(NULL == name){
+        return -1;
+    }
+
+    for(i = 0; i < 20; i++){
+    	memset(temp_name, 0, 32);
+    	sprintf(temp_name, "/dev/ttyUSB%d", i);
+
+		ret = access(temp_name, F_OK);
+		if(ret != 0){
+			continue;
+		}
+
+		no = i;
+    }
+
+	if(no >= 0){
+		sprintf(temp_name, "/dev/ttyUSB%d", no);
+		strcpy(name, temp_name);
+		ALOGV("get_current_tty_dev_mu509: tty_dev=%s\n", name);
+		return 0;
+	}else{
+		ALOGV("get_current_tty_dev_mu509: can not find the AT device\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int mu509_set_call_volume(ril_audio_path_type_t path, int volume)
+{
+	char tty_dev[32]={0};
+	char cmdline[30];
+
+	int level;
+
+	if (volume >= 10) {
+		level = 5;
+	} else if (volume >= 8){
+		level = 4;
+	} else if (volume >= 6){
+		level = 3;
+	} else if (volume >= 4){
+		level = 2;
+	} else if (volume >= 2){
+		level = 1;
+	} else {
+		level = 1;
+	}
+
+	mu509_get_tty_dev(tty_dev);
+
+	sprintf(cmdline, "AT+CLVL=%d", level);
+
+	exec_at(tty_dev,cmdline);
+
+	return 0;
+}
+
+static int mu509_set_call_path(ril_audio_path_type_t path)
+{
+	int channel = 0;
+       char cmdline[50]={0};
+	char tty_dev[32]={0};
+
+      switch(path) {
+#if 0
+            case RIL_AUDIO_PATH_EARPIECE:
+                channel = 0;
+            	break;
+            case RIL_AUDIO_PATH_HEADSET:
+                channel = 0;
+	        break;
+            case RIL_AUDIO_PATH_SPK:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_BT:
+                channel = 2;
+                break;
+            case RIL_AUDIO_PATH_MAIM_MIC:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_HEADSET_MIC:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_EARPIECE_LOOP:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_HEADSET_LOOP:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_SPK_LOOP:
+                channel = 0;
+                break;
+#else
+            case RIL_AUDIO_PATH_EARPIECE:
+            case RIL_AUDIO_PATH_HEADSET:
+            case RIL_AUDIO_PATH_SPK:
+            case RIL_AUDIO_PATH_BT:
+            case RIL_AUDIO_PATH_MAIM_MIC:
+            case RIL_AUDIO_PATH_HEADSET_MIC:
+            case RIL_AUDIO_PATH_EARPIECE_LOOP:
+            case RIL_AUDIO_PATH_HEADSET_LOOP:
+            case RIL_AUDIO_PATH_SPK_LOOP:
+                channel = 2;
+                break;
+
+#endif
+            default:
+                channel = 0;
+                break;
+        }
+
+    mu509_get_tty_dev(tty_dev);
+
+    ALOGD("mu509: channel=%d, at=%s\n", channel, tty_dev);
+
+    sprintf(cmdline, "AT^SWSPATH=%d", channel);
+    exec_at(tty_dev,cmdline);
+
+    return 0;
+}
+
+static int mu509_set_call_at(char *at)
+{
+	char tty_dev[32]={0};
+    mu509_get_tty_dev(tty_dev);
+    exec_at(tty_dev,at);
+
+    ALOGD("mu509_set_call_at");
+
+	return 0;
+}
+
+struct bp_ops mu509_ops = {
+    .get_tty_dev = mu509_get_tty_dev,
+    .set_call_volume= mu509_set_call_volume,
+    .set_call_path = mu509_set_call_path,
+    .set_call_at = mu509_set_call_at,
+};
+
diff --git a/softwinner/common/hardware/audio/libril_audio/bp_devices/mu509/mu509.h b/softwinner/common/hardware/audio/libril_audio/bp_devices/mu509/mu509.h
new file mode 100644
index 0000000..ff1a926
--- /dev/null
+++ b/softwinner/common/hardware/audio/libril_audio/bp_devices/mu509/mu509.h
@@ -0,0 +1,12 @@
+
+
+#ifndef __MU509_H__
+#define __MU509_H__
+
+
+
+
+
+#endif
+
+
diff --git a/softwinner/common/hardware/audio/libril_audio/bp_devices/mu709/mu709.c b/softwinner/common/hardware/audio/libril_audio/bp_devices/mu709/mu709.c
new file mode 100644
index 0000000..fe60879
--- /dev/null
+++ b/softwinner/common/hardware/audio/libril_audio/bp_devices/mu709/mu709.c
@@ -0,0 +1,133 @@
+
+#define LOG_TAG "audio_ril"
+#define LOG_NDEBUG 0
+
+#include <stdlib.h>
+#include <string.h>
+#include <utils/Log.h>
+
+#include <cutils/properties.h>
+
+#include "hal_bp.h"
+
+static int mu709_get_tty_dev(char *name)
+{
+
+    char temp_name[32];
+    int no = -1;
+    int i = 0;
+    int ret = 0;
+
+    if(NULL == name){
+        return -1;
+    }
+
+    for(i = 0; i < 20; i++){
+    	memset(temp_name, 0, 32);
+    	sprintf(temp_name, "/dev/ttyUSB%d", i);
+
+		ret = access(temp_name, F_OK);
+		if(ret != 0){
+			continue;
+		}
+
+		no = i;
+    }
+
+	if(no >= 0){
+		sprintf(temp_name, "/dev/ttyUSB%d", no);
+		strcpy(name, temp_name);
+		ALOGV("get_current_tty_dev_mu709: tty_dev=%s\n", name);
+		return 0;
+	}else{
+		ALOGV("get_current_tty_dev_mu709: can not find the AT device\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int mu709_set_call_volume(ril_audio_path_type_t path, int volume)
+{
+	char tty_dev[32]={0};
+	char cmdline[30];
+
+	int level;
+
+	if (volume >= 10) {
+		level = 5;
+	} else if (volume >= 8){
+		level = 4;
+	} else if (volume >= 6){
+		level = 3;
+	} else if (volume >= 4){
+		level = 2;
+	} else if (volume >= 2){
+		level = 1;
+	} else {
+		level = 1;
+	}
+
+	mu709_get_tty_dev(tty_dev);
+
+	sprintf(cmdline, "AT+CLVL=%d", level);
+
+	exec_at(tty_dev,cmdline);
+
+	return 0;
+}
+
+static int mu709_set_call_path(ril_audio_path_type_t path)
+{
+	int mode = 0;
+    char cmdline[50]={0};
+	char tty_dev[32]={0};
+
+    switch(path) {
+        case RIL_AUDIO_PATH_MAIM_MIC:
+        case RIL_AUDIO_PATH_HEADSET_MIC:
+        case RIL_AUDIO_PATH_EARPIECE:
+        case RIL_AUDIO_PATH_HEADSET:
+        case RIL_AUDIO_PATH_EARPIECE_LOOP:
+        case RIL_AUDIO_PATH_HEADSET_LOOP:
+        case RIL_AUDIO_PATH_SPK_LOOP:
+            mode = 3;
+            break;
+        case RIL_AUDIO_PATH_SPK:
+            mode = 1;
+            break;
+        case RIL_AUDIO_PATH_BT:
+            mode = 4;
+            break;
+        default:
+            mode = 3;
+            break;
+    }
+
+    mu709_get_tty_dev(tty_dev);
+
+    ALOGD("mu709: voice mode=%d, at=%s\n", mode, tty_dev);
+
+    sprintf(cmdline, "AT^VMSET=%d", mode);
+    exec_at(tty_dev,cmdline);
+
+    return 0;
+}
+
+static int mu709_set_call_at(char *at)
+{
+	char tty_dev[32]={0};
+    mu709_get_tty_dev(tty_dev);
+    exec_at(tty_dev,at);
+
+    ALOGD("mu709_set_call_at");
+
+	return 0;
+}
+
+struct bp_ops mu709_ops = {
+    .get_tty_dev = mu709_get_tty_dev,
+    .set_call_volume= mu709_set_call_volume,
+    .set_call_path = mu709_set_call_path,
+    .set_call_at = mu709_set_call_at,
+};
+
diff --git a/softwinner/common/hardware/audio/libril_audio/bp_devices/oviphone_em55/em55.c b/softwinner/common/hardware/audio/libril_audio/bp_devices/oviphone_em55/em55.c
new file mode 100644
index 0000000..cad8e16
--- /dev/null
+++ b/softwinner/common/hardware/audio/libril_audio/bp_devices/oviphone_em55/em55.c
@@ -0,0 +1,107 @@
+
+#define LOG_TAG "audio_ril_em55"
+#define LOG_NDEBUG 0
+
+#include <stdlib.h>
+#include <string.h>
+#include <utils/Log.h>
+
+#include <cutils/properties.h>
+
+#include "hal_bp.h"
+
+#define AT_PATH "/dev/mux2"
+
+static char tty_dev[32] = AT_PATH;
+
+static int em55_get_tty_dev(char *name)
+{
+   ALOGD("em55_get_tty_dev\n");
+   return 0;
+}
+
+static int em55_set_call_volume(ril_audio_path_type_t path, int vol)
+{
+   ALOGD("em55_set_call_volume\n");
+   return 0;
+}
+
+static int em55_set_call_path(ril_audio_path_type_t path)
+{
+	int channel = 0;
+	char cmdline[50]={0};
+	//char tty_dev[32]={0};
+
+#if 1
+      switch(path) {
+#if 0
+            case RIL_AUDIO_PATH_EARPIECE:
+                channel = 0;
+            	break;
+            case RIL_AUDIO_PATH_HEADSET:
+                channel = 0;
+	        break;
+            case RIL_AUDIO_PATH_SPK:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_BT:
+                channel = 2;
+                break;
+            case RIL_AUDIO_PATH_MAIM_MIC:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_HEADSET_MIC:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_EARPIECE_LOOP:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_HEADSET_LOOP:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_SPK_LOOP:
+                channel = 0;
+                break;
+#else
+            case RIL_AUDIO_PATH_EARPIECE:
+            case RIL_AUDIO_PATH_HEADSET:
+            case RIL_AUDIO_PATH_SPK:
+            case RIL_AUDIO_PATH_MAIM_MIC:
+            case RIL_AUDIO_PATH_HEADSET_MIC:
+            case RIL_AUDIO_PATH_EARPIECE_LOOP:
+            case RIL_AUDIO_PATH_HEADSET_LOOP:
+            case RIL_AUDIO_PATH_SPK_LOOP:
+		channel = 2;
+		exec_at(tty_dev,"AT+BTON=0");
+		break;
+            case RIL_AUDIO_PATH_BT:
+		exec_at(tty_dev,"AT+BTON=1");
+		break;
+#endif
+            default:
+                channel = 0;
+                break;
+        }
+#endif
+ 
+   ALOGD("em55_set_call_path\n");
+   return 0;
+}
+
+static int em55_set_call_at(char *at)
+{
+    exec_at(tty_dev,at);
+
+   ALOGD("em55_set_call_at\n");
+   return 0;
+}
+
+struct bp_ops em55_ops = {
+    .get_tty_dev = em55_get_tty_dev,
+    .set_call_volume= em55_set_call_volume,
+    .set_call_path = em55_set_call_path,
+    .set_call_at = em55_set_call_at,
+};
+
+
+
diff --git a/softwinner/common/hardware/audio/libril_audio/bp_devices/oviphone_em55/em55.h b/softwinner/common/hardware/audio/libril_audio/bp_devices/oviphone_em55/em55.h
new file mode 100644
index 0000000..c036ef8
--- /dev/null
+++ b/softwinner/common/hardware/audio/libril_audio/bp_devices/oviphone_em55/em55.h
@@ -0,0 +1,12 @@
+
+
+#ifndef __EM55_H__
+#define __EM55_H__
+
+
+
+
+
+#endif
+
+
diff --git a/softwinner/common/hardware/audio/libril_audio/bp_devices/usi6276/usi6276.c b/softwinner/common/hardware/audio/libril_audio/bp_devices/usi6276/usi6276.c
new file mode 100644
index 0000000..5d045ab
--- /dev/null
+++ b/softwinner/common/hardware/audio/libril_audio/bp_devices/usi6276/usi6276.c
@@ -0,0 +1,173 @@
+
+#define LOG_TAG "audio_ril_usi6276"
+#define LOG_NDEBUG 0
+
+#include <stdlib.h>
+#include <string.h>
+#include <utils/Log.h>
+
+#include <cutils/properties.h>
+
+#include "hal_bp.h"
+
+#define AT_PATH "/dev/ttyS3"
+
+
+//bp.
+static int usi6276_get_tty_dev(char *name)
+{
+   strncpy(name, AT_PATH, strlen(AT_PATH));
+   ALOGD("usi6276_get_tty_dev\n");
+   return 0;
+}
+
+
+//.,
+static int earpiece_vol[]={1,2,3,4,5,6};
+static int headset_vol[]={1,2,3,4,5,6};
+static int spk_vol[]={1,2,3,4,5,6};
+static int bt_vol[]={1,2,3,4,5,6};
+static int main_mic_vol[]={1,2,3,4,5,6};
+static int headset_mic_vol[]={1,2,3,4,5,6};
+
+//,
+static int usi6276_set_call_volume(ril_audio_path_type_t path, int volume)
+{
+	char tty_dev[32]={0};
+	char cmdline[30];
+	int level, bp_vol;
+
+
+	if (volume >= 10) {
+		level = 5;
+	} else if (volume >= 8){
+		level = 4;
+	} else if (volume >= 6){
+		level = 3;
+	} else if (volume >= 4){
+		level = 2;
+	} else if (volume >= 2){
+		level = 1;
+	} else {
+		level = 0;
+	}
+
+#if 0
+      switch(path) {
+            case RIL_AUDIO_PATH_EARPIECE:
+		sprintf(cmdline, "AT+CLVL=%d",  earpiece_vol[level]);
+            	break;
+            case RIL_AUDIO_PATH_HEADSET:
+		sprintf(cmdline, "AT+CLVL=%d",  headset_vol[level]);
+	        break;
+            case RIL_AUDIO_PATH_SPK:
+		sprintf(cmdline, "AT+CLVL=%d",  spk_vol[level]);
+                break;
+            case RIL_AUDIO_PATH_BT:
+		sprintf(cmdline, "AT+CLVL=%d",  bt_vol[level]);
+                break;
+            case RIL_AUDIO_PATH_MAIM_MIC:
+		sprintf(cmdline, "AT+CLVL=%d",  main_mic_vol[level]);
+                break;
+            case RIL_AUDIO_PATH_HEADSET_MIC:
+		sprintf(cmdline, "AT+CLVL=%d",  headset_mic_vol[level]);
+                break;
+
+	}
+#endif
+
+	usi6276_get_tty_dev(tty_dev);
+	//exec_at(tty_dev,cmdline);
+
+   	ALOGD("usi6276_set_call_volume\n");
+
+   return 0;
+}
+
+//
+static int usi6276_set_call_path(ril_audio_path_type_t path)
+{
+	int channel = 0;
+	char cmdline[50]={0};
+	char tty_dev[32]={0};
+
+#if 0
+      switch(path) {
+#if 0
+            case RIL_AUDIO_PATH_EARPIECE:
+                channel = 0;
+            	break;
+            case RIL_AUDIO_PATH_HEADSET:
+                channel = 0;
+	        break;
+            case RIL_AUDIO_PATH_SPK:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_BT:
+                channel = 2;
+                break;
+            case RIL_AUDIO_PATH_MAIM_MIC:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_HEADSET_MIC:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_EARPIECE_LOOP:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_HEADSET_LOOP:
+                channel = 0;
+                break;
+            case RIL_AUDIO_PATH_SPK_LOOP:
+                channel = 0;
+                break;
+#else
+            case RIL_AUDIO_PATH_EARPIECE:
+            case RIL_AUDIO_PATH_HEADSET:
+            case RIL_AUDIO_PATH_SPK:
+            case RIL_AUDIO_PATH_BT:
+            case RIL_AUDIO_PATH_MAIM_MIC:
+            case RIL_AUDIO_PATH_HEADSET_MIC:
+            case RIL_AUDIO_PATH_EARPIECE_LOOP:
+            case RIL_AUDIO_PATH_HEADSET_LOOP:
+            case RIL_AUDIO_PATH_SPK_LOOP:
+                channel = 2;
+                break;
+
+#endif
+            default:
+                channel = 0;
+                break;
+        }
+#endif
+
+    usi6276_get_tty_dev(tty_dev);
+    //sprintf(cmdline, "AT^SWSPATH=%d", channel);
+    //exec_at(tty_dev,cmdline);
+
+   ALOGD("usi6276_set_call_path\n");
+
+   return 0;
+}
+
+//at
+static int usi6276_set_call_at(char *at)
+{
+    char tty_dev[32]={0};
+
+    usi6276_get_tty_dev(tty_dev);
+    exec_at(tty_dev,at);
+
+   ALOGD("usi6276_set_call_at\n");
+   return 0;
+}
+
+struct bp_ops usi6276_ops = {
+    .get_tty_dev = usi6276_get_tty_dev,
+    .set_call_volume= usi6276_set_call_volume,
+    .set_call_path = usi6276_set_call_path,
+    .set_call_at = usi6276_set_call_at,
+};
+
+
+
diff --git a/softwinner/common/hardware/audio/libril_audio/bp_devices/usi6276/usi6276.h b/softwinner/common/hardware/audio/libril_audio/bp_devices/usi6276/usi6276.h
new file mode 100644
index 0000000..5bcc6da
--- /dev/null
+++ b/softwinner/common/hardware/audio/libril_audio/bp_devices/usi6276/usi6276.h
@@ -0,0 +1,12 @@
+
+
+#ifndef __USI6276_H__
+#define __USI6276_H__
+
+
+
+
+
+#endif
+
+
diff --git a/softwinner/common/hardware/audio/libril_audio/bp_utils.c b/softwinner/common/hardware/audio/libril_audio/bp_utils.c
new file mode 100644
index 0000000..e4774a1
--- /dev/null
+++ b/softwinner/common/hardware/audio/libril_audio/bp_utils.c
@@ -0,0 +1,13 @@
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+int exec_at(char *tty_dev, char *at)
+{
+   char cmdline[100] ={0} ;
+   sprintf(cmdline, "/system/bin/busybox echo -e \"%s\r\n\" > %s", at, tty_dev);
+   return  system(cmdline);
+}
+
+
diff --git a/softwinner/common/hardware/audio/libril_audio/bp_utils.h b/softwinner/common/hardware/audio/libril_audio/bp_utils.h
new file mode 100644
index 0000000..7f7a8c4
--- /dev/null
+++ b/softwinner/common/hardware/audio/libril_audio/bp_utils.h
@@ -0,0 +1,26 @@
+
+#ifndef __BP_UTILS_H__
+#define __BP_UTILS_H__
+
+int exec_at(char *tty_dev, char *at);
+
+typedef enum {
+	RIL_AUDIO_PATH_EARPIECE = 0,//
+	RIL_AUDIO_PATH_HEADSET,//
+	RIL_AUDIO_PATH_SPK,//
+	RIL_AUDIO_PATH_BT,//
+	RIL_AUDIO_PATH_MAIM_MIC,//mic
+	RIL_AUDIO_PATH_HEADSET_MIC,//mic
+	RIL_AUDIO_PATH_EARPIECE_LOOP,//
+	RIL_AUDIO_PATH_HEADSET_LOOP,//
+	RIL_AUDIO_PATH_SPK_LOOP,//
+
+	RIL_AUDIO_PATH_CNT,
+	RIL_AUDIO_PATH_MAX =RIL_AUDIO_PATH_CNT-1,
+}ril_audio_path_type_t;
+
+
+#endif
+
+
+
diff --git a/softwinner/common/hardware/audio/libril_audio/hal_bp.h b/softwinner/common/hardware/audio/libril_audio/hal_bp.h
new file mode 100644
index 0000000..0c44863
--- /dev/null
+++ b/softwinner/common/hardware/audio/libril_audio/hal_bp.h
@@ -0,0 +1,25 @@
+
+#ifndef __HAL_BP_H__
+#define __HAL_BP_H__
+
+#include "bp_utils.h"
+
+struct bp_ops {
+    int (*get_tty_dev)(char *name);
+    int (*set_call_volume)(ril_audio_path_type_t path, int vol);
+    int (*set_call_path)(ril_audio_path_type_t path);
+    int (*set_call_at)(char *at);
+};
+
+struct other_ops {
+    int (*other_op)(char *name);
+};
+
+
+struct bp_client {
+    struct bp_ops *bp_ops;
+};
+
+#endif
+
+
diff --git a/softwinner/common/hardware/audio/phone_volume.conf b/softwinner/common/hardware/audio/phone_volume.conf
new file mode 100644
index 0000000..28581bd
--- /dev/null
+++ b/softwinner/common/hardware/audio/phone_volume.conf
@@ -0,0 +1,60 @@
+#Configuration file for the audio volume 
+
+#:
+#[PHONE_EARPIECE] -->.,phonepn_gain,mixer_gain,output_gain.
+#phonepn_gain =1,4,4,4,4,7   (0~7)
+#mixer_gain   =3,3,3,4,5,7   (0~7)
+#output_gain  =60,60,60,60,60,60    (0~61)
+#
+#,level_1,.
+#level1, level2, level3, level4, level5, level6
+#
+#phonepn_gain =1,4,4,4,4,7 
+#level1,phonepn_gain1.
+#level2,phonepn_gain4.
+#
+#
+#phonepn_gain 0~7 	3dB/step
+#mixer_gain   0~7   	1.5dB/step
+#hp_gain      0~63     	1dB/step
+#spk_gain     0~31    	1.5dB/step
+#line_gain    0~31   	1.5dB/step
+
+
+
+################Phone down stream##################################
+[PHONE_EARPIECE]
+phonepn_gain 	=1,4,4,4,4,7
+mixer_gain   	=3,3,3,4,5,7
+hp_gain  	=60,60,60,60,60,60
+
+[PHONE_HEADSET]
+phonepn_gain 	=1,4,4,4,4,7
+mixer_gain   	=3,3,3,4,5,7
+hp_gain 	=20,25,30,35,35,35
+
+[PHONE_SPEAKER]
+phonepn_gain 	=1,4,4,4,4,7
+mixer_gain   	=3,3,3,4,5,7
+spk_gain  	=25,50,53,56,58,60
+
+#,mic
+#,,,
+#,plan one 
+[BLUETOOTH_UP]
+pcm_vol		=8
+
+
+
+##############Analog FM####################################
+[FM_HEADSET]
+line_gain   	=2,3,4,5,6,7
+hp_gain  	=48,50,52,56,58,61
+
+[FM_SPEAKER]
+line_gain   	=2,3,4,5,6,7
+spk_gain  	=20,50,53,56,58,60
+
+
+
+
diff --git a/softwinner/common/rild/ip-down b/softwinner/common/rild/ip-down
index 188afff..666e21f 100755
--- a/softwinner/common/rild/ip-down
+++ b/softwinner/common/rild/ip-down
@@ -14,3 +14,4 @@ NAME=${LINKNAME:-"$1"}
 #/system/bin/setprop "net.dns2" "" 
 /system/bin/setprop "net.$NAME.local-ip" "" 
 /system/bin/setprop "net.$NAME.remote-ip" "" 
+/system/bin/setprop "net.$NAME.gw" ""
diff --git a/softwinner/common/rild/ip-up b/softwinner/common/rild/ip-up
index 48f600a..02d1868 100755
--- a/softwinner/common/rild/ip-up
+++ b/softwinner/common/rild/ip-up
@@ -23,4 +23,5 @@ NAME=${LINKNAME:-"$1"}
 /system/bin/setprop "net.$NAME.dns2" "$DNS2" 
 /system/bin/setprop "net.$NAME.local-ip" "$IPLOCAL" 
 /system/bin/setprop "net.$NAME.remote-ip" "$IPREMOTE" 
+/system/bin/setprop "net.$NAME.gw" "$IPREMOTE" 
 
diff --git a/softwinner/common/rild/libhuawei-ril.so b/softwinner/common/rild/libhuawei-ril.so
new file mode 100644
index 0000000000000000000000000000000000000000..0d0b983a99d5d4ec8312c6dfd856d5e12292692d
GIT binary patch
literal 120556
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

literal 0
HcmV?d00001

diff --git a/softwinner/common/sw-common.mk b/softwinner/common/sw-common.mk
index 02912d0..2f8255b 100755
--- a/softwinner/common/sw-common.mk
+++ b/softwinner/common/sw-common.mk
@@ -12,7 +12,8 @@ PRODUCT_COPY_FILES += \
 	device/softwinner/common/bin/busybox:system/bin/busybox	
 
 PRODUCT_COPY_FILES += \
-	device/softwinner/common/hardware/audio/audio_policy.conf:system/etc/audio_policy.conf
+	device/softwinner/common/hardware/audio/audio_policy.conf:system/etc/audio_policy.conf \
+	device/softwinner/common/hardware/audio/phone_volume.conf:system/etc/phone_volume.conf
 
 # 3G Data Card Configuration Flie
 PRODUCT_COPY_FILES += \
@@ -23,6 +24,7 @@ PRODUCT_COPY_FILES += \
 	device/softwinner/common/rild/usb_modeswitch:system/bin/usb_modeswitch \
 	device/softwinner/common/rild/usb_modeswitch.sh:system/bin/usb_modeswitch.sh \
 	device/softwinner/common/rild/apns-conf_sdk.xml:system/etc/apns-conf.xml \
+	device/softwinner/common/rild/apns-conf_sdk.xml:system/lib/libhuawei-ril.so \
 	device/softwinner/common/rild/libsoftwinner-ril.so:system/lib/libsoftwinner-ril.so
 
 # usb modeswitch File
diff --git a/softwinner/sugar-standard/overlay/frameworks/base/core/res/res/values/config.xml b/softwinner/sugar-standard/overlay/frameworks/base/core/res/res/values/config.xml
index 115d7d2..09a0d8e 100755
--- a/softwinner/sugar-standard/overlay/frameworks/base/core/res/res/values/config.xml
+++ b/softwinner/sugar-standard/overlay/frameworks/base/core/res/res/values/config.xml
@@ -45,7 +45,7 @@
          PackageManager.FEATURE_TELEPHONY system feature, which is
          available on *any* device with a telephony radio, even if the
          device is data-only. -->
-    <bool name="config_voice_capable">false</bool>
+    <bool name="config_voice_capable">true</bool>
     <!-- List of regexpressions describing the interface (if any) that represent tetherable
          bluetooth interfaces.  If the device doesn't want to support tethering over bluetooth this
          should be empty. -->
diff --git a/softwinner/sugar-standard/overlay/frameworks/base/packages/SettingsProvider/res/values/defaults.xml b/softwinner/sugar-standard/overlay/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
index 7b46606..9c777cc 100755
--- a/softwinner/sugar-standard/overlay/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
+++ b/softwinner/sugar-standard/overlay/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
@@ -169,4 +169,6 @@
 
     <!-- Default for Settings.Secure.USER_SETUP_COMPLETE -->
     <bool name="def_user_setup_complete">false</bool>
+
+    <string name="def_display_output_format" translatable="false">VGA 1024 x 768</string>
 </resources>
diff --git a/softwinner/sugar-standard/sugar_standard.mk b/softwinner/sugar-standard/sugar_standard.mk
index d50d1e6..69af9f1 100755
--- a/softwinner/sugar-standard/sugar_standard.mk
+++ b/softwinner/sugar-standard/sugar_standard.mk
@@ -21,7 +21,8 @@ PRODUCT_COPY_FILES += \
 	device/softwinner/sugar-standard/init.sun7i.usb.rc:root/init.sun7i.usb.rc \
 	device/softwinner/sugar-standard/camera.cfg:system/etc/camera.cfg \
 	device/softwinner/sugar-standard/media_profiles.xml:system/etc/media_profiles.xml \
-	frameworks/native/data/etc/android.hardware.camera.xml:system/etc/permissions/android.hardware.camera.xml
+	frameworks/native/data/etc/android.hardware.camera.xml:system/etc/permissions/android.hardware.camera.xml \
+	frameworks/native/data/etc/android.hardware.camera.autofocus.xml:system/etc/permissions/android.hardware.camera.autofocus.xml
 
 #input device config
 PRODUCT_COPY_FILES += \
@@ -37,8 +38,11 @@ PRODUCT_COPY_FILES += \
 	device/softwinner/sugar-standard/vold.fstab:system/etc/vold.fstab
 	
 PRODUCT_PACKAGES += \
-	TvdLauncher \
     Bluetooth \
+	Mms \
+	VoiceDialer \
+	# TvdLauncher \
+
 #	TSCalibration2
 #support rmvb
 #PRODUCT_COPY_FILES += \
@@ -80,6 +84,9 @@ PRODUCT_COPY_FILES += \
 	hardware/broadcom/wlan/firmware/ap6210/fw_bcm40181a2_p2p.bin:system/vendor/modules/fw_bcm40181a2_p2p.bin \
 	hardware/broadcom/wlan/firmware/ap6210/nvram_ap6210.txt:system/vendor/modules/nvram_ap6210.txt \
 	hardware/broadcom/wlan/firmware/ap6210/bcm20710a1.hcd:system/vendor/modules/bcm20710a1.hcd
+
+PRODUCT_COPY_FILES += \
+	frameworks/native/data/etc/android.hardware.telephony.gsm.xml:system/etc/permissions/android.hardware.telephony.gsm.xml
 	
 PRODUCT_PROPERTY_OVERRIDES += \
 	dalvik.vm.heapsize=256m \
@@ -89,11 +96,9 @@ PRODUCT_PROPERTY_OVERRIDES += \
 	dalvik.vm.heapminfree=2m \
 	dalvik.vm.heapmaxfree=8m \
 	persist.sys.usb.config=mass_storage,adb \
-	ro.property.tabletUI=true \
+	ro.property.tabletUI=false \
 	ro.udisk.lable=sugar \
 	ro.product.firmware=v1.2 \
-	ro.sw.defaultlauncherpackage=com.softwinner.launcher \
-	ro.sw.defaultlauncherclass=com.softwinner.launcher.Launcher \
 	audio.output.active=AUDIO_CODEC \
 	audio.input.active=AUDIO_CODEC \
 	ro.audio.multi.output=true \
@@ -107,11 +112,21 @@ PRODUCT_PROPERTY_OVERRIDES += \
     ro.softmouse.rightbtn.code=-1 \
     ro.sw.shortpressleadshut=false \
     ro.settings.support.gps=false \
-    ro.sw.videotrimming=1
+    ro.sw.videotrimming=1 \
+	ro.sf.lcd_density=200 \
+    ro.com.android.dataroaming=false \
+	rild.libargs=-d/dev/ttyUSB2 \
+	rild.libpath=/system/lib/libhuawei-ril.so \
+	audio.without.earpiece=1 \
+	ro.sw.embeded.telephony=true \
+	ro.sw.audio.codec_plan_name=PLAN_THREE \
+	ro.sw.audio.bp_device_name=mu709 \
+	# ro.sw.defaultlauncherpackage=com.softwinner.launcher \
+	# ro.sw.defaultlauncherclass=com.softwinner.launcher.Launcher \
 
 $(call inherit-product-if-exists, device/softwinner/sugar-standard/modules/modules.mk)
 
-PRODUCT_CHARACTERISTICS := tablet
+PRODUCT_CHARACTERISTICS := phone
 
 # Overrides
 PRODUCT_BRAND  := softwinners
diff --git a/softwinner/wing-common/ProductCommon.mk b/softwinner/wing-common/ProductCommon.mk
index 255274a..4169e6b 100644
--- a/softwinner/wing-common/ProductCommon.mk
+++ b/softwinner/wing-common/ProductCommon.mk
@@ -15,6 +15,8 @@ PRODUCT_PACKAGES += \
 PRODUCT_PACKAGES += \
 	audio.primary.exDroid \
 	audio.a2dp.default \
+	audio.r_submix.default \
+	audio.usb.default \
 	libaudioutils \
 	libcedarxbase \
 	libcedarxosal \
@@ -99,7 +101,7 @@ PRODUCT_COPY_FILES += \
     frameworks/native/data/etc/android.hardware.wifi.xml:system/etc/permissions/android.hardware.wifi.xml \
     frameworks/native/data/etc/android.hardware.touchscreen.xml:system/etc/permissions/android.hardware.touchscreen.xml \
 #    No tultitouch on homlet or dongle, modify by huanglong
-#    frameworks/native/data/etc/android.hardware.touchscreen.multitouch.distinct.xml:system/etc/permissions/android.hardware.touchscreen.multitouch.distinct.xml \
+    frameworks/native/data/etc/android.hardware.touchscreen.multitouch.distinct.xml:system/etc/permissions/android.hardware.touchscreen.multitouch.distinct.xml \
 #    No Gps on homlet or dongle, modify by huanglong    
 #    frameworks/native/data/etc/android.hardware.location.gps.xml:system/etc/permissions/android.hardware.location.gps.xml
 
@@ -117,19 +119,19 @@ PRODUCT_COPY_FILES += \
 PRODUCT_PROPERTY_OVERRIDES += \
 	ro.kernel.android.checkjni=0 \
 	persist.sys.timezone=Asia/Shanghai \
-	persist.sys.language=zh \
-	persist.sys.country=CN \
+	persist.sys.language=en \
+	persist.sys.country=SG \
 	wifi.interface=wlan0 \
 	wifi.supplicant_scan_interval=15 \
 	debug.egl.hw=1 \
 	ro.display.switch=1 \
 	ro.opengles.version=131072 \
-	rild.libargs=-d/dev/ttyUSB2 \
-	rild.libpath=/system/lib/libsoftwinner-ril.so \
 	keyguard.no_require_sim=true \
 	persist.sys.strictmode.visual=0 \
 	persist.sys.strictmode.disable=1 \
-	hwui.render_dirty_regions=false
+	hwui.render_dirty_regions=false \
+	# rild.libargs=-d/dev/ttyUSB2 \
+	# rild.libpath=/system/lib/libsoftwinner-ril.so \
 
 PRODUCT_PROPERTY_OVERRIDES += \
 	drm.service.enabled=false
@@ -151,8 +153,8 @@ PRODUCT_COPY_FILES += \
 	$(call find-copy-subdir-files,*,$(LOCAL_PATH)/apkdata/txt2epub,system/txt2epub) 
 
 #googleservice default disable,change by Bruce Wang
-#PRODUCT_COPY_FILES += \
-#  $(call find-copy-subdir-files,*,$(LOCAL_PATH)/googleservice/gapps-jb-20130301-signed/system,system)
+PRODUCT_COPY_FILES += \
+	$(call find-copy-subdir-files,*,$(LOCAL_PATH)/googleservice/gapps-jb-20130301-signed/system,system)
 
 # Overrides
 PRODUCT_BRAND  := softwinners
-- 
1.7.9.5

